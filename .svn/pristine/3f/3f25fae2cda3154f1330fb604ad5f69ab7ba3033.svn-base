{"version":3,"sources":["webpack:///static/js/44.bc7fe003206a95f49c0c.js","webpack:///./~/_echarts@3.8.5@echarts/lib/chart/treemap/helper.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/DataZoomModel.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/DataZoomView.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/helper.js","webpack:///./~/_echarts@3.8.5@echarts/lib/chart/helper/Line.js","webpack:///./~/_echarts@3.8.5@echarts/lib/chart/helper/LineDraw.js","webpack:///./~/_echarts@3.8.5@echarts/lib/chart/helper/LinePath.js","webpack:///./~/_echarts@3.8.5@echarts/lib/chart/treemap.js","webpack:///./~/_echarts@3.8.5@echarts/lib/chart/treemap/Breadcrumb.js","webpack:///./~/_echarts@3.8.5@echarts/lib/chart/treemap/TreemapSeries.js","webpack:///./~/_echarts@3.8.5@echarts/lib/chart/treemap/TreemapView.js","webpack:///./~/_echarts@3.8.5@echarts/lib/chart/treemap/treemapAction.js","webpack:///./~/_echarts@3.8.5@echarts/lib/chart/treemap/treemapLayout.js","webpack:///./~/_echarts@3.8.5@echarts/lib/chart/treemap/treemapVisual.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/AxisProxy.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/InsideZoomModel.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/InsideZoomView.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/SliderZoomModel.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/SliderZoomView.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/dataZoomAction.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/dataZoomProcessor.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/roams.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/dataZoom/typeDefaulter.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/markLine.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/marker/MarkLineModel.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/marker/MarkLineView.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/marker/MarkerModel.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/marker/MarkerView.js","webpack:///./~/_echarts@3.8.5@echarts/lib/component/marker/markerHelper.js","webpack:///./~/_echarts@3.8.5@echarts/lib/data/Tree.js","webpack:///./~/_echarts@3.8.5@echarts/lib/data/helper/linkList.js","webpack:///./~/_echarts@3.8.5@echarts/lib/util/animation.js"],"names":["webpackJsonp","533","module","exports","__webpack_require__","retrieveTargetInfo","payload","seriesModel","type","root","getData","tree","targetNode","contains","node","targetNodeId","getNodeById","getPathToRoot","path","parentNode","push","reverse","aboveViewRoot","viewRoot","viewPath","zrUtil","indexOf","wrapTreePathInfo","treePathInfo","nodeDataIndex","dataIndex","name","value","getRawValue","561","retrieveRaw","option","ret","each","hasOwnProperty","updateRangeUse","dataZoomModel","rawOption","rangePropMode","_rangePropMode","rangeModeInOption","get","names","index","percentSpecified","valueSpecified","_config","echarts","__DEV__","env","modelUtil","helper","AxisProxy","eachAxisDim","DataZoomModel","extendComponentModel","dependencies","defaultOption","zlevel","z","orient","xAxisIndex","yAxisIndex","filterMode","throttle","start","end","startValue","endValue","minSpan","maxSpan","minValueSpan","maxValueSpan","rangeMode","init","parentModel","ecModel","this","_dataIntervalByAxis","_dataInfo","_axisProxies","textStyleModel","_autoThrottle","mergeDefaultAndTheme","doInit","mergeOption","newOption","merge","thisOption","canvasSupported","realtime","_setDefaultThrottle","getModel","_resetTarget","_giveAxisProxies","axisProxies","eachTargetAxis","dimNames","axisIndex","axisModel","dependentModels","axis","axisProxy","__dzAxisProxy","autoMode","_judgeAutoMode","axisIndexName","normalizeToArray","_autoSetAxisIndex","_autoSetOrient","hasIndexSpecified","autoAxisIndex","dimName","length","singleAxis","singleAxisModel","singleAxisIndex","componentIndex","axisIndices","axisModels","i","len","eachSeries","_isSeriesHasAllAxesTypeOf","axisId","queryComponents","mainType","id","dim","axisType","is","seriesAxisIndex","globalOption","animation","animationDurationUpdate","getFirstTargetAxisModel","firstAxisModel","indices","callback","context","call","getAxisProxy","getAxisModel","setRawRange","opt","ignoreUpdateRangeUsg","getPercentRange","findRepresentativeAxisProxy","getDataPercentWindow","getValueRange","axisDimName","getDataValueWindow","key","hostedBy","getRangePropMode","slice","_default","562","ComponentView","extend","render","api","getTargetCoordInfo","save","coordModel","store","coordIndex","item","model","coordSysLists","getComponent","getCoordSysModel","563","isCoordSupported","coordType","COORDS","createNameEach","attrs","capitalNames","map","formatUtil","capitalFirst","capitalAttrs","nameObj","capital","j","createLinkedNodesFinder","forEachNode","forEachEdgeType","edgeIdGetter","isNodeAbsorded","result","nodes","isLinked","hasLink","edgeType","edgeId","records","absorb","sourceNode","processSingleNode","existsLink","AXIS_DIMS","647","makeSymbolTypeKey","symbolCategory","createSymbol","lineData","idx","color","getItemVisual","symbolType","symbolSize","isArray","symbolPath","symbolUtil","createLine","points","line","LinePath","setLinePoints","shape","targetShape","p1","p2","cp1","x1","y1","x2","y2","percent","cpx1","cpy1","NaN","updateSymbolAndLabelBeforeLineUpdate","lineGroup","symbolFrom","childOfName","symbolTo","label","ignore","invScale","parent","scale","__dirty","fromPos","pointAt","toPos","d","vector","sub","normalize","attr","tangent","tangentAt","Math","PI","atan2","textPosition","textAlign","textVerticalAlign","distance","__position","halfPercent","n","cp","rotation","style","__verticalAlign","__textAlign","position","Line","seriesScope","graphic","Group","_createLine","_number","round","SYMBOL_CATEGORIES","lineProto","prototype","beforeUpdate","hostModel","linePoints","getItemLayout","initProps","add","Text","symbol","_updateCommonStl","updateData","target","updateProps","remove","lineStyle","hoverLineStyle","labelModel","hoverLabelModel","hasItemOption","itemModel","getItemModel","getLineStyle","visualColor","visualOpacity","retrieve3","opacity","useStyle","defaults","strokeNoScale","fill","stroke","hoverStyle","setColor","setStyle","defaultLabelColor","defaultText","normalText","emphasisText","showLabel","getShallow","hoverShowLabel","rawVal","getName","isFinite","retrieve2","getFormattedLabel","dataType","labelStyle","setTextStyle","text","autoColor","textFill","getTextColor","fontStyle","fontWeight","fontSize","fontFamily","setHoverStyle","highlight","trigger","downplay","updateLayout","linePath","dirty","inherits","648","isPointNaN","pt","isNaN","lineNeedsDraw","pts","LineDraw","ctor","_ctor","LineGroup","group","lineDrawProto","oldLineData","_lineData","LineCtor","diff","setItemGraphicEl","update","newIdx","oldIdx","getItemGraphicEl","execute","eachItemGraphicEl","el","removeAll","649","isLine","vec2","straightLineProto","bezierCurveProto","BezierCurve","extendShape","buildPath","ctx","t","p","650","treemapVisual","treemapLayout","registerVisual","registerLayout","651","Breadcrumb","containerGroup","makeItemPoints","x","y","itemWidth","itemHeight","head","tail","ARRAY_LENGTH","splice","packEventData","itemNode","eventData","componentType","componentSubType","seriesIndex","seriesName","seriesType","selfType","nodeData","layout","_helper","constructor","onSelect","thisGroup","normalStyleModel","layoutParam","pos","left","right","top","bottom","box","width","getWidth","height","getHeight","emptyItemWidth","totalWidth","renderList","_prepare","_renderContent","positionElement","textRect","getTextRect","max","TEXT_PADDING","lastX","availableSize","getAvailableSize","Polygon","getItemStyle","lineJoin","textFont","getFont","onclick","curry","652","completeTreeValue","dataNode","sum","children","child","childValue","thisValue","setDefault","levels","globalColorList","hasColorDefine","levelDefine","Model","modelColor","SeriesModel","Tree","_format","encodeHTML","addCommas","layoutMode","_viewRoot","progressive","hoverLayerThreshold","Infinity","sort","clipWindow","squareRatio","sqrt","leafDepth","drillDownIcon","zoomToNodeRatio","roam","nodeClick","animationEasing","breadcrumb","show","itemStyle","normal","borderColor","borderWidth","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","textStyle","emphasis","padding","ellipsis","upperLabel","verticalAlign","colorAlpha","colorSaturation","gapWidth","borderColorSaturation","visualDimension","visualMin","visualMax","colorMappingBy","visibleMin","childrenVisibleMin","getInitialData","data","treeOption","createTree","optionUpdated","resetViewRoot","formatTooltip","formattedValue","getDataParams","params","apply","arguments","getNodeByDataIndex","setLayoutInfo","layoutInfo","mapIdToIndex","idIndexMap","_idIndexMap","createHashMap","_idIndexMapCount","set","getViewRoot","653","createStorage","nodeGroup","background","content","renderNode","thisStorage","oldStorage","reRoot","lastsForAnimation","willInvisibleEls","thisNode","oldNode","parentGroup","depth","updateStyle","element","cb","thisInvisible","invisible","__tmWillVisible","prepareText","normalStyle","emphasisStyle","upperLabelRect","nodeModel","retrieve","thisLayout","isLeafRoot","iconChar","normalLabelModel","PATH_UPPERLABEL_NORMAL","PATH_LABEL_NOAMAL","emphasisLabelModel","PATH_UPPERLABEL_EMPHASIS","PATH_LABEL_EMPHASIS","isShow","setLabelStyle","isRectText","clone","truncate","outerWidth","outerHeight","minChar","giveGraphic","storageName","Ctor","oldRawIndex","lasts","prepareAnimationWhenHasOld","calculateZ","__tmDepth","__tmStorageName","prepareAnimationWhenNoOld","thisRawIndex","old","lastCfg","direction","parentOldX","parentOldY","parentOldBg","getRawIndex","fadein","getLayout","isInView","thisWidth","thisHeight","thisViewChildren","viewChildren","upperHeight","isParent","itemStyleNormalModel","itemStyleEmphasisModel","__tmNodeWidth","__tmNodeHeight","isAboveViewRoot","bg","Rect","Z_BG","useUpperLabel","setShape","visualBorderColor","getVisual","emphasisBorderColor","getItemStyleNormal","getItemStyleEmphasis","upperLabelWidth","Z_CONTENT","contentWidth","contentHeight","culling","zInLevel","zb","Z_BASE","DataDiffer","RoamController","BoundingRect","matrix","animationUtil","makeStyleMapper","bind","lineWidth","extendChartView","o","_containerGroup","_storage","_oldTree","_breadcrumb","_controller","_state","models","findComponents","subType","query","targetInfo","payloadType","isInit","rootNodeGroup","_giveContainerGroup","renderResult","_doRender","renderFinally","_doAnimation","_resetController","_renderBreadcrumb","_initEvents","dualTravel","oldViewChildren","sameTree","getKey","getId","processNode","newIndex","oldIndex","doRenderNode","isRemoved","willDeleteEls","els","thisTree","oldTree","storage","delEls","__tmWillDelete","duration","easing","animationWrap","createWrap","rawIndex","targetX","targetY","last","done","controller","getZr","enable","on","_onPan","_onZoom","rect","setPointerChecker","e","contain","_clearController","dispose","dx","dy","abs","rootLayout","dispatchAction","from","uid","seriesId","rootRect","mouseX","mouseY","m","create","translate","applyTransform","findTarget","offsetX","offsetY","_rootToNode","_zoomToNode","hostTree","link","linkTarget","window","open","eachNode","order","bgEl","point","transformCoordToLocal","654","noop","actionTypes","registerAction","handleRootToNode","originViewRoot","eachComponent","655","condition","ecWidth","ecHeight","seriesOption","getLayoutRect","getBoxLayoutParams","size","containerWidth","parsePercent","retrieveValue","containerHeight","viewAbovePath","rootSize","estimateRootSize","options","clearLayouts","viewRootLayout","area","setLayout","squarify","getValue","dataExtent","treeRoot","calculateRootPosition","prunning","hideChildren","PATH_BORDER_WIDTH","halfGapWidth","PATH_GAP_WIDTH","upperLabelHeight","getUpperLabelHeight","layoutOffset","layoutOffsetUpper","mathMax","totalArea","initChildren","rowFixedLength","mathMin","best","row","score","worst","pop","orderBy","overLeafDepth","filter","info","statistic","filterByThreshold","orderedChildren","deletePoint","a","b","dimension","ratio","areaMax","areaMin","squareArea","f","flush","idx0WhenH","idx1WhenH","xy","wh","rowOtherLength","rowLen","nodeLayout","step","wh1","remain","modWH","wh0","currNode","defaultSize","viewArea","siblings","currNodeValue","pow","MAX_SAFE_INTEGER","defaultPosition","targetCenter","clipRect","nodeInViewAbovePath","intersect","childClipRect","PATH_UPPER_LABEL_SHOW","PATH_UPPER_LABEL_HEIGHT","min","656","seriesItemStyleModel","ITEM_STYLE_NORMAL","travelTree","levelModels","levelModel","getAncestors","designatedVisual","levelItemStyles","viewRootAncestors","thisNodeColor","nodeItemStyleModel","levelItemStyle","visuals","buildVisuals","calculateColor","calculateBorderColor","setVisual","mapping","buildVisualMapping","mapVisual","visualName","val","getValueVisualDefine","zrColor","modifyHSL","modifyAlpha","rangeVisual","getRangeVisual","visual","range","mappingMethod","loop","VisualMapping","__drColorMappingBy","childVisuals","mappingType","mapValueToVisual","657","658","calculateDataExtent","axisDim","seriesModels","seriesData","coordDimToDataDim","seriesExtent","getDataExtent","fixExtentByAxis","getMin","isCategoryAxis","axisDataLen","getMax","setAxisModel","isRestore","percentWindow","_percentWindow","valueWindow","_valueWindow","precision","numberUtil","getPixelPrecision","useOrigin","setRange","toFixed","setMinMaxSpan","minMaxSpan","_minMaxSpan","_dataZoomModel","minMax","valueSpan","parse","_dataExtent","linearMap","asc","_dimName","_axisIndex","getTargetSeriesModels","getOtherAxisModel","otherAxisDim","coordSysIndexName","isCartesian","foundOtherAxisModel","otherAxisModel","getMinMaxSpan","calculateDataWindow","percentExtent","prop","boundValue","boundPercent","reset","dataWindow","restore","filterData","isInWindow","dataDims","filterSelf","leftOut","rightOut","hasValue","thisHasValue","thisLeftOut","thisRightOut","setData","659","disabled","zoomLock","zoomOnMouseWheel","moveOnMouseMove","preventDefaultMouseMove","660","DataZoomView","sliderMove","roams","InsideZoomView","_range","superApply","shouldRecordRange","coordInfoList","coordSysName","allCoordIds","coordInfo","generateCoordId","dataZoomOption","register","coordId","containsPoint","coordinateSystem","containPoint","dataZoomId","throttleRate","panGetRange","zoomGetRange","roamControllerOpt","unregister","oldX","oldY","newX","newY","directionInfo","getDirectionInfo","percentDelta","signal","pixel","pixelLength","percentPoint","pixelStart","grid","oldPoint","newPoint","getRect","inverse","polar","radiusExtent","getRadiusAxis","getExtent","angleExtent","getAngleAxis","pointToCoord","661","SliderZoomModel","backgroundColor","dataBackground","areaStyle","fillerColor","handleIcon","handleSize","handleStyle","labelPrecision","labelFormatter","showDetail","showDataShadow","662","getOtherDim","thisDim","radius","angle","getCursor","eventTool","HORIZONTAL","LABEL_GAP","SHOW_DATA_SHADOW_SERIES_TYPE","SliderZoomView","_displayables","_orient","_handleEnds","_size","_handleWidth","_handleHeight","_location","_dragging","_dataShadowInfo","createOrUpdate","_buildView","_updateView","clear","_resetLocation","_resetInterval","barGroup","_renderBackground","_renderHandle","_renderDataShadow","_positionGroup","coordRect","_findCoordRect","ecSize","positionInfo","layoutParams","getLayoutParams","layoutRect","location","targetAxisModel","otherAxisInverse","getBoundingRect","_getViewExtent","silent","z2","_onClickPanelClick","_prepareDataShadowInfo","series","getRawData","otherDim","getShadowDim","otherDataExtent","otherOffset","lastIsEmpty","otherShadowExtent","thisShadowExtent","areaPoints","count","thisCoord","stride","isEmpty","otherCoord","getAreaStyle","Polyline","thisAxis","coordSys","getOtherAxis","displaybles","handles","handleLabels","filler","draggable","cursor","drift","_onDragMove","onmousemove","stop","event","ondragstart","_showDataInfo","ondragend","_onDragEnd","onmouseover","onmouseout","subPixelOptimizeRect","handleIndex","createIcon","bRect","handleColor","viewExtent","_updateInterval","delta","handleEnds","viewExtend","nonRealtime","handleInterval","handle","handleHeight","_updateDataInfo","setLabel","barTransform","getTransform","transformDirection","offset","textPoint","orderedHandleEnds","labelTexts","dataInterval","_formatLabel","valueStr","getLabel","isFunction","isString","replace","showOrHide","getLocalTransform","vertex","_dispatchZoomAction","localPoint","center","663","linkedNodesFinder","effectedModels","664","resetSingleAxis","filterSingleAxis","registerProcessor","percentRange","valueRange","665","dataZoomInfo","giveStore","theDataZoomId","theCoordId","record","dataZoomInfos","cleanStore","createController","controllerParams","mergeControllerParams","controlType","throttleUtil","batch","zr","ATTR","newRecord","onPan","onZoom","wrapAndDispatch","getRange","typePriority","true","move","false","undefined","oneType","666","registerSubTypeDefaulter","667","registerPreprocessor","markLine","668","MarkerModel","tooltip","669","isInifinity","ifMarkLineHasOnlyDim","dimIndex","fromCoord","toCoord","otherDimIndex","dimensions","getAxis","containData","markLineFilter","coord","markerHelper","dataFilter","updateSingleMarkerEndLayout","isFrom","xPx","yPx","getMarkerPosition","getValues","dims","dataToPoint","xAxis","yAxis","toGlobalCoord","setItemLayout","createList","mlModel","coordDimsInfos","coordDim","getDimensionInfo","fromData","List","toData","optData","markLineTransform","dimValueGetter","initData","to","MarkerView","mlType","valueDataDim","axisInfo","getAxisInfo","valueAxis","numCalculate","valueIndex","baseIndex","mlFrom","mlTo","dataTransform","markLineModel","mlData","__from","__to","markerGroupMap","renderSeries","updateDataVisualAndLayout","setItemVisual","lineDrawMap","lineDraw","lineColor","fromSymbolSize","fromSymbol","toSymbolSize","toSymbol","traverse","dataModel","__keep","670","fillLabel","defaultEmphasis","extraOpt","createdBySelf","isAnimationEnabled","hostSeries","__hostSeries","newOpt","modelPropName","markerOpt","markerModel","Array","join","html","_data","mixin","dataFormatMixin","671","extendComponentView","markerModelKey","672","hasXOrY","parseFloat","hasXAndY","getPrecision","valueAxisDim","stackedOn","markerTypeCalculatorWithExtent","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","indicesOfNearest","markerTypeCalculator","baseAxis","baseDataDim","radiusAxis","angleAxis","dataDim","valueDim","getDimension","dataDimToCoordDim","getBaseAxis","average","673","levelOptions","leavesOption","_nodes","leavesModel","addChild","linkList","completeDimensions","TreeNode","suppressVisitSub","updateDepthAndHeight","res","includeSelf","ancestors","getLevelModel","isExpand","getLeavesModel","ignoreParent","getNodeByName","clearItemLayouts","dataRoot","treeOptions","buildHierarchy","dimMax","listData","leaves","dimCount","list","mainData","struct","structAttr","674","datas","main","datasAttr","linkAll","TRANSFERABLE_METHODS","methodName","wrapMethod","transferInjection","cloneShallowInjection","CHANGABLE_METHODS","changeInjection","assert","isMainData","DATAS","linkSingle","MAIN_DATA","cloneShallow","getLinkedData","675","doneCallback","elExistsMap","time","delay","animateTo"],"mappings":"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","file":"static/js/44.bc7fe003206a95f49c0c.js","sourcesContent":["webpackJsonp([44],{\n\n/***/ 533:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nfunction retrieveTargetInfo(payload, seriesModel) {\n  if (payload && (payload.type === 'treemapZoomToNode' || payload.type === 'treemapRootToNode')) {\n    var root = seriesModel.getData().tree.root;\n    var targetNode = payload.targetNode;\n\n    if (targetNode && root.contains(targetNode)) {\n      return {\n        node: targetNode\n      };\n    }\n\n    var targetNodeId = payload.targetNodeId;\n\n    if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {\n      return {\n        node: targetNode\n      };\n    }\n  }\n} // Not includes the given node at the last item.\n\n\nfunction getPathToRoot(node) {\n  var path = [];\n\n  while (node) {\n    node = node.parentNode;\n    node && path.push(node);\n  }\n\n  return path.reverse();\n}\n\nfunction aboveViewRoot(viewRoot, node) {\n  var viewPath = getPathToRoot(viewRoot);\n  return zrUtil.indexOf(viewPath, node) >= 0;\n} // From root to the input node (the input node will be included).\n\n\nfunction wrapTreePathInfo(node, seriesModel) {\n  var treePathInfo = [];\n\n  while (node) {\n    var nodeDataIndex = node.dataIndex;\n    treePathInfo.push({\n      name: node.name,\n      dataIndex: nodeDataIndex,\n      value: seriesModel.getRawValue(nodeDataIndex)\n    });\n    node = node.parentNode;\n  }\n\n  treePathInfo.reverse();\n  return treePathInfo;\n}\n\nexports.retrieveTargetInfo = retrieveTargetInfo;\nexports.getPathToRoot = getPathToRoot;\nexports.aboveViewRoot = aboveViewRoot;\nexports.wrapTreePathInfo = wrapTreePathInfo;\n\n/***/ }),\n\n/***/ 561:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(5);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(1);\n\nvar zrUtil = __webpack_require__(0);\n\nvar env = __webpack_require__(11);\n\nvar modelUtil = __webpack_require__(4);\n\nvar helper = __webpack_require__(563);\n\nvar AxisProxy = __webpack_require__(658);\n\nvar each = zrUtil.each;\nvar eachAxisDim = helper.eachAxisDim;\nvar DataZoomModel = echarts.extendComponentModel({\n  type: 'dataZoom',\n  dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    zlevel: 0,\n    z: 4,\n    // Higher than normal component (z: 2).\n    orient: null,\n    // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n    xAxisIndex: null,\n    // Default the first horizontal category axis.\n    yAxisIndex: null,\n    // Default the first vertical category axis.\n    filterMode: 'filter',\n    // Possible values: 'filter' or 'empty' or 'weakFilter'.\n    // 'filter': data items which are out of window will be removed. This option is\n    //          applicable when filtering outliers. For each data item, it will be\n    //          filtered if one of the relevant dimensions is out of the window.\n    // 'weakFilter': data items which are out of window will be removed. This option\n    //          is applicable when filtering outliers. For each data item, it will be\n    //          filtered only if all  of the relevant dimensions are out of the same\n    //          side of the window.\n    // 'empty': data items which are out of window will be set to empty.\n    //          This option is applicable when user should not neglect\n    //          that there are some data items out of window.\n    // 'none': Do not filter.\n    // Taking line chart as an example, line will be broken in\n    // the filtered points when filterModel is set to 'empty', but\n    // be connected when set to 'filter'.\n    throttle: null,\n    // Dispatch action by the fixed rate, avoid frequency.\n    // default 100. Do not throttle when use null/undefined.\n    // If animation === true and animationDurationUpdate > 0,\n    // default value is 100, otherwise 20.\n    start: 0,\n    // Start percent. 0 ~ 100\n    end: 100,\n    // End percent. 0 ~ 100\n    startValue: null,\n    // Start value. If startValue specified, start is ignored.\n    endValue: null,\n    // End value. If endValue specified, end is ignored.\n    minSpan: null,\n    // 0 ~ 100\n    maxSpan: null,\n    // 0 ~ 100\n    minValueSpan: null,\n    // The range of dataZoom can not be smaller than that.\n    maxValueSpan: null,\n    // The range of dataZoom can not be larger than that.\n    rangeMode: null // Array, can be 'value' or 'percent'.\n\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel) {\n    /**\n     * key like x_0, y_1\n     * @private\n     * @type {Object}\n     */\n    this._dataIntervalByAxis = {};\n    /**\n     * @private\n     */\n\n    this._dataInfo = {};\n    /**\n     * key like x_0, y_1\n     * @private\n     */\n\n    this._axisProxies = {};\n    /**\n     * @readOnly\n     */\n\n    this.textStyleModel;\n    /**\n     * @private\n     */\n\n    this._autoThrottle = true;\n    /**\n     * 'percent' or 'value'\n     * @private\n     */\n\n    this._rangePropMode = ['percent', 'percent'];\n    var rawOption = retrieveRaw(option);\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (newOption) {\n    var rawOption = retrieveRaw(newOption); //FIX #2591\n\n    zrUtil.merge(this.option, newOption, true);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @protected\n   */\n  doInit: function (rawOption) {\n    var thisOption = this.option; // Disable realtime view update if canvas is not supported.\n\n    if (!env.canvasSupported) {\n      thisOption.realtime = false;\n    }\n\n    this._setDefaultThrottle(rawOption);\n\n    updateRangeUse(this, rawOption);\n    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = null;\n      } // Otherwise do nothing and use the merge result.\n\n    }, this);\n    this.textStyleModel = this.getModel('textStyle');\n\n    this._resetTarget();\n\n    this._giveAxisProxies();\n  },\n\n  /**\n   * @private\n   */\n  _giveAxisProxies: function () {\n    var axisProxies = this._axisProxies;\n    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n      var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.\n\n      var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.\n      axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME\n      // dispose __dzAxisProxy\n\n      axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetTarget: function () {\n    var thisOption = this.option;\n\n    var autoMode = this._judgeAutoMode();\n\n    eachAxisDim(function (dimNames) {\n      var axisIndexName = dimNames.axisIndex;\n      thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);\n    }, this);\n\n    if (autoMode === 'axisIndex') {\n      this._autoSetAxisIndex();\n    } else if (autoMode === 'orient') {\n      this._autoSetOrient();\n    }\n  },\n\n  /**\n   * @private\n   */\n  _judgeAutoMode: function () {\n    // Auto set only works for setOption at the first time.\n    // The following is user's reponsibility. So using merged\n    // option is OK.\n    var thisOption = this.option;\n    var hasIndexSpecified = false;\n    eachAxisDim(function (dimNames) {\n      // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occured.\n      if (thisOption[dimNames.axisIndex] != null) {\n        hasIndexSpecified = true;\n      }\n    }, this);\n    var orient = thisOption.orient;\n\n    if (orient == null && hasIndexSpecified) {\n      return 'orient';\n    } else if (!hasIndexSpecified) {\n      if (orient == null) {\n        thisOption.orient = 'horizontal';\n      }\n\n      return 'axisIndex';\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetAxisIndex: function () {\n    var autoAxisIndex = true;\n    var orient = this.get('orient', true);\n    var thisOption = this.option;\n    var dependentModels = this.dependentModels;\n\n    if (autoAxisIndex) {\n      // Find axis that parallel to dataZoom as default.\n      var dimName = orient === 'vertical' ? 'y' : 'x';\n\n      if (dependentModels[dimName + 'Axis'].length) {\n        thisOption[dimName + 'AxisIndex'] = [0];\n        autoAxisIndex = false;\n      } else {\n        each(dependentModels.singleAxis, function (singleAxisModel) {\n          if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n            autoAxisIndex = false;\n          }\n        });\n      }\n    }\n\n    if (autoAxisIndex) {\n      // Find the first category axis as default. (consider polar)\n      eachAxisDim(function (dimNames) {\n        if (!autoAxisIndex) {\n          return;\n        }\n\n        var axisIndices = [];\n        var axisModels = this.dependentModels[dimNames.axis];\n\n        if (axisModels.length && !axisIndices.length) {\n          for (var i = 0, len = axisModels.length; i < len; i++) {\n            if (axisModels[i].get('type') === 'category') {\n              axisIndices.push(i);\n            }\n          }\n        }\n\n        thisOption[dimNames.axisIndex] = axisIndices;\n\n        if (axisIndices.length) {\n          autoAxisIndex = false;\n        }\n      }, this);\n    }\n\n    if (autoAxisIndex) {\n      // FIXME\n      // 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），\n      // 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？\n      // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n      // dataZoom component auto adopts series that reference to\n      // both xAxis and yAxis which type is 'value'.\n      this.ecModel.eachSeries(function (seriesModel) {\n        if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n          eachAxisDim(function (dimNames) {\n            var axisIndices = thisOption[dimNames.axisIndex];\n            var axisIndex = seriesModel.get(dimNames.axisIndex);\n            var axisId = seriesModel.get(dimNames.axisId);\n            var axisModel = seriesModel.ecModel.queryComponents({\n              mainType: dimNames.axis,\n              index: axisIndex,\n              id: axisId\n            })[0];\n            axisIndex = axisModel.componentIndex;\n\n            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n              axisIndices.push(axisIndex);\n            }\n          });\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetOrient: function () {\n    var dim; // Find the first axis\n\n    this.eachTargetAxis(function (dimNames) {\n      !dim && (dim = dimNames.name);\n    }, this);\n    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n  },\n\n  /**\n   * @private\n   */\n  _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n    // FIXME\n    // 需要series的xAxisIndex和yAxisIndex都首先自动设置上。\n    // 例如series.type === scatter时。\n    var is = true;\n    eachAxisDim(function (dimNames) {\n      var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n      var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n      if (!axisModel || axisModel.get('type') !== axisType) {\n        is = false;\n      }\n    }, this);\n    return is;\n  },\n\n  /**\n   * @private\n   */\n  _setDefaultThrottle: function (rawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (rawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  },\n\n  /**\n   * @public\n   */\n  getFirstTargetAxisModel: function () {\n    var firstAxisModel;\n    eachAxisDim(function (dimNames) {\n      if (firstAxisModel == null) {\n        var indices = this.get(dimNames.axisIndex);\n\n        if (indices.length) {\n          firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n        }\n      }\n    }, this);\n    return firstAxisModel;\n  },\n\n  /**\n   * @public\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n   */\n  eachTargetAxis: function (callback, context) {\n    var ecModel = this.ecModel;\n    eachAxisDim(function (dimNames) {\n      each(this.get(dimNames.axisIndex), function (axisIndex) {\n        callback.call(context, dimNames, axisIndex, this, ecModel);\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n   */\n  getAxisProxy: function (dimName, axisIndex) {\n    return this._axisProxies[dimName + '_' + axisIndex];\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/model/Model} If not found, return null/undefined.\n   */\n  getAxisModel: function (dimName, axisIndex) {\n    var axisProxy = this.getAxisProxy(dimName, axisIndex);\n    return axisProxy && axisProxy.getAxisModel();\n  },\n\n  /**\n   * If not specified, set to undefined.\n   *\n   * @public\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   * @param {boolean} [ignoreUpdateRangeUsg=false]\n   */\n  setRawRange: function (opt, ignoreUpdateRangeUsg) {\n    var option = this.option;\n    each([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // If only one of 'start' and 'startValue' is not null/undefined, the other\n      // should be cleared, which enable clear the option.\n      // If both of them are not set, keep option with the original value, which\n      // enable use only set start but not set end when calling `dispatchAction`.\n      // The same as 'end' and 'endValue'.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        option[names[0]] = opt[names[0]];\n        option[names[1]] = opt[names[1]];\n      }\n    }, this);\n    !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n  },\n\n  /**\n   * @public\n   * @return {Array.<number>} [startPercent, endPercent]\n   */\n  getPercentRange: function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  },\n\n  /**\n   * @public\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n   *\n   * @param {string} [axisDimName]\n   * @param {number} [axisIndex]\n   * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n   */\n  getValueRange: function (axisDimName, axisIndex) {\n    if (axisDimName == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n    }\n  },\n\n  /**\n   * @public\n   * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n   *      corresponding to the axisModel\n   * @return {module:echarts/component/dataZoom/AxisProxy}\n   */\n  findRepresentativeAxisProxy: function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    } // Find the first hosted axisProxy\n\n\n    var axisProxies = this._axisProxies;\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    } // If no hosted axis find not hosted axisProxy.\n    // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n    // and the option.start or option.end settings are different. The percentRange\n    // should follow axisProxy.\n    // (We encounter this problem in toolbox data zoom.)\n\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    }\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getRangePropMode: function () {\n    return this._rangePropMode.slice();\n  }\n});\n\nfunction retrieveRaw(option) {\n  var ret = {};\n  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n\nfunction updateRangeUse(dataZoomModel, rawOption) {\n  var rangePropMode = dataZoomModel._rangePropMode;\n  var rangeModeInOption = dataZoomModel.get('rangeMode');\n  each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n    var percentSpecified = rawOption[names[0]] != null;\n    var valueSpecified = rawOption[names[1]] != null;\n\n    if (percentSpecified && !valueSpecified) {\n      rangePropMode[index] = 'percent';\n    } else if (!percentSpecified && valueSpecified) {\n      rangePropMode[index] = 'value';\n    } else if (rangeModeInOption) {\n      rangePropMode[index] = rangeModeInOption[index];\n    } else if (percentSpecified) {\n      // percentSpecified && valueSpecified\n      rangePropMode[index] = 'percent';\n    } // else remain its original setting.\n\n  });\n}\n\nvar _default = DataZoomModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 562:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ComponentView = __webpack_require__(196);\n\nvar _default = ComponentView.extend({\n  type: 'dataZoom',\n  render: function (dataZoomModel, ecModel, api, payload) {\n    this.dataZoomModel = dataZoomModel;\n    this.ecModel = ecModel;\n    this.api = api;\n  },\n\n  /**\n   * Find the first target coordinate system.\n   *\n   * @protected\n   * @return {Object} {\n   *                   grid: [\n   *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n   *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n   *                       ...\n   *                   ],  // cartesians must not be null/undefined.\n   *                   polar: [\n   *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n   *                       ...\n   *                   ],  // polars must not be null/undefined.\n   *                   singleAxis: [\n   *                       {model: coord0, axisModels: [], coordIndex: 0}\n   *                   ]\n   */\n  getTargetCoordInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var ecModel = this.ecModel;\n    var coordSysLists = {};\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n\n      if (axisModel) {\n        var coordModel = axisModel.getCoordSysModel();\n        coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);\n      }\n    }, this);\n\n    function save(coordModel, axisModel, store, coordIndex) {\n      var item;\n\n      for (var i = 0; i < store.length; i++) {\n        if (store[i].model === coordModel) {\n          item = store[i];\n          break;\n        }\n      }\n\n      if (!item) {\n        store.push(item = {\n          model: coordModel,\n          axisModels: [],\n          coordIndex: coordIndex\n        });\n      }\n\n      item.axisModels.push(axisModel);\n    }\n\n    return coordSysLists;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 563:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar formatUtil = __webpack_require__(7);\n\nvar AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.\n\nvar COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n/**\n * @param {string} coordType\n * @return {boolean}\n */\n\nfunction isCoordSupported(coordType) {\n  return zrUtil.indexOf(COORDS, coordType) >= 0;\n}\n/**\n * Create \"each\" method to iterate names.\n *\n * @pubilc\n * @param  {Array.<string>} names\n * @param  {Array.<string>=} attrs\n * @return {Function}\n */\n\n\nfunction createNameEach(names, attrs) {\n  names = names.slice();\n  var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n  attrs = (attrs || []).slice();\n  var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n  return function (callback, context) {\n    zrUtil.each(names, function (name, index) {\n      var nameObj = {\n        name: name,\n        capital: capitalNames[index]\n      };\n\n      for (var j = 0; j < attrs.length; j++) {\n        nameObj[attrs[j]] = name + capitalAttrs[j];\n      }\n\n      callback.call(context, nameObj);\n    });\n  };\n}\n/**\n * Iterate each dimension name.\n *\n * @public\n * @param {Function} callback The parameter is like:\n *                            {\n *                                name: 'angle',\n *                                capital: 'Angle',\n *                                axis: 'angleAxis',\n *                                axisIndex: 'angleAixs',\n *                                index: 'angleIndex'\n *                            }\n * @param {Object} context\n */\n\n\nvar eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n/**\n * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n * dataZoomModels and 'links' make up one or more graphics.\n * This function finds the graphic where the source dataZoomModel is in.\n *\n * @public\n * @param {Function} forEachNode Node iterator.\n * @param {Function} forEachEdgeType edgeType iterator\n * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n */\n\nfunction createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {\n  return function (sourceNode) {\n    var result = {\n      nodes: [],\n      records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n\n    };\n    forEachEdgeType(function (edgeType) {\n      result.records[edgeType.name] = {};\n    });\n\n    if (!sourceNode) {\n      return result;\n    }\n\n    absorb(sourceNode, result);\n    var existsLink;\n\n    do {\n      existsLink = false;\n      forEachNode(processSingleNode);\n    } while (existsLink);\n\n    function processSingleNode(node) {\n      if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n        absorb(node, result);\n        existsLink = true;\n      }\n    }\n\n    return result;\n  };\n\n  function isNodeAbsorded(node, result) {\n    return zrUtil.indexOf(result.nodes, node) >= 0;\n  }\n\n  function isLinked(node, result) {\n    var hasLink = false;\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] && (hasLink = true);\n      });\n    });\n    return hasLink;\n  }\n\n  function absorb(node, result) {\n    result.nodes.push(node);\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] = true;\n      });\n    });\n  }\n}\n\nexports.isCoordSupported = isCoordSupported;\nexports.createNameEach = createNameEach;\nexports.eachAxisDim = eachAxisDim;\nexports.createLinkedNodesFinder = createLinkedNodesFinder;\n\n/***/ }),\n\n/***/ 647:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar vector = __webpack_require__(6);\n\nvar symbolUtil = __webpack_require__(25);\n\nvar LinePath = __webpack_require__(649);\n\nvar graphic = __webpack_require__(2);\n\nvar _number = __webpack_require__(3);\n\nvar round = _number.round;\n\n/**\n * @module echarts/chart/helper/Line\n */\nvar SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];\n\nfunction makeSymbolTypeKey(symbolCategory) {\n  return '_' + symbolCategory + 'Type';\n}\n/**\n * @inner\n */\n\n\nfunction createSymbol(name, lineData, idx) {\n  var color = lineData.getItemVisual(idx, 'color');\n  var symbolType = lineData.getItemVisual(idx, name);\n  var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n\n  if (!symbolType || symbolType === 'none') {\n    return;\n  }\n\n  if (!zrUtil.isArray(symbolSize)) {\n    symbolSize = [symbolSize, symbolSize];\n  }\n\n  var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);\n  symbolPath.name = name;\n  return symbolPath;\n}\n\nfunction createLine(points) {\n  var line = new LinePath({\n    name: 'line'\n  });\n  setLinePoints(line.shape, points);\n  return line;\n}\n\nfunction setLinePoints(targetShape, points) {\n  var p1 = points[0];\n  var p2 = points[1];\n  var cp1 = points[2];\n  targetShape.x1 = p1[0];\n  targetShape.y1 = p1[1];\n  targetShape.x2 = p2[0];\n  targetShape.y2 = p2[1];\n  targetShape.percent = 1;\n\n  if (cp1) {\n    targetShape.cpx1 = cp1[0];\n    targetShape.cpy1 = cp1[1];\n  } else {\n    targetShape.cpx1 = NaN;\n    targetShape.cpy1 = NaN;\n  }\n}\n\nfunction updateSymbolAndLabelBeforeLineUpdate() {\n  var lineGroup = this;\n  var symbolFrom = lineGroup.childOfName('fromSymbol');\n  var symbolTo = lineGroup.childOfName('toSymbol');\n  var label = lineGroup.childOfName('label'); // Quick reject\n\n  if (!symbolFrom && !symbolTo && label.ignore) {\n    return;\n  }\n\n  var invScale = 1;\n  var parentNode = this.parent;\n\n  while (parentNode) {\n    if (parentNode.scale) {\n      invScale /= parentNode.scale[0];\n    }\n\n    parentNode = parentNode.parent;\n  }\n\n  var line = lineGroup.childOfName('line'); // If line not changed\n  // FIXME Parent scale changed\n\n  if (!this.__dirty && !line.__dirty) {\n    return;\n  }\n\n  var percent = line.shape.percent;\n  var fromPos = line.pointAt(0);\n  var toPos = line.pointAt(percent);\n  var d = vector.sub([], toPos, fromPos);\n  vector.normalize(d, d);\n\n  if (symbolFrom) {\n    symbolFrom.attr('position', fromPos);\n    var tangent = line.tangentAt(0);\n    symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));\n    symbolFrom.attr('scale', [invScale * percent, invScale * percent]);\n  }\n\n  if (symbolTo) {\n    symbolTo.attr('position', toPos);\n    var tangent = line.tangentAt(1);\n    symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));\n    symbolTo.attr('scale', [invScale * percent, invScale * percent]);\n  }\n\n  if (!label.ignore) {\n    label.attr('position', toPos);\n    var textPosition;\n    var textAlign;\n    var textVerticalAlign;\n    var distance = 5 * invScale; // End\n\n    if (label.__position === 'end') {\n      textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];\n      textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';\n      textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';\n    } // Middle\n    else if (label.__position === 'middle') {\n        var halfPercent = percent / 2;\n        var tangent = line.tangentAt(halfPercent);\n        var n = [tangent[1], -tangent[0]];\n        var cp = line.pointAt(halfPercent);\n\n        if (n[1] > 0) {\n          n[0] = -n[0];\n          n[1] = -n[1];\n        }\n\n        textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];\n        textAlign = 'center';\n        textVerticalAlign = 'bottom';\n        var rotation = -Math.atan2(tangent[1], tangent[0]);\n\n        if (toPos[0] < fromPos[0]) {\n          rotation = Math.PI + rotation;\n        }\n\n        label.attr('rotation', rotation);\n      } // Start\n      else {\n          textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];\n          textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';\n          textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';\n        }\n\n    label.attr({\n      style: {\n        // Use the user specified text align and baseline first\n        textVerticalAlign: label.__verticalAlign || textVerticalAlign,\n        textAlign: label.__textAlign || textAlign\n      },\n      position: textPosition,\n      scale: [invScale, invScale]\n    });\n  }\n}\n/**\n * @constructor\n * @extends {module:zrender/graphic/Group}\n * @alias {module:echarts/chart/helper/Line}\n */\n\n\nfunction Line(lineData, idx, seriesScope) {\n  graphic.Group.call(this);\n\n  this._createLine(lineData, idx, seriesScope);\n}\n\nvar lineProto = Line.prototype; // Update symbol position and rotation\n\nlineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;\n\nlineProto._createLine = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var linePoints = lineData.getItemLayout(idx);\n  var line = createLine(linePoints);\n  line.shape.percent = 0;\n  graphic.initProps(line, {\n    shape: {\n      percent: 1\n    }\n  }, seriesModel, idx);\n  this.add(line);\n  var label = new graphic.Text({\n    name: 'label'\n  });\n  this.add(label);\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbol = createSymbol(symbolCategory, lineData, idx); // symbols must added after line to make sure\n    // it will be updated after line#update.\n    // Or symbol position and rotation update in line#beforeUpdate will be one frame slow\n\n    this.add(symbol);\n    this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);\n  }, this);\n\n  this._updateCommonStl(lineData, idx, seriesScope);\n};\n\nlineProto.updateData = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var line = this.childOfName('line');\n  var linePoints = lineData.getItemLayout(idx);\n  var target = {\n    shape: {}\n  };\n  setLinePoints(target.shape, linePoints);\n  graphic.updateProps(line, target, seriesModel, idx);\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbolType = lineData.getItemVisual(idx, symbolCategory);\n    var key = makeSymbolTypeKey(symbolCategory); // Symbol changed\n\n    if (this[key] !== symbolType) {\n      this.remove(this.childOfName(symbolCategory));\n      var symbol = createSymbol(symbolCategory, lineData, idx);\n      this.add(symbol);\n    }\n\n    this[key] = symbolType;\n  }, this);\n\n  this._updateCommonStl(lineData, idx, seriesScope);\n};\n\nlineProto._updateCommonStl = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var line = this.childOfName('line');\n  var lineStyle = seriesScope && seriesScope.lineStyle;\n  var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; // Optimization for large dataset\n\n  if (!seriesScope || lineData.hasItemOption) {\n    var itemModel = lineData.getItemModel(idx);\n    lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();\n    hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n    labelModel = itemModel.getModel('label.normal');\n    hoverLabelModel = itemModel.getModel('label.emphasis');\n  }\n\n  var visualColor = lineData.getItemVisual(idx, 'color');\n  var visualOpacity = zrUtil.retrieve3(lineData.getItemVisual(idx, 'opacity'), lineStyle.opacity, 1);\n  line.useStyle(zrUtil.defaults({\n    strokeNoScale: true,\n    fill: 'none',\n    stroke: visualColor,\n    opacity: visualOpacity\n  }, lineStyle));\n  line.hoverStyle = hoverLineStyle; // Update symbol\n\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbol = this.childOfName(symbolCategory);\n\n    if (symbol) {\n      symbol.setColor(visualColor);\n      symbol.setStyle({\n        opacity: visualOpacity\n      });\n    }\n  }, this);\n  var showLabel = labelModel.getShallow('show');\n  var hoverShowLabel = hoverLabelModel.getShallow('show');\n  var label = this.childOfName('label');\n  var defaultLabelColor;\n  var defaultText;\n  var normalText;\n  var emphasisText;\n\n  if (showLabel || hoverShowLabel) {\n    var rawVal = seriesModel.getRawValue(idx);\n    defaultText = rawVal == null ? defaultText = lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal;\n    defaultLabelColor = visualColor || '#000';\n    normalText = zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType), defaultText);\n    emphasisText = zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), normalText);\n  } // label.afterUpdate = lineAfterUpdate;\n\n\n  if (showLabel) {\n    var labelStyle = graphic.setTextStyle(label.style, labelModel, {\n      text: normalText\n    }, {\n      autoColor: defaultLabelColor\n    });\n    label.__textAlign = labelStyle.textAlign;\n    label.__verticalAlign = labelStyle.textVerticalAlign; // 'start', 'middle', 'end'\n\n    label.__position = labelModel.get('position') || 'middle';\n  } else {\n    label.setStyle('text', null);\n  }\n\n  if (hoverShowLabel) {\n    // Only these properties supported in this emphasis style here.\n    label.hoverStyle = {\n      text: emphasisText,\n      textFill: hoverLabelModel.getTextColor(true),\n      // For merging hover style to normal style, do not use\n      // `hoverLabelModel.getFont()` here.\n      fontStyle: hoverLabelModel.getShallow('fontStyle'),\n      fontWeight: hoverLabelModel.getShallow('fontWeight'),\n      fontSize: hoverLabelModel.getShallow('fontSize'),\n      fontFamily: hoverLabelModel.getShallow('fontFamily')\n    };\n  } else {\n    label.hoverStyle = {\n      text: null\n    };\n  }\n\n  label.ignore = !showLabel && !hoverShowLabel;\n  graphic.setHoverStyle(this);\n};\n\nlineProto.highlight = function () {\n  this.trigger('emphasis');\n};\n\nlineProto.downplay = function () {\n  this.trigger('normal');\n};\n\nlineProto.updateLayout = function (lineData, idx) {\n  this.setLinePoints(lineData.getItemLayout(idx));\n};\n\nlineProto.setLinePoints = function (points) {\n  var linePath = this.childOfName('line');\n  setLinePoints(linePath.shape, points);\n  linePath.dirty();\n};\n\nzrUtil.inherits(Line, graphic.Group);\nvar _default = Line;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 648:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(2);\n\nvar LineGroup = __webpack_require__(647);\n\n/**\n * @module echarts/chart/helper/LineDraw\n */\nfunction isPointNaN(pt) {\n  return isNaN(pt[0]) || isNaN(pt[1]);\n}\n\nfunction lineNeedsDraw(pts) {\n  return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);\n}\n/**\n * @alias module:echarts/component/marker/LineDraw\n * @constructor\n */\n\n\nfunction LineDraw(ctor) {\n  this._ctor = ctor || LineGroup;\n  this.group = new graphic.Group();\n}\n\nvar lineDrawProto = LineDraw.prototype;\n/**\n * @param {module:echarts/data/List} lineData\n */\n\nlineDrawProto.updateData = function (lineData) {\n  var oldLineData = this._lineData;\n  var group = this.group;\n  var LineCtor = this._ctor;\n  var hostModel = lineData.hostModel;\n  var seriesScope = {\n    lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(),\n    hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(),\n    labelModel: hostModel.getModel('label.normal'),\n    hoverLabelModel: hostModel.getModel('label.emphasis')\n  };\n  lineData.diff(oldLineData).add(function (idx) {\n    if (!lineNeedsDraw(lineData.getItemLayout(idx))) {\n      return;\n    }\n\n    var lineGroup = new LineCtor(lineData, idx, seriesScope);\n    lineData.setItemGraphicEl(idx, lineGroup);\n    group.add(lineGroup);\n  }).update(function (newIdx, oldIdx) {\n    var lineGroup = oldLineData.getItemGraphicEl(oldIdx);\n\n    if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) {\n      group.remove(lineGroup);\n      return;\n    }\n\n    if (!lineGroup) {\n      lineGroup = new LineCtor(lineData, newIdx, seriesScope);\n    } else {\n      lineGroup.updateData(lineData, newIdx, seriesScope);\n    }\n\n    lineData.setItemGraphicEl(newIdx, lineGroup);\n    group.add(lineGroup);\n  }).remove(function (idx) {\n    group.remove(oldLineData.getItemGraphicEl(idx));\n  }).execute();\n  this._lineData = lineData;\n};\n\nlineDrawProto.updateLayout = function () {\n  var lineData = this._lineData;\n  lineData.eachItemGraphicEl(function (el, idx) {\n    el.updateLayout(lineData, idx);\n  }, this);\n};\n\nlineDrawProto.remove = function () {\n  this.group.removeAll();\n};\n\nvar _default = LineDraw;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 649:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(2);\n\nvar vec2 = __webpack_require__(6);\n\n/**\n * Line path for bezier and straight line draw\n */\nvar straightLineProto = graphic.Line.prototype;\nvar bezierCurveProto = graphic.BezierCurve.prototype;\n\nfunction isLine(shape) {\n  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);\n}\n\nvar _default = graphic.extendShape({\n  type: 'ec-line',\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    percent: 1,\n    cpx1: null,\n    cpy1: null\n  },\n  buildPath: function (ctx, shape) {\n    (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);\n  },\n  pointAt: function (t) {\n    return isLine(this.shape) ? straightLineProto.pointAt.call(this, t) : bezierCurveProto.pointAt.call(this, t);\n  },\n  tangentAt: function (t) {\n    var shape = this.shape;\n    var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 650:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(1);\n\n__webpack_require__(652);\n\n__webpack_require__(653);\n\n__webpack_require__(654);\n\nvar treemapVisual = __webpack_require__(656);\n\nvar treemapLayout = __webpack_require__(655);\n\necharts.registerVisual(treemapVisual);\necharts.registerLayout(treemapLayout);\n\n/***/ }),\n\n/***/ 651:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(2);\n\nvar layout = __webpack_require__(16);\n\nvar zrUtil = __webpack_require__(0);\n\nvar _helper = __webpack_require__(533);\n\nvar wrapTreePathInfo = _helper.wrapTreePathInfo;\nvar TEXT_PADDING = 8;\nvar ITEM_GAP = 8;\nvar ARRAY_LENGTH = 5;\n\nfunction Breadcrumb(containerGroup) {\n  /**\n   * @private\n   * @type {module:zrender/container/Group}\n   */\n  this.group = new graphic.Group();\n  containerGroup.add(this.group);\n}\n\nBreadcrumb.prototype = {\n  constructor: Breadcrumb,\n  render: function (seriesModel, api, targetNode, onSelect) {\n    var model = seriesModel.getModel('breadcrumb');\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n\n    if (!model.get('show') || !targetNode) {\n      return;\n    }\n\n    var normalStyleModel = model.getModel('itemStyle.normal'); // var emphasisStyleModel = model.getModel('itemStyle.emphasis');\n\n    var textStyleModel = normalStyleModel.getModel('textStyle');\n    var layoutParam = {\n      pos: {\n        left: model.get('left'),\n        right: model.get('right'),\n        top: model.get('top'),\n        bottom: model.get('bottom')\n      },\n      box: {\n        width: api.getWidth(),\n        height: api.getHeight()\n      },\n      emptyItemWidth: model.get('emptyItemWidth'),\n      totalWidth: 0,\n      renderList: []\n    };\n\n    this._prepare(targetNode, layoutParam, textStyleModel);\n\n    this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);\n\n    layout.positionElement(thisGroup, layoutParam.pos, layoutParam.box);\n  },\n\n  /**\n   * Prepare render list and total width\n   * @private\n   */\n  _prepare: function (targetNode, layoutParam, textStyleModel) {\n    for (var node = targetNode; node; node = node.parentNode) {\n      var text = node.getModel().get('name');\n      var textRect = textStyleModel.getTextRect(text);\n      var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);\n      layoutParam.totalWidth += itemWidth + ITEM_GAP;\n      layoutParam.renderList.push({\n        node: node,\n        text: text,\n        width: itemWidth\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _renderContent: function (seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {\n    // Start rendering.\n    var lastX = 0;\n    var emptyItemWidth = layoutParam.emptyItemWidth;\n    var height = seriesModel.get('breadcrumb.height');\n    var availableSize = layout.getAvailableSize(layoutParam.pos, layoutParam.box);\n    var totalWidth = layoutParam.totalWidth;\n    var renderList = layoutParam.renderList;\n\n    for (var i = renderList.length - 1; i >= 0; i--) {\n      var item = renderList[i];\n      var itemNode = item.node;\n      var itemWidth = item.width;\n      var text = item.text; // Hdie text and shorten width if necessary.\n\n      if (totalWidth > availableSize.width) {\n        totalWidth -= itemWidth - emptyItemWidth;\n        itemWidth = emptyItemWidth;\n        text = null;\n      }\n\n      var el = new graphic.Polygon({\n        shape: {\n          points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)\n        },\n        style: zrUtil.defaults(normalStyleModel.getItemStyle(), {\n          lineJoin: 'bevel',\n          text: text,\n          textFill: textStyleModel.getTextColor(),\n          textFont: textStyleModel.getFont()\n        }),\n        z: 10,\n        onclick: zrUtil.curry(onSelect, itemNode)\n      });\n      this.group.add(el);\n      packEventData(el, seriesModel, itemNode);\n      lastX += itemWidth + ITEM_GAP;\n    }\n  },\n\n  /**\n   * @override\n   */\n  remove: function () {\n    this.group.removeAll();\n  }\n};\n\nfunction makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {\n  var points = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];\n  !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);\n  !head && points.push([x, y + itemHeight / 2]);\n  return points;\n} // Package custom mouse event.\n\n\nfunction packEventData(el, seriesModel, itemNode) {\n  el.eventData = {\n    componentType: 'series',\n    componentSubType: 'treemap',\n    seriesIndex: seriesModel.componentIndex,\n    seriesName: seriesModel.name,\n    seriesType: 'treemap',\n    selfType: 'breadcrumb',\n    // Distinguish with click event on treemap node.\n    nodeData: {\n      dataIndex: itemNode && itemNode.dataIndex,\n      name: itemNode && itemNode.name\n    },\n    treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)\n  };\n}\n\nvar _default = Breadcrumb;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 652:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar SeriesModel = __webpack_require__(30);\n\nvar Tree = __webpack_require__(673);\n\nvar Model = __webpack_require__(9);\n\nvar _format = __webpack_require__(7);\n\nvar encodeHTML = _format.encodeHTML;\nvar addCommas = _format.addCommas;\n\nvar _helper = __webpack_require__(533);\n\nvar wrapTreePathInfo = _helper.wrapTreePathInfo;\n\nvar _default = SeriesModel.extend({\n  type: 'series.treemap',\n  layoutMode: 'box',\n  dependencies: ['grid', 'polar'],\n\n  /**\n   * @type {module:echarts/data/Tree~Node}\n   */\n  _viewRoot: null,\n  defaultOption: {\n    // Disable progressive rendering\n    progressive: 0,\n    hoverLayerThreshold: Infinity,\n    // center: ['50%', '50%'],          // not supported in ec3.\n    // size: ['80%', '80%'],            // deprecated, compatible with ec2.\n    left: 'center',\n    top: 'middle',\n    right: null,\n    bottom: null,\n    width: '80%',\n    height: '80%',\n    sort: true,\n    // Can be null or false or true\n    // (order by desc default, asc not supported yet (strange effect))\n    clipWindow: 'origin',\n    // Size of clipped window when zooming. 'origin' or 'fullscreen'\n    squareRatio: 0.5 * (1 + Math.sqrt(5)),\n    // golden ratio\n    leafDepth: null,\n    // Nodes on depth from root are regarded as leaves.\n    // Count from zero (zero represents only view root).\n    drillDownIcon: '▶',\n    // Use html character temporarily because it is complicated\n    // to align specialized icon. ▷▶❒❐▼✚\n    zoomToNodeRatio: 0.32 * 0.32,\n    // Be effective when using zoomToNode. Specify the proportion of the\n    // target node area in the view area.\n    roam: true,\n    // true, false, 'scale' or 'zoom', 'move'.\n    nodeClick: 'zoomToNode',\n    // Leaf node click behaviour: 'zoomToNode', 'link', false.\n    // If leafDepth is set and clicking a node which has children but\n    // be on left depth, the behaviour would be changing root. Otherwise\n    // use behavious defined above.\n    animation: true,\n    animationDurationUpdate: 900,\n    animationEasing: 'quinticInOut',\n    breadcrumb: {\n      show: true,\n      height: 22,\n      left: 'center',\n      top: 'bottom',\n      // right\n      // bottom\n      emptyItemWidth: 25,\n      // Width of empty node.\n      itemStyle: {\n        normal: {\n          color: 'rgba(0,0,0,0.7)',\n          //'#5793f3',\n          borderColor: 'rgba(255,255,255,0.7)',\n          borderWidth: 1,\n          shadowColor: 'rgba(150,150,150,1)',\n          shadowBlur: 3,\n          shadowOffsetX: 0,\n          shadowOffsetY: 0,\n          textStyle: {\n            color: '#fff'\n          }\n        },\n        emphasis: {\n          textStyle: {}\n        }\n      }\n    },\n    label: {\n      normal: {\n        show: true,\n        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.\n        distance: 0,\n        padding: 5,\n        position: 'inside',\n        // Can be [5, '5%'] or position stirng like 'insideTopLeft', ...\n        // formatter: null,\n        color: '#fff',\n        ellipsis: true // align\n        // verticalAlign\n\n      }\n    },\n    upperLabel: {\n      // Label when node is parent.\n      normal: {\n        show: false,\n        position: [0, '50%'],\n        height: 20,\n        // formatter: null,\n        color: '#fff',\n        ellipsis: true,\n        // align: null,\n        verticalAlign: 'middle'\n      },\n      emphasis: {\n        show: true,\n        position: [0, '50%'],\n        color: '#fff',\n        ellipsis: true,\n        verticalAlign: 'middle'\n      }\n    },\n    itemStyle: {\n      normal: {\n        color: null,\n        // Can be 'none' if not necessary.\n        colorAlpha: null,\n        // Can be 'none' if not necessary.\n        colorSaturation: null,\n        // Can be 'none' if not necessary.\n        borderWidth: 0,\n        gapWidth: 0,\n        borderColor: '#fff',\n        borderColorSaturation: null // If specified, borderColor will be ineffective, and the\n        // border color is evaluated by color of current node and\n        // borderColorSaturation.\n\n      },\n      emphasis: {}\n    },\n    visualDimension: 0,\n    // Can be 0, 1, 2, 3.\n    visualMin: null,\n    visualMax: null,\n    color: [],\n    // + treemapSeries.color should not be modified. Please only modified\n    // level[n].color (if necessary).\n    // + Specify color list of each level. level[0].color would be global\n    // color list if not specified. (see method `setDefault`).\n    // + But set as a empty array to forbid fetch color from global palette\n    // when using nodeModel.get('color'), otherwise nodes on deep level\n    // will always has color palette set and are not able to inherit color\n    // from parent node.\n    // + TreemapSeries.color can not be set as 'none', otherwise effect\n    // legend color fetching (see seriesColor.js).\n    colorAlpha: null,\n    // Array. Specify color alpha range of each level, like [0.2, 0.8]\n    colorSaturation: null,\n    // Array. Specify color saturation of each level, like [0.2, 0.5]\n    colorMappingBy: 'index',\n    // 'value' or 'index' or 'id'.\n    visibleMin: 10,\n    // If area less than this threshold (unit: pixel^2), node will not\n    // be rendered. Only works when sort is 'asc' or 'desc'.\n    childrenVisibleMin: null,\n    // If area of a node less than this threshold (unit: pixel^2),\n    // grandchildren will not show.\n    // Why grandchildren? If not grandchildren but children,\n    // some siblings show children and some not,\n    // the appearance may be mess and not consistent,\n    levels: [] // Each item: {\n    //     visibleMin, itemStyle, visualDimension, label\n    // }\n    // data: {\n    //      value: [],\n    //      children: [],\n    //      link: 'http://xxx.xxx.xxx',\n    //      target: 'blank' or 'self'\n    // }\n\n  },\n\n  /**\n   * @override\n   */\n  getInitialData: function (option, ecModel) {\n    // Create a virtual root.\n    var root = {\n      name: option.name,\n      children: option.data\n    };\n    completeTreeValue(root);\n    var levels = option.levels || [];\n    levels = option.levels = setDefault(levels, ecModel);\n    var treeOption = {};\n    treeOption.levels = levels; // Make sure always a new tree is created when setOption,\n    // in TreemapView, we check whether oldTree === newTree\n    // to choose mappings approach among old shapes and new shapes.\n\n    return Tree.createTree(root, this, treeOption).data;\n  },\n  optionUpdated: function () {\n    this.resetViewRoot();\n  },\n\n  /**\n   * @override\n   * @param {number} dataIndex\n   * @param {boolean} [mutipleSeries=false]\n   */\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? addCommas(value[0]) : addCommas(value);\n    var name = data.getName(dataIndex);\n    return encodeHTML(name + ': ' + formattedValue);\n  },\n\n  /**\n   * Add tree path to tooltip param\n   *\n   * @override\n   * @param {number} dataIndex\n   * @return {Object}\n   */\n  getDataParams: function (dataIndex) {\n    var params = SeriesModel.prototype.getDataParams.apply(this, arguments);\n    var node = this.getData().tree.getNodeByDataIndex(dataIndex);\n    params.treePathInfo = wrapTreePathInfo(node, this);\n    return params;\n  },\n\n  /**\n   * @public\n   * @param {Object} layoutInfo {\n   *                                x: containerGroup x\n   *                                y: containerGroup y\n   *                                width: containerGroup width\n   *                                height: containerGroup height\n   *                            }\n   */\n  setLayoutInfo: function (layoutInfo) {\n    /**\n     * @readOnly\n     * @type {Object}\n     */\n    this.layoutInfo = this.layoutInfo || {};\n    zrUtil.extend(this.layoutInfo, layoutInfo);\n  },\n\n  /**\n   * @param  {string} id\n   * @return {number} index\n   */\n  mapIdToIndex: function (id) {\n    // A feature is implemented:\n    // index is monotone increasing with the sequence of\n    // input id at the first time.\n    // This feature can make sure that each data item and its\n    // mapped color have the same index between data list and\n    // color list at the beginning, which is useful for user\n    // to adjust data-color mapping.\n\n    /**\n     * @private\n     * @type {Object}\n     */\n    var idIndexMap = this._idIndexMap;\n\n    if (!idIndexMap) {\n      idIndexMap = this._idIndexMap = zrUtil.createHashMap();\n      /**\n       * @private\n       * @type {number}\n       */\n\n      this._idIndexMapCount = 0;\n    }\n\n    var index = idIndexMap.get(id);\n\n    if (index == null) {\n      idIndexMap.set(id, index = this._idIndexMapCount++);\n    }\n\n    return index;\n  },\n  getViewRoot: function () {\n    return this._viewRoot;\n  },\n\n  /**\n   * @param {module:echarts/data/Tree~Node} [viewRoot]\n   */\n  resetViewRoot: function (viewRoot) {\n    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;\n    var root = this.getData().tree.root;\n\n    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {\n      this._viewRoot = root;\n    }\n  }\n});\n/**\n * @param {Object} dataNode\n */\n\n\nfunction completeTreeValue(dataNode) {\n  // Postorder travel tree.\n  // If value of none-leaf node is not set,\n  // calculate it by suming up the value of all children.\n  var sum = 0;\n  zrUtil.each(dataNode.children, function (child) {\n    completeTreeValue(child);\n    var childValue = child.value;\n    zrUtil.isArray(childValue) && (childValue = childValue[0]);\n    sum += childValue;\n  });\n  var thisValue = dataNode.value;\n\n  if (zrUtil.isArray(thisValue)) {\n    thisValue = thisValue[0];\n  }\n\n  if (thisValue == null || isNaN(thisValue)) {\n    thisValue = sum;\n  } // Value should not less than 0.\n\n\n  if (thisValue < 0) {\n    thisValue = 0;\n  }\n\n  zrUtil.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;\n}\n/**\n * set default to level configuration\n */\n\n\nfunction setDefault(levels, ecModel) {\n  var globalColorList = ecModel.get('color');\n\n  if (!globalColorList) {\n    return;\n  }\n\n  levels = levels || [];\n  var hasColorDefine;\n  zrUtil.each(levels, function (levelDefine) {\n    var model = new Model(levelDefine);\n    var modelColor = model.get('color');\n\n    if (model.get('itemStyle.normal.color') || modelColor && modelColor !== 'none') {\n      hasColorDefine = true;\n    }\n  });\n\n  if (!hasColorDefine) {\n    var level0 = levels[0] || (levels[0] = {});\n    level0.color = globalColorList.slice();\n  }\n\n  return levels;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 653:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(1);\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(2);\n\nvar DataDiffer = __webpack_require__(195);\n\nvar helper = __webpack_require__(533);\n\nvar Breadcrumb = __webpack_require__(651);\n\nvar RoamController = __webpack_require__(190);\n\nvar BoundingRect = __webpack_require__(10);\n\nvar matrix = __webpack_require__(26);\n\nvar animationUtil = __webpack_require__(675);\n\nvar makeStyleMapper = __webpack_require__(55);\n\nvar bind = zrUtil.bind;\nvar Group = graphic.Group;\nvar Rect = graphic.Rect;\nvar each = zrUtil.each;\nvar DRAG_THRESHOLD = 3;\nvar PATH_LABEL_NOAMAL = ['label', 'normal'];\nvar PATH_LABEL_EMPHASIS = ['label', 'emphasis'];\nvar PATH_UPPERLABEL_NORMAL = ['upperLabel', 'normal'];\nvar PATH_UPPERLABEL_EMPHASIS = ['upperLabel', 'emphasis'];\nvar Z_BASE = 10; // Should bigger than every z.\n\nvar Z_BG = 1;\nvar Z_CONTENT = 2;\nvar getItemStyleEmphasis = makeStyleMapper([['fill', 'color'], // `borderColor` and `borderWidth` has been occupied,\n// so use `stroke` to indicate the stroke of the rect.\n['stroke', 'strokeColor'], ['lineWidth', 'strokeWidth'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\n\nvar getItemStyleNormal = function (model) {\n  // Normal style props should include emphasis style props.\n  var itemStyle = getItemStyleEmphasis(model); // Clear styles set by emphasis.\n\n  itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;\n  return itemStyle;\n};\n\nvar _default = echarts.extendChartView({\n  type: 'treemap',\n\n  /**\n   * @override\n   */\n  init: function (o, api) {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this._containerGroup;\n    /**\n     * @private\n     * @type {Object.<string, Array.<module:zrender/container/Group>>}\n     */\n\n    this._storage = createStorage();\n    /**\n     * @private\n     * @type {module:echarts/data/Tree}\n     */\n\n    this._oldTree;\n    /**\n     * @private\n     * @type {module:echarts/chart/treemap/Breadcrumb}\n     */\n\n    this._breadcrumb;\n    /**\n     * @private\n     * @type {module:echarts/component/helper/RoamController}\n     */\n\n    this._controller;\n    /**\n     * 'ready', 'animating'\n     * @private\n     */\n\n    this._state = 'ready';\n  },\n\n  /**\n   * @override\n   */\n  render: function (seriesModel, ecModel, api, payload) {\n    var models = ecModel.findComponents({\n      mainType: 'series',\n      subType: 'treemap',\n      query: payload\n    });\n\n    if (zrUtil.indexOf(models, seriesModel) < 0) {\n      return;\n    }\n\n    this.seriesModel = seriesModel;\n    this.api = api;\n    this.ecModel = ecModel;\n    var targetInfo = helper.retrieveTargetInfo(payload, seriesModel);\n    var payloadType = payload && payload.type;\n    var layoutInfo = seriesModel.layoutInfo;\n    var isInit = !this._oldTree;\n    var thisStorage = this._storage; // Mark new root when action is treemapRootToNode.\n\n    var reRoot = payloadType === 'treemapRootToNode' && targetInfo && thisStorage ? {\n      rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],\n      direction: payload.direction\n    } : null;\n\n    var containerGroup = this._giveContainerGroup(layoutInfo);\n\n    var renderResult = this._doRender(containerGroup, seriesModel, reRoot);\n\n    !isInit && (!payloadType || payloadType === 'treemapZoomToNode' || payloadType === 'treemapRootToNode') ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();\n\n    this._resetController(api);\n\n    this._renderBreadcrumb(seriesModel, api, targetInfo);\n  },\n\n  /**\n   * @private\n   */\n  _giveContainerGroup: function (layoutInfo) {\n    var containerGroup = this._containerGroup;\n\n    if (!containerGroup) {\n      // FIXME\n      // 加一层containerGroup是为了clip，但是现在clip功能并没有实现。\n      containerGroup = this._containerGroup = new Group();\n\n      this._initEvents(containerGroup);\n\n      this.group.add(containerGroup);\n    }\n\n    containerGroup.attr('position', [layoutInfo.x, layoutInfo.y]);\n    return containerGroup;\n  },\n\n  /**\n   * @private\n   */\n  _doRender: function (containerGroup, seriesModel, reRoot) {\n    var thisTree = seriesModel.getData().tree;\n    var oldTree = this._oldTree; // Clear last shape records.\n\n    var lastsForAnimation = createStorage();\n    var thisStorage = createStorage();\n    var oldStorage = this._storage;\n    var willInvisibleEls = [];\n    var doRenderNode = zrUtil.curry(renderNode, seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls); // Notice: when thisTree and oldTree are the same tree (see list.cloneShallow),\n    // the oldTree is actually losted, so we can not find all of the old graphic\n    // elements from tree. So we use this stragegy: make element storage, move\n    // from old storage to new storage, clear old storage.\n\n    dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0); // Process all removing.\n\n    var willDeleteEls = clearStorage(oldStorage);\n    this._oldTree = thisTree;\n    this._storage = thisStorage;\n    return {\n      lastsForAnimation: lastsForAnimation,\n      willDeleteEls: willDeleteEls,\n      renderFinally: renderFinally\n    };\n\n    function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {\n      // When 'render' is triggered by action,\n      // 'this' and 'old' may be the same tree,\n      // we use rawIndex in that case.\n      if (sameTree) {\n        oldViewChildren = thisViewChildren;\n        each(thisViewChildren, function (child, index) {\n          !child.isRemoved() && processNode(index, index);\n        });\n      } // Diff hierarchically (diff only in each subtree, but not whole).\n      // because, consistency of view is important.\n      else {\n          new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove(zrUtil.curry(processNode, null)).execute();\n        }\n\n      function getKey(node) {\n        // Identify by name or raw index.\n        return node.getId();\n      }\n\n      function processNode(newIndex, oldIndex) {\n        var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;\n        var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;\n        var group = doRenderNode(thisNode, oldNode, parentGroup, depth);\n        group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);\n      }\n    }\n\n    function clearStorage(storage) {\n      var willDeleteEls = createStorage();\n      storage && each(storage, function (store, storageName) {\n        var delEls = willDeleteEls[storageName];\n        each(store, function (el) {\n          el && (delEls.push(el), el.__tmWillDelete = 1);\n        });\n      });\n      return willDeleteEls;\n    }\n\n    function renderFinally() {\n      each(willDeleteEls, function (els) {\n        each(els, function (el) {\n          el.parent && el.parent.remove(el);\n        });\n      });\n      each(willInvisibleEls, function (el) {\n        el.invisible = true; // Setting invisible is for optimizing, so no need to set dirty,\n        // just mark as invisible.\n\n        el.dirty();\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _doAnimation: function (containerGroup, renderResult, seriesModel, reRoot) {\n    if (!seriesModel.get('animation')) {\n      return;\n    }\n\n    var duration = seriesModel.get('animationDurationUpdate');\n    var easing = seriesModel.get('animationEasing');\n    var animationWrap = animationUtil.createWrap(); // Make delete animations.\n\n    each(renderResult.willDeleteEls, function (store, storageName) {\n      each(store, function (el, rawIndex) {\n        if (el.invisible) {\n          return;\n        }\n\n        var parent = el.parent; // Always has parent, and parent is nodeGroup.\n\n        var target;\n\n        if (reRoot && reRoot.direction === 'drillDown') {\n          target = parent === reRoot.rootNodeGroup // This is the content element of view root.\n          // Only `content` will enter this branch, because\n          // `background` and `nodeGroup` will not be deleted.\n          ? {\n            shape: {\n              x: 0,\n              y: 0,\n              width: parent.__tmNodeWidth,\n              height: parent.__tmNodeHeight\n            },\n            style: {\n              opacity: 0\n            } // Others.\n\n          } : {\n            style: {\n              opacity: 0\n            }\n          };\n        } else {\n          var targetX = 0;\n          var targetY = 0;\n\n          if (!parent.__tmWillDelete) {\n            // Let node animate to right-bottom corner, cooperating with fadeout,\n            // which is appropriate for user understanding.\n            // Divided by 2 for reRoot rolling up effect.\n            targetX = parent.__tmNodeWidth / 2;\n            targetY = parent.__tmNodeHeight / 2;\n          }\n\n          target = storageName === 'nodeGroup' ? {\n            position: [targetX, targetY],\n            style: {\n              opacity: 0\n            }\n          } : {\n            shape: {\n              x: targetX,\n              y: targetY,\n              width: 0,\n              height: 0\n            },\n            style: {\n              opacity: 0\n            }\n          };\n        }\n\n        target && animationWrap.add(el, target, duration, easing);\n      });\n    }); // Make other animations\n\n    each(this._storage, function (store, storageName) {\n      each(store, function (el, rawIndex) {\n        var last = renderResult.lastsForAnimation[storageName][rawIndex];\n        var target = {};\n\n        if (!last) {\n          return;\n        }\n\n        if (storageName === 'nodeGroup') {\n          if (last.old) {\n            target.position = el.position.slice();\n            el.attr('position', last.old);\n          }\n        } else {\n          if (last.old) {\n            target.shape = zrUtil.extend({}, el.shape);\n            el.setShape(last.old);\n          }\n\n          if (last.fadein) {\n            el.setStyle('opacity', 0);\n            target.style = {\n              opacity: 1\n            };\n          } // When animation is stopped for succedent animation starting,\n          // el.style.opacity might not be 1\n          else if (el.style.opacity !== 1) {\n              target.style = {\n                opacity: 1\n              };\n            }\n        }\n\n        animationWrap.add(el, target, duration, easing);\n      });\n    }, this);\n    this._state = 'animating';\n    animationWrap.done(bind(function () {\n      this._state = 'ready';\n      renderResult.renderFinally();\n    }, this)).start();\n  },\n\n  /**\n   * @private\n   */\n  _resetController: function (api) {\n    var controller = this._controller; // Init controller.\n\n    if (!controller) {\n      controller = this._controller = new RoamController(api.getZr());\n      controller.enable(this.seriesModel.get('roam'));\n      controller.on('pan', bind(this._onPan, this));\n      controller.on('zoom', bind(this._onZoom, this));\n    }\n\n    var rect = new BoundingRect(0, 0, api.getWidth(), api.getHeight());\n    controller.setPointerChecker(function (e, x, y) {\n      return rect.contain(x, y);\n    });\n  },\n\n  /**\n   * @private\n   */\n  _clearController: function () {\n    var controller = this._controller;\n\n    if (controller) {\n      controller.dispose();\n      controller = null;\n    }\n  },\n\n  /**\n   * @private\n   */\n  _onPan: function (dx, dy) {\n    if (this._state !== 'animating' && (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD)) {\n      // These param must not be cached.\n      var root = this.seriesModel.getData().tree.root;\n\n      if (!root) {\n        return;\n      }\n\n      var rootLayout = root.getLayout();\n\n      if (!rootLayout) {\n        return;\n      }\n\n      this.api.dispatchAction({\n        type: 'treemapMove',\n        from: this.uid,\n        seriesId: this.seriesModel.id,\n        rootRect: {\n          x: rootLayout.x + dx,\n          y: rootLayout.y + dy,\n          width: rootLayout.width,\n          height: rootLayout.height\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _onZoom: function (scale, mouseX, mouseY) {\n    if (this._state !== 'animating') {\n      // These param must not be cached.\n      var root = this.seriesModel.getData().tree.root;\n\n      if (!root) {\n        return;\n      }\n\n      var rootLayout = root.getLayout();\n\n      if (!rootLayout) {\n        return;\n      }\n\n      var rect = new BoundingRect(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);\n      var layoutInfo = this.seriesModel.layoutInfo; // Transform mouse coord from global to containerGroup.\n\n      mouseX -= layoutInfo.x;\n      mouseY -= layoutInfo.y; // Scale root bounding rect.\n\n      var m = matrix.create();\n      matrix.translate(m, m, [-mouseX, -mouseY]);\n      matrix.scale(m, m, [scale, scale]);\n      matrix.translate(m, m, [mouseX, mouseY]);\n      rect.applyTransform(m);\n      this.api.dispatchAction({\n        type: 'treemapRender',\n        from: this.uid,\n        seriesId: this.seriesModel.id,\n        rootRect: {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _initEvents: function (containerGroup) {\n    containerGroup.on('click', function (e) {\n      if (this._state !== 'ready') {\n        return;\n      }\n\n      var nodeClick = this.seriesModel.get('nodeClick', true);\n\n      if (!nodeClick) {\n        return;\n      }\n\n      var targetInfo = this.findTarget(e.offsetX, e.offsetY);\n\n      if (!targetInfo) {\n        return;\n      }\n\n      var node = targetInfo.node;\n\n      if (node.getLayout().isLeafRoot) {\n        this._rootToNode(targetInfo);\n      } else {\n        if (nodeClick === 'zoomToNode') {\n          this._zoomToNode(targetInfo);\n        } else if (nodeClick === 'link') {\n          var itemModel = node.hostTree.data.getItemModel(node.dataIndex);\n          var link = itemModel.get('link', true);\n          var linkTarget = itemModel.get('target', true) || 'blank';\n          link && window.open(link, linkTarget);\n        }\n      }\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _renderBreadcrumb: function (seriesModel, api, targetInfo) {\n    if (!targetInfo) {\n      targetInfo = seriesModel.get('leafDepth', true) != null ? {\n        node: seriesModel.getViewRoot() // FIXME\n        // better way?\n        // Find breadcrumb tail on center of containerGroup.\n\n      } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);\n\n      if (!targetInfo) {\n        targetInfo = {\n          node: seriesModel.getData().tree.root\n        };\n      }\n    }\n\n    (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group))).render(seriesModel, api, targetInfo.node, bind(onSelect, this));\n\n    function onSelect(node) {\n      if (this._state !== 'animating') {\n        helper.aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({\n          node: node\n        }) : this._zoomToNode({\n          node: node\n        });\n      }\n    }\n  },\n\n  /**\n   * @override\n   */\n  remove: function () {\n    this._clearController();\n\n    this._containerGroup && this._containerGroup.removeAll();\n    this._storage = createStorage();\n    this._state = 'ready';\n    this._breadcrumb && this._breadcrumb.remove();\n  },\n  dispose: function () {\n    this._clearController();\n  },\n\n  /**\n   * @private\n   */\n  _zoomToNode: function (targetInfo) {\n    this.api.dispatchAction({\n      type: 'treemapZoomToNode',\n      from: this.uid,\n      seriesId: this.seriesModel.id,\n      targetNode: targetInfo.node\n    });\n  },\n\n  /**\n   * @private\n   */\n  _rootToNode: function (targetInfo) {\n    this.api.dispatchAction({\n      type: 'treemapRootToNode',\n      from: this.uid,\n      seriesId: this.seriesModel.id,\n      targetNode: targetInfo.node\n    });\n  },\n\n  /**\n   * @public\n   * @param {number} x Global coord x.\n   * @param {number} y Global coord y.\n   * @return {Object} info If not found, return undefined;\n   * @return {number} info.node Target node.\n   * @return {number} info.offsetX x refer to target node.\n   * @return {number} info.offsetY y refer to target node.\n   */\n  findTarget: function (x, y) {\n    var targetInfo;\n    var viewRoot = this.seriesModel.getViewRoot();\n    viewRoot.eachNode({\n      attr: 'viewChildren',\n      order: 'preorder'\n    }, function (node) {\n      var bgEl = this._storage.background[node.getRawIndex()]; // If invisible, there might be no element.\n\n\n      if (bgEl) {\n        var point = bgEl.transformCoordToLocal(x, y);\n        var shape = bgEl.shape; // For performance consideration, dont use 'getBoundingRect'.\n\n        if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {\n          targetInfo = {\n            node: node,\n            offsetX: point[0],\n            offsetY: point[1]\n          };\n        } else {\n          return false; // Suppress visit subtree.\n        }\n      }\n    }, this);\n    return targetInfo;\n  }\n});\n/**\n * @inner\n */\n\n\nfunction createStorage() {\n  return {\n    nodeGroup: [],\n    background: [],\n    content: []\n  };\n}\n/**\n * @inner\n * @return Return undefined means do not travel further.\n */\n\n\nfunction renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {\n  // Whether under viewRoot.\n  if (!thisNode) {\n    // Deleting nodes will be performed finally. This method just find\n    // element from old storage, or create new element, set them to new\n    // storage, and set styles.\n    return;\n  } // -------------------------------------------------------------------\n  // Start of closure variables available in \"Procedures in renderNode\".\n\n\n  var thisLayout = thisNode.getLayout();\n\n  if (!thisLayout || !thisLayout.isInView) {\n    return;\n  }\n\n  var thisWidth = thisLayout.width;\n  var thisHeight = thisLayout.height;\n  var borderWidth = thisLayout.borderWidth;\n  var thisInvisible = thisLayout.invisible;\n  var thisRawIndex = thisNode.getRawIndex();\n  var oldRawIndex = oldNode && oldNode.getRawIndex();\n  var thisViewChildren = thisNode.viewChildren;\n  var upperHeight = thisLayout.upperHeight;\n  var isParent = thisViewChildren && thisViewChildren.length;\n  var itemStyleNormalModel = thisNode.getModel('itemStyle.normal');\n  var itemStyleEmphasisModel = thisNode.getModel('itemStyle.emphasis'); // End of closure ariables available in \"Procedures in renderNode\".\n  // -----------------------------------------------------------------\n  // Node group\n\n  var group = giveGraphic('nodeGroup', Group);\n\n  if (!group) {\n    return;\n  }\n\n  parentGroup.add(group); // x,y are not set when el is above view root.\n\n  group.attr('position', [thisLayout.x || 0, thisLayout.y || 0]);\n  group.__tmNodeWidth = thisWidth;\n  group.__tmNodeHeight = thisHeight;\n\n  if (thisLayout.isAboveViewRoot) {\n    return group;\n  } // Background\n\n\n  var bg = giveGraphic('background', Rect, depth, Z_BG);\n  bg && renderBackground(group, bg, isParent && thisLayout.upperHeight); // No children, render content.\n\n  if (!isParent) {\n    var content = giveGraphic('content', Rect, depth, Z_CONTENT);\n    content && renderContent(group, content);\n  }\n\n  return group; // ----------------------------\n  // | Procedures in renderNode |\n  // ----------------------------\n\n  function renderBackground(group, bg, useUpperLabel) {\n    // For tooltip.\n    bg.dataIndex = thisNode.dataIndex;\n    bg.seriesIndex = seriesModel.seriesIndex;\n    bg.setShape({\n      x: 0,\n      y: 0,\n      width: thisWidth,\n      height: thisHeight\n    });\n    var visualBorderColor = thisNode.getVisual('borderColor', true);\n    var emphasisBorderColor = itemStyleEmphasisModel.get('borderColor');\n    updateStyle(bg, function () {\n      var normalStyle = getItemStyleNormal(itemStyleNormalModel);\n      normalStyle.fill = visualBorderColor;\n      var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);\n      emphasisStyle.fill = emphasisBorderColor;\n\n      if (useUpperLabel) {\n        var upperLabelWidth = thisWidth - 2 * borderWidth;\n        prepareText(normalStyle, emphasisStyle, visualBorderColor, upperLabelWidth, upperHeight, {\n          x: borderWidth,\n          y: 0,\n          width: upperLabelWidth,\n          height: upperHeight\n        });\n      } // For old bg.\n      else {\n          normalStyle.text = emphasisStyle.text = null;\n        }\n\n      bg.setStyle(normalStyle);\n      graphic.setHoverStyle(bg, emphasisStyle);\n    });\n    group.add(bg);\n  }\n\n  function renderContent(group, content) {\n    // For tooltip.\n    content.dataIndex = thisNode.dataIndex;\n    content.seriesIndex = seriesModel.seriesIndex;\n    var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);\n    var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);\n    content.culling = true;\n    content.setShape({\n      x: borderWidth,\n      y: borderWidth,\n      width: contentWidth,\n      height: contentHeight\n    });\n    var visualColor = thisNode.getVisual('color', true);\n    updateStyle(content, function () {\n      var normalStyle = getItemStyleNormal(itemStyleNormalModel);\n      normalStyle.fill = visualColor;\n      var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);\n      prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight);\n      content.setStyle(normalStyle);\n      graphic.setHoverStyle(content, emphasisStyle);\n    });\n    group.add(content);\n  }\n\n  function updateStyle(element, cb) {\n    if (!thisInvisible) {\n      // If invisible, do not set visual, otherwise the element will\n      // change immediately before animation. We think it is OK to\n      // remain its origin color when moving out of the view window.\n      cb();\n\n      if (!element.__tmWillVisible) {\n        element.invisible = false;\n      }\n    } else {\n      // Delay invisible setting utill animation finished,\n      // avoid element vanish suddenly before animation.\n      !element.invisible && willInvisibleEls.push(element);\n    }\n  }\n\n  function prepareText(normalStyle, emphasisStyle, visualColor, width, height, upperLabelRect) {\n    var nodeModel = thisNode.getModel();\n    var text = zrUtil.retrieve(seriesModel.getFormattedLabel(thisNode.dataIndex, 'normal', null, null, upperLabelRect ? 'upperLabel' : 'label'), nodeModel.get('name'));\n\n    if (!upperLabelRect && thisLayout.isLeafRoot) {\n      var iconChar = seriesModel.get('drillDownIcon', true);\n      text = iconChar ? iconChar + ' ' + text : text;\n    }\n\n    var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);\n    var emphasisLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_EMPHASIS : PATH_LABEL_EMPHASIS);\n    var isShow = normalLabelModel.getShallow('show');\n    graphic.setLabelStyle(normalStyle, emphasisStyle, normalLabelModel, emphasisLabelModel, {\n      defaultText: isShow ? text : null,\n      autoColor: visualColor,\n      isRectText: true\n    });\n    upperLabelRect && (normalStyle.textRect = zrUtil.clone(upperLabelRect));\n    normalStyle.truncate = isShow && normalLabelModel.get('ellipsis') ? {\n      outerWidth: width,\n      outerHeight: height,\n      minChar: 2\n    } : null;\n  }\n\n  function giveGraphic(storageName, Ctor, depth, z) {\n    var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];\n    var lasts = lastsForAnimation[storageName];\n\n    if (element) {\n      // Remove from oldStorage\n      oldStorage[storageName][oldRawIndex] = null;\n      prepareAnimationWhenHasOld(lasts, element, storageName);\n    } // If invisible and no old element, do not create new element (for optimizing).\n    else if (!thisInvisible) {\n        element = new Ctor({\n          z: calculateZ(depth, z)\n        });\n        element.__tmDepth = depth;\n        element.__tmStorageName = storageName;\n        prepareAnimationWhenNoOld(lasts, element, storageName);\n      } // Set to thisStorage\n\n\n    return thisStorage[storageName][thisRawIndex] = element;\n  }\n\n  function prepareAnimationWhenHasOld(lasts, element, storageName) {\n    var lastCfg = lasts[thisRawIndex] = {};\n    lastCfg.old = storageName === 'nodeGroup' ? element.position.slice() : zrUtil.extend({}, element.shape);\n  } // If a element is new, we need to find the animation start point carefully,\n  // otherwise it will looks strange when 'zoomToNode'.\n\n\n  function prepareAnimationWhenNoOld(lasts, element, storageName) {\n    var lastCfg = lasts[thisRawIndex] = {};\n    var parentNode = thisNode.parentNode;\n\n    if (parentNode && (!reRoot || reRoot.direction === 'drillDown')) {\n      var parentOldX = 0;\n      var parentOldY = 0; // New nodes appear from right-bottom corner in 'zoomToNode' animation.\n      // For convenience, get old bounding rect from background.\n\n      var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];\n\n      if (!reRoot && parentOldBg && parentOldBg.old) {\n        parentOldX = parentOldBg.old.width;\n        parentOldY = parentOldBg.old.height;\n      } // When no parent old shape found, its parent is new too,\n      // so we can just use {x:0, y:0}.\n\n\n      lastCfg.old = storageName === 'nodeGroup' ? [0, parentOldY] : {\n        x: parentOldX,\n        y: parentOldY,\n        width: 0,\n        height: 0\n      };\n    } // Fade in, user can be aware that these nodes are new.\n\n\n    lastCfg.fadein = storageName !== 'nodeGroup';\n  }\n} // We can not set all backgroud with the same z, Because the behaviour of\n// drill down and roll up differ background creation sequence from tree\n// hierarchy sequence, which cause that lowser background element overlap\n// upper ones. So we calculate z based on depth.\n// Moreover, we try to shrink down z interval to [0, 1] to avoid that\n// treemap with large z overlaps other components.\n\n\nfunction calculateZ(depth, zInLevel) {\n  var zb = depth * Z_BASE + zInLevel;\n  return (zb - 1) / zb;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 654:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(1);\n\nvar helper = __webpack_require__(533);\n\n/**\n * @file Treemap action\n */\nvar noop = function () {};\n\nvar actionTypes = ['treemapZoomToNode', 'treemapRender', 'treemapMove'];\n\nfor (var i = 0; i < actionTypes.length; i++) {\n  echarts.registerAction({\n    type: actionTypes[i],\n    update: 'updateView'\n  }, noop);\n}\n\necharts.registerAction({\n  type: 'treemapRootToNode',\n  update: 'updateView'\n}, function (payload, ecModel) {\n  ecModel.eachComponent({\n    mainType: 'series',\n    subType: 'treemap',\n    query: payload\n  }, handleRootToNode);\n\n  function handleRootToNode(model, index) {\n    var targetInfo = helper.retrieveTargetInfo(payload, model);\n\n    if (targetInfo) {\n      var originViewRoot = model.getViewRoot();\n\n      if (originViewRoot) {\n        payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';\n      }\n\n      model.resetViewRoot(targetInfo.node);\n    }\n  }\n});\n\n/***/ }),\n\n/***/ 655:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar BoundingRect = __webpack_require__(10);\n\nvar _number = __webpack_require__(3);\n\nvar parsePercent = _number.parsePercent;\nvar MAX_SAFE_INTEGER = _number.MAX_SAFE_INTEGER;\n\nvar layout = __webpack_require__(16);\n\nvar helper = __webpack_require__(533);\n\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar retrieveValue = zrUtil.retrieve;\nvar each = zrUtil.each;\nvar PATH_BORDER_WIDTH = ['itemStyle', 'normal', 'borderWidth'];\nvar PATH_GAP_WIDTH = ['itemStyle', 'normal', 'gapWidth'];\nvar PATH_UPPER_LABEL_SHOW = ['upperLabel', 'normal', 'show'];\nvar PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'normal', 'height'];\n/**\n * @public\n */\n\nfunction _default(ecModel, api, payload) {\n  // Layout result in each node:\n  // {x, y, width, height, area, borderWidth}\n  var condition = {\n    mainType: 'series',\n    subType: 'treemap',\n    query: payload\n  };\n  ecModel.eachComponent(condition, function (seriesModel) {\n    var ecWidth = api.getWidth();\n    var ecHeight = api.getHeight();\n    var seriesOption = seriesModel.option;\n    var layoutInfo = layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    var size = seriesOption.size || []; // Compatible with ec2.\n\n    var containerWidth = parsePercent(retrieveValue(layoutInfo.width, size[0]), ecWidth);\n    var containerHeight = parsePercent(retrieveValue(layoutInfo.height, size[1]), ecHeight); // Fetch payload info.\n\n    var payloadType = payload && payload.type;\n    var targetInfo = helper.retrieveTargetInfo(payload, seriesModel);\n    var rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null;\n    var viewRoot = seriesModel.getViewRoot();\n    var viewAbovePath = helper.getPathToRoot(viewRoot);\n\n    if (payloadType !== 'treemapMove') {\n      var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];\n      var sort = seriesOption.sort;\n\n      if (sort && sort !== 'asc' && sort !== 'desc') {\n        sort = 'desc';\n      }\n\n      var options = {\n        squareRatio: seriesOption.squareRatio,\n        sort: sort,\n        leafDepth: seriesOption.leafDepth\n      }; // layout should be cleared because using updateView but not update.\n\n      viewRoot.hostTree.clearLayouts(); // TODO\n      // optimize: if out of view clip, do not layout.\n      // But take care that if do not render node out of view clip,\n      // how to calculate start po\n\n      var viewRootLayout = {\n        x: 0,\n        y: 0,\n        width: rootSize[0],\n        height: rootSize[1],\n        area: rootSize[0] * rootSize[1]\n      };\n      viewRoot.setLayout(viewRootLayout);\n      squarify(viewRoot, options, false, 0); // Supplement layout.\n\n      var viewRootLayout = viewRoot.getLayout();\n      each(viewAbovePath, function (node, index) {\n        var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();\n        node.setLayout(zrUtil.extend({\n          dataExtent: [childValue, childValue],\n          borderWidth: 0,\n          upperHeight: 0\n        }, viewRootLayout));\n      });\n    }\n\n    var treeRoot = seriesModel.getData().tree.root;\n    treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);\n    seriesModel.setLayoutInfo(layoutInfo); // FIXME\n    // 现在没有clip功能，暂时取ec高宽。\n\n    prunning(treeRoot, // Transform to base element coordinate system.\n    new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);\n  });\n}\n/**\n * Layout treemap with squarify algorithm.\n * @see https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf\n * @see https://github.com/mbostock/d3/blob/master/src/layout/treemap.js\n *\n * @protected\n * @param {module:echarts/data/Tree~TreeNode} node\n * @param {Object} options\n * @param {string} options.sort 'asc' or 'desc'\n * @param {number} options.squareRatio\n * @param {boolean} hideChildren\n * @param {number} depth\n */\n\n\nfunction squarify(node, options, hideChildren, depth) {\n  var width;\n  var height;\n\n  if (node.isRemoved()) {\n    return;\n  }\n\n  var thisLayout = node.getLayout();\n  width = thisLayout.width;\n  height = thisLayout.height; // Considering border and gap\n\n  var nodeModel = node.getModel();\n  var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);\n  var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;\n  var upperLabelHeight = getUpperLabelHeight(nodeModel);\n  var upperHeight = Math.max(borderWidth, upperLabelHeight);\n  var layoutOffset = borderWidth - halfGapWidth;\n  var layoutOffsetUpper = upperHeight - halfGapWidth;\n  var nodeModel = node.getModel();\n  node.setLayout({\n    borderWidth: borderWidth,\n    upperHeight: upperHeight,\n    upperLabelHeight: upperLabelHeight\n  }, true);\n  width = mathMax(width - 2 * layoutOffset, 0);\n  height = mathMax(height - layoutOffset - layoutOffsetUpper, 0);\n  var totalArea = width * height;\n  var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);\n\n  if (!viewChildren.length) {\n    return;\n  }\n\n  var rect = {\n    x: layoutOffset,\n    y: layoutOffsetUpper,\n    width: width,\n    height: height\n  };\n  var rowFixedLength = mathMin(width, height);\n  var best = Infinity; // the best row score so far\n\n  var row = [];\n  row.area = 0;\n\n  for (var i = 0, len = viewChildren.length; i < len;) {\n    var child = viewChildren[i];\n    row.push(child);\n    row.area += child.getLayout().area;\n    var score = worst(row, rowFixedLength, options.squareRatio); // continue with this orientation\n\n    if (score <= best) {\n      i++;\n      best = score;\n    } // abort, and try a different orientation\n    else {\n        row.area -= row.pop().getLayout().area;\n        position(row, rowFixedLength, rect, halfGapWidth, false);\n        rowFixedLength = mathMin(rect.width, rect.height);\n        row.length = row.area = 0;\n        best = Infinity;\n      }\n  }\n\n  if (row.length) {\n    position(row, rowFixedLength, rect, halfGapWidth, true);\n  }\n\n  if (!hideChildren) {\n    var childrenVisibleMin = nodeModel.get('childrenVisibleMin');\n\n    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {\n      hideChildren = true;\n    }\n  }\n\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    squarify(viewChildren[i], options, hideChildren, depth + 1);\n  }\n}\n/**\n * Set area to each child, and calculate data extent for visual coding.\n */\n\n\nfunction initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {\n  var viewChildren = node.children || [];\n  var orderBy = options.sort;\n  orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);\n  var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth; // leafDepth has higher priority.\n\n  if (hideChildren && !overLeafDepth) {\n    return node.viewChildren = [];\n  } // Sort children, order by desc.\n\n\n  viewChildren = zrUtil.filter(viewChildren, function (child) {\n    return !child.isRemoved();\n  });\n  sort(viewChildren, orderBy);\n  var info = statistic(nodeModel, viewChildren, orderBy);\n\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  }\n\n  info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);\n\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  } // Set area to each child.\n\n\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    var area = viewChildren[i].getValue() / info.sum * totalArea; // Do not use setLayout({...}, true), because it is needed to clear last layout.\n\n    viewChildren[i].setLayout({\n      area: area\n    });\n  }\n\n  if (overLeafDepth) {\n    viewChildren.length && node.setLayout({\n      isLeafRoot: true\n    }, true);\n    viewChildren.length = 0;\n  }\n\n  node.viewChildren = viewChildren;\n  node.setLayout({\n    dataExtent: info.dataExtent\n  }, true);\n  return viewChildren;\n}\n/**\n * Consider 'visibleMin'. Modify viewChildren and get new sum.\n */\n\n\nfunction filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {\n  // visibleMin is not supported yet when no option.sort.\n  if (!orderBy) {\n    return sum;\n  }\n\n  var visibleMin = nodeModel.get('visibleMin');\n  var len = orderedChildren.length;\n  var deletePoint = len; // Always travel from little value to big value.\n\n  for (var i = len - 1; i >= 0; i--) {\n    var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();\n\n    if (value / sum * totalArea < visibleMin) {\n      deletePoint = i;\n      sum -= value;\n    }\n  }\n\n  orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);\n  return sum;\n}\n/**\n * Sort\n */\n\n\nfunction sort(viewChildren, orderBy) {\n  if (orderBy) {\n    viewChildren.sort(function (a, b) {\n      var diff = orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();\n      return diff === 0 ? orderBy === 'asc' ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;\n    });\n  }\n\n  return viewChildren;\n}\n/**\n * Statistic\n */\n\n\nfunction statistic(nodeModel, children, orderBy) {\n  // Calculate sum.\n  var sum = 0;\n\n  for (var i = 0, len = children.length; i < len; i++) {\n    sum += children[i].getValue();\n  } // Statistic data extent for latter visual coding.\n  // Notice: data extent should be calculate based on raw children\n  // but not filtered view children, otherwise visual mapping will not\n  // be stable when zoom (where children is filtered by visibleMin).\n\n\n  var dimension = nodeModel.get('visualDimension');\n  var dataExtent; // The same as area dimension.\n\n  if (!children || !children.length) {\n    dataExtent = [NaN, NaN];\n  } else if (dimension === 'value' && orderBy) {\n    dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];\n    orderBy === 'asc' && dataExtent.reverse();\n  } // Other dimension.\n  else {\n      var dataExtent = [Infinity, -Infinity];\n      each(children, function (child) {\n        var value = child.getValue(dimension);\n        value < dataExtent[0] && (dataExtent[0] = value);\n        value > dataExtent[1] && (dataExtent[1] = value);\n      });\n    }\n\n  return {\n    sum: sum,\n    dataExtent: dataExtent\n  };\n}\n/**\n * Computes the score for the specified row,\n * as the worst aspect ratio.\n */\n\n\nfunction worst(row, rowFixedLength, ratio) {\n  var areaMax = 0;\n  var areaMin = Infinity;\n\n  for (var i = 0, area, len = row.length; i < len; i++) {\n    area = row[i].getLayout().area;\n\n    if (area) {\n      area < areaMin && (areaMin = area);\n      area > areaMax && (areaMax = area);\n    }\n  }\n\n  var squareArea = row.area * row.area;\n  var f = rowFixedLength * rowFixedLength * ratio;\n  return squareArea ? mathMax(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;\n}\n/**\n * Positions the specified row of nodes. Modifies `rect`.\n */\n\n\nfunction position(row, rowFixedLength, rect, halfGapWidth, flush) {\n  // When rowFixedLength === rect.width,\n  // it is horizontal subdivision,\n  // rowFixedLength is the width of the subdivision,\n  // rowOtherLength is the height of the subdivision,\n  // and nodes will be positioned from left to right.\n  // wh[idx0WhenH] means: when horizontal,\n  //      wh[idx0WhenH] => wh[0] => 'width'.\n  //      xy[idx1WhenH] => xy[1] => 'y'.\n  var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;\n  var idx1WhenH = 1 - idx0WhenH;\n  var xy = ['x', 'y'];\n  var wh = ['width', 'height'];\n  var last = rect[xy[idx0WhenH]];\n  var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;\n\n  if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {\n    rowOtherLength = rect[wh[idx1WhenH]]; // over+underflow\n  }\n\n  for (var i = 0, rowLen = row.length; i < rowLen; i++) {\n    var node = row[i];\n    var nodeLayout = {};\n    var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;\n    var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0); // We use Math.max/min to avoid negative width/height when considering gap width.\n\n    var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;\n    var modWH = i === rowLen - 1 || remain < step ? remain : step;\n    var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);\n    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);\n    nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);\n    last += modWH;\n    node.setLayout(nodeLayout, true);\n  }\n\n  rect[xy[idx1WhenH]] += rowOtherLength;\n  rect[wh[idx1WhenH]] -= rowOtherLength;\n} // Return [containerWidth, containerHeight] as defualt.\n\n\nfunction estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {\n  // If targetInfo.node exists, we zoom to the node,\n  // so estimate whold width and heigth by target node.\n  var currNode = (targetInfo || {}).node;\n  var defaultSize = [containerWidth, containerHeight];\n\n  if (!currNode || currNode === viewRoot) {\n    return defaultSize;\n  }\n\n  var parent;\n  var viewArea = containerWidth * containerHeight;\n  var area = viewArea * seriesModel.option.zoomToNodeRatio;\n\n  while (parent = currNode.parentNode) {\n    // jshint ignore:line\n    var sum = 0;\n    var siblings = parent.children;\n\n    for (var i = 0, len = siblings.length; i < len; i++) {\n      sum += siblings[i].getValue();\n    }\n\n    var currNodeValue = currNode.getValue();\n\n    if (currNodeValue === 0) {\n      return defaultSize;\n    }\n\n    area *= sum / currNodeValue; // Considering border, suppose aspect ratio is 1.\n\n    var parentModel = parent.getModel();\n    var borderWidth = parentModel.get(PATH_BORDER_WIDTH);\n    var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel, borderWidth));\n    area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);\n    area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);\n    currNode = parent;\n  }\n\n  area < viewArea && (area = viewArea);\n  var scale = Math.pow(area / viewArea, 0.5);\n  return [containerWidth * scale, containerHeight * scale];\n} // Root postion base on coord of containerGroup\n\n\nfunction calculateRootPosition(layoutInfo, rootRect, targetInfo) {\n  if (rootRect) {\n    return {\n      x: rootRect.x,\n      y: rootRect.y\n    };\n  }\n\n  var defaultPosition = {\n    x: 0,\n    y: 0\n  };\n\n  if (!targetInfo) {\n    return defaultPosition;\n  } // If targetInfo is fetched by 'retrieveTargetInfo',\n  // old tree and new tree are the same tree,\n  // so the node still exists and we can visit it.\n\n\n  var targetNode = targetInfo.node;\n  var layout = targetNode.getLayout();\n\n  if (!layout) {\n    return defaultPosition;\n  } // Transform coord from local to container.\n\n\n  var targetCenter = [layout.width / 2, layout.height / 2];\n  var node = targetNode;\n\n  while (node) {\n    var nodeLayout = node.getLayout();\n    targetCenter[0] += nodeLayout.x;\n    targetCenter[1] += nodeLayout.y;\n    node = node.parentNode;\n  }\n\n  return {\n    x: layoutInfo.width / 2 - targetCenter[0],\n    y: layoutInfo.height / 2 - targetCenter[1]\n  };\n} // Mark nodes visible for prunning when visual coding and rendering.\n// Prunning depends on layout and root position, so we have to do it after layout.\n\n\nfunction prunning(node, clipRect, viewAbovePath, viewRoot, depth) {\n  var nodeLayout = node.getLayout();\n  var nodeInViewAbovePath = viewAbovePath[depth];\n  var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;\n\n  if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {\n    return;\n  }\n\n  node.setLayout({\n    // isInView means: viewRoot sub tree + viewAbovePath\n    isInView: true,\n    // invisible only means: outside view clip so that the node can not\n    // see but still layout for animation preparation but not render.\n    invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),\n    isAboveViewRoot: isAboveViewRoot\n  }, true); // Transform to child coordinate.\n\n  var childClipRect = new BoundingRect(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);\n  each(node.viewChildren || [], function (child) {\n    prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);\n  });\n}\n\nfunction getUpperLabelHeight(model) {\n  return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 656:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar VisualMapping = __webpack_require__(43);\n\nvar zrColor = __webpack_require__(36);\n\nvar zrUtil = __webpack_require__(0);\n\nvar isArray = zrUtil.isArray;\nvar ITEM_STYLE_NORMAL = 'itemStyle.normal';\n\nfunction _default(ecModel, api, payload) {\n  var condition = {\n    mainType: 'series',\n    subType: 'treemap',\n    query: payload\n  };\n  ecModel.eachComponent(condition, function (seriesModel) {\n    var tree = seriesModel.getData().tree;\n    var root = tree.root;\n    var seriesItemStyleModel = seriesModel.getModel(ITEM_STYLE_NORMAL);\n\n    if (root.isRemoved()) {\n      return;\n    }\n\n    var levelItemStyles = zrUtil.map(tree.levelModels, function (levelModel) {\n      return levelModel ? levelModel.get(ITEM_STYLE_NORMAL) : null;\n    });\n    travelTree(root, // Visual should calculate from tree root but not view root.\n    {}, levelItemStyles, seriesItemStyleModel, seriesModel.getViewRoot().getAncestors(), seriesModel);\n  });\n}\n\nfunction travelTree(node, designatedVisual, levelItemStyles, seriesItemStyleModel, viewRootAncestors, seriesModel) {\n  var nodeModel = node.getModel();\n  var nodeLayout = node.getLayout(); // Optimize\n\n  if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {\n    return;\n  }\n\n  var nodeItemStyleModel = node.getModel(ITEM_STYLE_NORMAL);\n  var levelItemStyle = levelItemStyles[node.depth];\n  var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel); // calculate border color\n\n  var borderColor = nodeItemStyleModel.get('borderColor');\n  var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');\n  var thisNodeColor;\n\n  if (borderColorSaturation != null) {\n    // For performance, do not always execute 'calculateColor'.\n    thisNodeColor = calculateColor(visuals, node);\n    borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);\n  }\n\n  node.setVisual('borderColor', borderColor);\n  var viewChildren = node.viewChildren;\n\n  if (!viewChildren || !viewChildren.length) {\n    thisNodeColor = calculateColor(visuals, node); // Apply visual to this node.\n\n    node.setVisual('color', thisNodeColor);\n  } else {\n    var mapping = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren); // Designate visual to children.\n\n    zrUtil.each(viewChildren, function (child, index) {\n      // If higher than viewRoot, only ancestors of viewRoot is needed to visit.\n      if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {\n        var childVisual = mapVisual(nodeModel, visuals, child, index, mapping, seriesModel);\n        travelTree(child, childVisual, levelItemStyles, seriesItemStyleModel, viewRootAncestors, seriesModel);\n      }\n    });\n  }\n}\n\nfunction buildVisuals(nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel) {\n  var visuals = zrUtil.extend({}, designatedVisual);\n  zrUtil.each(['color', 'colorAlpha', 'colorSaturation'], function (visualName) {\n    // Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel\n    var val = nodeItemStyleModel.get(visualName, true); // Ignore parent\n\n    val == null && levelItemStyle && (val = levelItemStyle[visualName]);\n    val == null && (val = designatedVisual[visualName]);\n    val == null && (val = seriesItemStyleModel.get(visualName));\n    val != null && (visuals[visualName] = val);\n  });\n  return visuals;\n}\n\nfunction calculateColor(visuals) {\n  var color = getValueVisualDefine(visuals, 'color');\n\n  if (color) {\n    var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');\n    var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');\n\n    if (colorSaturation) {\n      color = zrColor.modifyHSL(color, null, null, colorSaturation);\n    }\n\n    if (colorAlpha) {\n      color = zrColor.modifyAlpha(color, colorAlpha);\n    }\n\n    return color;\n  }\n}\n\nfunction calculateBorderColor(borderColorSaturation, thisNodeColor) {\n  return thisNodeColor != null ? zrColor.modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;\n}\n\nfunction getValueVisualDefine(visuals, name) {\n  var value = visuals[name];\n\n  if (value != null && value !== 'none') {\n    return value;\n  }\n}\n\nfunction buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {\n  if (!viewChildren || !viewChildren.length) {\n    return;\n  }\n\n  var rangeVisual = getRangeVisual(nodeModel, 'color') || visuals.color != null && visuals.color !== 'none' && (getRangeVisual(nodeModel, 'colorAlpha') || getRangeVisual(nodeModel, 'colorSaturation'));\n\n  if (!rangeVisual) {\n    return;\n  }\n\n  var visualMin = nodeModel.get('visualMin');\n  var visualMax = nodeModel.get('visualMax');\n  var dataExtent = nodeLayout.dataExtent.slice();\n  visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);\n  visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);\n  var colorMappingBy = nodeModel.get('colorMappingBy');\n  var opt = {\n    type: rangeVisual.name,\n    dataExtent: dataExtent,\n    visual: rangeVisual.range\n  };\n\n  if (opt.type === 'color' && (colorMappingBy === 'index' || colorMappingBy === 'id')) {\n    opt.mappingMethod = 'category';\n    opt.loop = true; // categories is ordinal, so do not set opt.categories.\n  } else {\n    opt.mappingMethod = 'linear';\n  }\n\n  var mapping = new VisualMapping(opt);\n  mapping.__drColorMappingBy = colorMappingBy;\n  return mapping;\n} // Notice: If we dont have the attribute 'colorRange', but only use\n// attribute 'color' to represent both concepts of 'colorRange' and 'color',\n// (It means 'colorRange' when 'color' is Array, means 'color' when not array),\n// this problem will be encountered:\n// If a level-1 node dont have children, and its siblings has children,\n// and colorRange is set on level-1, then the node can not be colored.\n// So we separate 'colorRange' and 'color' to different attributes.\n\n\nfunction getRangeVisual(nodeModel, name) {\n  // 'colorRange', 'colorARange', 'colorSRange'.\n  // If not exsits on this node, fetch from levels and series.\n  var range = nodeModel.get(name);\n  return isArray(range) && range.length ? {\n    name: name,\n    range: range\n  } : null;\n}\n\nfunction mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {\n  var childVisuals = zrUtil.extend({}, visuals);\n\n  if (mapping) {\n    var mappingType = mapping.type;\n    var colorMappingBy = mappingType === 'color' && mapping.__drColorMappingBy;\n    var value = colorMappingBy === 'index' ? index : colorMappingBy === 'id' ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get('visualDimension'));\n    childVisuals[mappingType] = mapping.mapValueToVisual(value);\n  }\n\n  return childVisuals;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 657:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(666);\n\n__webpack_require__(561);\n\n__webpack_require__(562);\n\n__webpack_require__(661);\n\n__webpack_require__(662);\n\n__webpack_require__(659);\n\n__webpack_require__(660);\n\n__webpack_require__(664);\n\n__webpack_require__(663);\n\n/***/ }),\n\n/***/ 658:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar numberUtil = __webpack_require__(3);\n\nvar helper = __webpack_require__(563);\n\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [opt.start, opt.end];\n    var valueWindow = [];\n    each(['startValue', 'endValue'], function (prop) {\n      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n    }); // Normalize bound.\n\n    each([0, 1], function (idx) {\n      var boundValue = valueWindow[idx];\n      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n      // for cases that a dataZoom component controls multiple axes with different\n      // unit or extent, and the latter one is suitable for accurate zoom by pixel\n      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n      // but it is awkward that `percentProp` can not be obtained from `valueProp`\n      // accurately (because all of values that are overflow the `dataExtent` will\n      // be calculated to percent '100%'). So we have to use\n      // `dataZoom.getRangePropMode()` to mark which prop is used.\n      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n      // it remains its original value.\n\n      if (rangePropMode[idx] === 'percent') {\n        if (boundPercent == null) {\n          boundPercent = percentExtent[idx];\n        } // Use scale.parse to math round for category or time axis.\n\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));\n      } else {\n        // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    return {\n      valueWindow: asc(valueWindow),\n      percentWindow: asc(percentWindow)\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    } // Culculate data window and data extent, and record them.\n\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, this.getTargetSeriesModels());\n    var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow;\n    setMinMaxSpan(this); // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n\n\n    var otherAxisModel = this.getOtherAxisModel();\n\n    if (dataZoomModel.get('$fromToolbox') && otherAxisModel && otherAxisModel.get('type') === 'category') {\n      filterMode = 'empty';\n    } // Process series data\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesModel.coordDimToDataDim(axisDim);\n\n      if (filterMode === 'weakFilter') {\n        seriesData && seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        seriesData && each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            seriesData.filterSelf(dim, isInWindow);\n          }\n        });\n      }\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n        var seriesExtent = seriesData.getDataExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && (axisModel.get('data') || []).length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  each(['min', 'max'], function (minMax) {\n    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n\n    if (valueSpan != null) {\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n\n      if (valueSpan != null) {\n        var dataExtent = axisProxy._dataExtent;\n        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      }\n    }\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 659:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataZoomModel = __webpack_require__(561);\n\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    disabled: false,\n    // Whether disable this inside zoom.\n    zoomLock: false,\n    // Whether disable zoom but only pan.\n    zoomOnMouseWheel: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    moveOnMouseMove: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    preventDefaultMouseMove: true\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 660:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar DataZoomView = __webpack_require__(562);\n\nvar sliderMove = __webpack_require__(191);\n\nvar roams = __webpack_require__(665);\n\nvar bind = zrUtil.bind;\nvar InsideZoomView = DataZoomView.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @override\n   */\n  init: function (ecModel, api) {\n    /**\n     * 'throttle' is used in this.dispatchAction, so we save range\n     * to avoid missing some 'pan' info.\n     * @private\n     * @type {Array.<number>}\n     */\n    this._range;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    InsideZoomView.superApply(this, 'render', arguments); // Notice: origin this._range should be maintained, and should not be re-fetched\n    // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'\n    // info will be missed because of 'throttle' of this.dispatchAction.\n\n    if (roams.shouldRecordRange(payload, dataZoomModel.id)) {\n      this._range = dataZoomModel.getPercentRange();\n    } // Reset controllers.\n\n\n    zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {\n      var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {\n        return roams.generateCoordId(coordInfo.model);\n      });\n      zrUtil.each(coordInfoList, function (coordInfo) {\n        var coordModel = coordInfo.model;\n        var dataZoomOption = dataZoomModel.option;\n        roams.register(api, {\n          coordId: roams.generateCoordId(coordModel),\n          allCoordIds: allCoordIds,\n          containsPoint: function (e, x, y) {\n            return coordModel.coordinateSystem.containPoint([x, y]);\n          },\n          dataZoomId: dataZoomModel.id,\n          throttleRate: dataZoomModel.get('throttle', true),\n          panGetRange: bind(this._onPan, this, coordInfo, coordSysName),\n          zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName),\n          zoomLock: dataZoomOption.zoomLock,\n          disabled: dataZoomOption.disabled,\n          roamControllerOpt: {\n            zoomOnMouseWheel: dataZoomOption.zoomOnMouseWheel,\n            moveOnMouseMove: dataZoomOption.moveOnMouseMove,\n            preventDefaultMouseMove: dataZoomOption.preventDefaultMouseMove\n          }\n        });\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    roams.unregister(this.api, this.dataZoomModel.id);\n    InsideZoomView.superApply(this, 'dispose', arguments);\n    this._range = null;\n  },\n\n  /**\n   * @private\n   */\n  _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName]([oldX, oldY], [newX, newY], axisModel, controller, coordInfo);\n    var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;\n    sliderMove(percentDelta, range, [0, 100], 'all');\n    return this._range = range;\n  },\n\n  /**\n   * @private\n   */\n  _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName](null, [mouseX, mouseY], axisModel, controller, coordInfo);\n    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n    scale = Math.max(1 / scale, 0);\n    range[0] = (range[0] - percentPoint) * scale + percentPoint;\n    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.\n\n    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);\n    return this._range = range;\n  }\n});\nvar getDirectionInfo = {\n  grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.dim === 'x') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // axis.dim === 'y'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var polar = coordInfo.model.coordinateSystem;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var angleExtent = polar.getAngleAxis().getExtent();\n    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n    newPoint = polar.pointToCoord(newPoint);\n\n    if (axisModel.mainType === 'radiusAxis') {\n      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n\n      ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n      ret.pixelStart = radiusExtent[0];\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'angleAxis'\n      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n\n      ret.pixelLength = angleExtent[1] - angleExtent[0];\n      ret.pixelStart = angleExtent[0];\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    var ret = {};\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.orient === 'horizontal') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'vertical'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  }\n};\nvar _default = InsideZoomView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 661:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataZoomModel = __webpack_require__(561);\n\nvar SliderZoomModel = DataZoomModel.extend({\n  type: 'dataZoom.slider',\n  layoutMode: 'box',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    show: true,\n    // ph => placeholder. Using placehoder here because\n    // deault value can only be drived in view stage.\n    right: 'ph',\n    // Default align to grid rect.\n    top: 'ph',\n    // Default align to grid rect.\n    width: 'ph',\n    // Default align to grid rect.\n    height: 'ph',\n    // Default align to grid rect.\n    left: null,\n    // Default align to grid rect.\n    bottom: null,\n    // Default align to grid rect.\n    backgroundColor: 'rgba(47,69,84,0)',\n    // Background of slider zoom component.\n    // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,\n    // highest priority, remain for compatibility of\n    // previous version, but not recommended any more.\n    dataBackground: {\n      lineStyle: {\n        color: '#2f4554',\n        width: 0.5,\n        opacity: 0.3\n      },\n      areaStyle: {\n        color: 'rgba(47,69,84,0.3)',\n        opacity: 0.3\n      }\n    },\n    borderColor: '#ddd',\n    // border color of the box. For compatibility,\n    // if dataBackgroundColor is set, borderColor\n    // is ignored.\n    fillerColor: 'rgba(167,183,204,0.4)',\n    // Color of selected area.\n    // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.\n    // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',\n    handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',\n    // Percent of the slider height\n    handleSize: '100%',\n    handleStyle: {\n      color: '#a7b7cc'\n    },\n    labelPrecision: null,\n    labelFormatter: null,\n    showDetail: true,\n    showDataShadow: 'auto',\n    // Default auto decision.\n    realtime: true,\n    zoomLock: false,\n    // Whether disable zoom.\n    textStyle: {\n      color: '#333'\n    }\n  }\n});\nvar _default = SliderZoomModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 662:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar eventTool = __webpack_require__(31);\n\nvar graphic = __webpack_require__(2);\n\nvar throttle = __webpack_require__(75);\n\nvar DataZoomView = __webpack_require__(562);\n\nvar numberUtil = __webpack_require__(3);\n\nvar layout = __webpack_require__(16);\n\nvar sliderMove = __webpack_require__(191);\n\nvar Rect = graphic.Rect;\nvar linearMap = numberUtil.linearMap;\nvar asc = numberUtil.asc;\nvar bind = zrUtil.bind;\nvar each = zrUtil.each; // Constants\n\nvar DEFAULT_LOCATION_EDGE_GAP = 7;\nvar DEFAULT_FRAME_BORDER_WIDTH = 1;\nvar DEFAULT_FILLER_SIZE = 30;\nvar HORIZONTAL = 'horizontal';\nvar VERTICAL = 'vertical';\nvar LABEL_GAP = 5;\nvar SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\nvar SliderZoomView = DataZoomView.extend({\n  type: 'dataZoom.slider',\n  init: function (ecModel, api) {\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._displayables = {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this._orient;\n    /**\n     * [0, 100]\n     * @private\n     */\n\n    this._range;\n    /**\n     * [coord of the first handle, coord of the second handle]\n     * @private\n     */\n\n    this._handleEnds;\n    /**\n     * [length, thick]\n     * @private\n     * @type {Array.<number>}\n     */\n\n    this._size;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleWidth;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleHeight;\n    /**\n     * @private\n     */\n\n    this._location;\n    /**\n     * @private\n     */\n\n    this._dragging;\n    /**\n     * @private\n     */\n\n    this._dataShadowInfo;\n    this.api = api;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    SliderZoomView.superApply(this, 'render', arguments);\n    throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');\n    this._orient = dataZoomModel.get('orient');\n\n    if (this.dataZoomModel.get('show') === false) {\n      this.group.removeAll();\n      return;\n    } // Notice: this._resetInterval() should not be executed when payload.type\n    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n\n\n    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n      this._buildView();\n    }\n\n    this._updateView();\n  },\n\n  /**\n   * @override\n   */\n  remove: function () {\n    SliderZoomView.superApply(this, 'remove', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    SliderZoomView.superApply(this, 'dispose', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n  _buildView: function () {\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n\n    this._resetLocation();\n\n    this._resetInterval();\n\n    var barGroup = this._displayables.barGroup = new graphic.Group();\n\n    this._renderBackground();\n\n    this._renderHandle();\n\n    this._renderDataShadow();\n\n    thisGroup.add(barGroup);\n\n    this._positionGroup();\n  },\n\n  /**\n   * @private\n   */\n  _resetLocation: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var api = this.api; // If some of x/y/width/height are not specified,\n    // auto-adapt according to target grid.\n\n    var coordRect = this._findCoordRect();\n\n    var ecSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    }; // Default align by coordinate system rect.\n\n    var positionInfo = this._orient === HORIZONTAL ? {\n      // Why using 'right', because right should be used in vertical,\n      // and it is better to be consistent for dealing with position param merge.\n      right: ecSize.width - coordRect.x - coordRect.width,\n      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,\n      width: coordRect.width,\n      height: DEFAULT_FILLER_SIZE\n    } : {\n      // vertical\n      right: DEFAULT_LOCATION_EDGE_GAP,\n      top: coordRect.y,\n      width: DEFAULT_FILLER_SIZE,\n      height: coordRect.height\n    }; // Do not write back to option and replace value 'ph', because\n    // the 'ph' value should be recalculated when resize.\n\n    var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.\n\n    zrUtil.each(['right', 'top', 'width', 'height'], function (name) {\n      if (layoutParams[name] === 'ph') {\n        layoutParams[name] = positionInfo[name];\n      }\n    });\n    var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);\n    this._location = {\n      x: layoutRect.x,\n      y: layoutRect.y\n    };\n    this._size = [layoutRect.width, layoutRect.height];\n    this._orient === VERTICAL && this._size.reverse();\n  },\n\n  /**\n   * @private\n   */\n  _positionGroup: function () {\n    var thisGroup = this.group;\n    var location = this._location;\n    var orient = this._orient; // Just use the first axis to determine mapping.\n\n    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n    var inverse = targetAxisModel && targetAxisModel.get('inverse');\n    var barGroup = this._displayables.barGroup;\n    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.\n\n    barGroup.attr(orient === HORIZONTAL && !inverse ? {\n      scale: otherAxisInverse ? [1, 1] : [1, -1]\n    } : orient === HORIZONTAL && inverse ? {\n      scale: otherAxisInverse ? [-1, 1] : [-1, -1]\n    } : orient === VERTICAL && !inverse ? {\n      scale: otherAxisInverse ? [1, -1] : [1, 1],\n      rotation: Math.PI / 2 // Dont use Math.PI, considering shadow direction.\n\n    } : {\n      scale: otherAxisInverse ? [-1, -1] : [-1, 1],\n      rotation: Math.PI / 2\n    }); // Position barGroup\n\n    var rect = thisGroup.getBoundingRect([barGroup]);\n    thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);\n  },\n\n  /**\n   * @private\n   */\n  _getViewExtent: function () {\n    return [0, this._size[0]];\n  },\n  _renderBackground: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var size = this._size;\n    var barGroup = this._displayables.barGroup;\n    barGroup.add(new Rect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: dataZoomModel.get('backgroundColor')\n      },\n      z2: -40\n    })); // Click panel, over shadow, below handles.\n\n    barGroup.add(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: 'transparent'\n      },\n      z2: 0,\n      onclick: zrUtil.bind(this._onClickPanelClick, this)\n    }));\n  },\n  _renderDataShadow: function () {\n    var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n    if (!info) {\n      return;\n    }\n\n    var size = this._size;\n    var seriesModel = info.series;\n    var data = seriesModel.getRawData();\n    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick\n    : info.otherDim;\n\n    if (otherDim == null) {\n      return;\n    }\n\n    var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.\n\n    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];\n    var otherShadowExtent = [0, size[1]];\n    var thisShadowExtent = [0, size[0]];\n    var areaPoints = [[size[0], 0], [0, 0]];\n    var linePoints = [];\n    var step = thisShadowExtent[1] / (data.count() - 1);\n    var thisCoord = 0; // Optimize for large data shadow\n\n    var stride = Math.round(data.count() / size[0]);\n    var lastIsEmpty;\n    data.each([otherDim], function (value, index) {\n      if (stride > 0 && index % stride) {\n        thisCoord += step;\n        return;\n      } // FIXME\n      // Should consider axis.min/axis.max when drawing dataShadow.\n      // FIXME\n      // 应该使用统一的空判断？还是在list里进行空判断？\n\n\n      var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.\n\n      var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.\n\n      if (isEmpty && !lastIsEmpty && index) {\n        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n        linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n      } else if (!isEmpty && lastIsEmpty) {\n        areaPoints.push([thisCoord, 0]);\n        linePoints.push([thisCoord, 0]);\n      }\n\n      areaPoints.push([thisCoord, otherCoord]);\n      linePoints.push([thisCoord, otherCoord]);\n      thisCoord += step;\n      lastIsEmpty = isEmpty;\n    });\n    var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n\n    this._displayables.barGroup.add(new graphic.Polygon({\n      shape: {\n        points: areaPoints\n      },\n      style: zrUtil.defaults({\n        fill: dataZoomModel.get('dataBackgroundColor')\n      }, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),\n      silent: true,\n      z2: -20\n    }));\n\n    this._displayables.barGroup.add(new graphic.Polyline({\n      shape: {\n        points: linePoints\n      },\n      style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),\n      silent: true,\n      z2: -19\n    }));\n  },\n  _prepareDataShadowInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var showDataShadow = dataZoomModel.get('showDataShadow');\n\n    if (showDataShadow === false) {\n      return;\n    } // Find a representative series.\n\n\n    var result;\n    var ecModel = this.ecModel;\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();\n      zrUtil.each(seriesModels, function (seriesModel) {\n        if (result) {\n          return;\n        }\n\n        if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {\n          return;\n        }\n\n        var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;\n        var otherDim = getOtherDim(dimNames.name);\n        var otherAxisInverse;\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (otherDim != null && coordSys.getOtherAxis) {\n          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n        }\n\n        result = {\n          thisAxis: thisAxis,\n          series: seriesModel,\n          thisDim: dimNames.name,\n          otherDim: otherDim,\n          otherAxisInverse: otherAxisInverse\n        };\n      }, this);\n    }, this);\n    return result;\n  },\n  _renderHandle: function () {\n    var displaybles = this._displayables;\n    var handles = displaybles.handles = [];\n    var handleLabels = displaybles.handleLabels = [];\n    var barGroup = this._displayables.barGroup;\n    var size = this._size;\n    var dataZoomModel = this.dataZoomModel;\n    barGroup.add(displaybles.filler = new Rect({\n      draggable: true,\n      cursor: getCursor(this._orient),\n      drift: bind(this._onDragMove, this, 'all'),\n      onmousemove: function (e) {\n        // Fot mobile devicem, prevent screen slider on the button.\n        eventTool.stop(e.event);\n      },\n      ondragstart: bind(this._showDataInfo, this, true),\n      ondragend: bind(this._onDragEnd, this),\n      onmouseover: bind(this._showDataInfo, this, true),\n      onmouseout: bind(this._showDataInfo, this, false),\n      style: {\n        fill: dataZoomModel.get('fillerColor'),\n        textPosition: 'inside'\n      }\n    })); // Frame border.\n\n    barGroup.add(new Rect(graphic.subPixelOptimizeRect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),\n        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n        fill: 'rgba(0,0,0,0)'\n      }\n    })));\n    each([0, 1], function (handleIndex) {\n      var path = graphic.createIcon(dataZoomModel.get('handleIcon'), {\n        cursor: getCursor(this._orient),\n        draggable: true,\n        drift: bind(this._onDragMove, this, handleIndex),\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        ondragend: bind(this._onDragEnd, this),\n        onmouseover: bind(this._showDataInfo, this, true),\n        onmouseout: bind(this._showDataInfo, this, false)\n      }, {\n        x: -1,\n        y: 0,\n        width: 2,\n        height: 2\n      });\n      var bRect = path.getBoundingRect();\n      this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);\n      this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n      var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version\n\n      if (handleColor != null) {\n        path.style.fill = handleColor;\n      }\n\n      barGroup.add(handles[handleIndex] = path);\n      var textStyleModel = dataZoomModel.textStyleModel;\n      this.group.add(handleLabels[handleIndex] = new graphic.Text({\n        silent: true,\n        invisible: true,\n        style: {\n          x: 0,\n          y: 0,\n          text: '',\n          textVerticalAlign: 'middle',\n          textAlign: 'center',\n          textFill: textStyleModel.getTextColor(),\n          textFont: textStyleModel.getFont()\n        },\n        z2: 10\n      }));\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetInterval: function () {\n    var range = this._range = this.dataZoomModel.getPercentRange();\n\n    var viewExtent = this._getViewExtent();\n\n    this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];\n  },\n\n  /**\n   * @private\n   * @param {(number|string)} handleIndex 0 or 1 or 'all'\n   * @param {number} delta\n   */\n  _updateInterval: function (handleIndex, delta) {\n    var dataZoomModel = this.dataZoomModel;\n    var handleEnds = this._handleEnds;\n\n    var viewExtend = this._getViewExtent();\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    var percentExtent = [0, 100];\n    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);\n    this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);\n  },\n\n  /**\n   * @private\n   */\n  _updateView: function (nonRealtime) {\n    var displaybles = this._displayables;\n    var handleEnds = this._handleEnds;\n    var handleInterval = asc(handleEnds.slice());\n    var size = this._size;\n    each([0, 1], function (handleIndex) {\n      // Handles\n      var handle = displaybles.handles[handleIndex];\n      var handleHeight = this._handleHeight;\n      handle.attr({\n        scale: [handleHeight / 2, handleHeight / 2],\n        position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]\n      });\n    }, this); // Filler\n\n    displaybles.filler.setShape({\n      x: handleInterval[0],\n      y: 0,\n      width: handleInterval[1] - handleInterval[0],\n      height: size[1]\n    });\n\n    this._updateDataInfo(nonRealtime);\n  },\n\n  /**\n   * @private\n   */\n  _updateDataInfo: function (nonRealtime) {\n    var dataZoomModel = this.dataZoomModel;\n    var displaybles = this._displayables;\n    var handleLabels = displaybles.handleLabels;\n    var orient = this._orient;\n    var labelTexts = ['', '']; // FIXME\n    // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）\n\n    if (dataZoomModel.get('showDetail')) {\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        var axis = axisProxy.getAxisModel().axis;\n        var range = this._range;\n        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.\n        ? axisProxy.calculateDataWindow({\n          start: range[0],\n          end: range[1]\n        }).valueWindow : axisProxy.getDataValueWindow();\n        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];\n      }\n    }\n\n    var orderedHandleEnds = asc(this._handleEnds.slice());\n    setLabel.call(this, 0);\n    setLabel.call(this, 1);\n\n    function setLabel(handleIndex) {\n      // Label\n      // Text should not transform by barGroup.\n      // Ignore handlers transform\n      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);\n      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);\n      var offset = this._handleWidth / 2 + LABEL_GAP;\n      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);\n      handleLabels[handleIndex].setStyle({\n        x: textPoint[0],\n        y: textPoint[1],\n        textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n        textAlign: orient === HORIZONTAL ? direction : 'center',\n        text: labelTexts[handleIndex]\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _formatLabel: function (value, axis) {\n    var dataZoomModel = this.dataZoomModel;\n    var labelFormatter = dataZoomModel.get('labelFormatter');\n    var labelPrecision = dataZoomModel.get('labelPrecision');\n\n    if (labelPrecision == null || labelPrecision === 'auto') {\n      labelPrecision = axis.getPixelPrecision();\n    }\n\n    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code\n    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20.\n    : value.toFixed(Math.min(labelPrecision, 20));\n    return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;\n  },\n\n  /**\n   * @private\n   * @param {boolean} showOrHide true: show, false: hide\n   */\n  _showDataInfo: function (showOrHide) {\n    // Always show when drgging.\n    showOrHide = this._dragging || showOrHide;\n    var handleLabels = this._displayables.handleLabels;\n    handleLabels[0].attr('invisible', !showOrHide);\n    handleLabels[1].attr('invisible', !showOrHide);\n  },\n  _onDragMove: function (handleIndex, dx, dy) {\n    this._dragging = true; // Transform dx, dy to bar coordination.\n\n    var barTransform = this._displayables.barGroup.getLocalTransform();\n\n    var vertex = graphic.applyTransform([dx, dy], barTransform, true);\n\n    this._updateInterval(handleIndex, vertex[0]);\n\n    var realtime = this.dataZoomModel.get('realtime');\n\n    this._updateView(!realtime);\n\n    if (realtime) {\n      realtime && this._dispatchZoomAction();\n    }\n  },\n  _onDragEnd: function () {\n    this._dragging = false;\n\n    this._showDataInfo(false);\n\n    this._dispatchZoomAction();\n  },\n  _onClickPanelClick: function (e) {\n    var size = this._size;\n\n    var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);\n\n    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {\n      return;\n    }\n\n    var handleEnds = this._handleEnds;\n    var center = (handleEnds[0] + handleEnds[1]) / 2;\n\n    this._updateInterval('all', localPoint[0] - center);\n\n    this._updateView();\n\n    this._dispatchZoomAction();\n  },\n\n  /**\n   * This action will be throttled.\n   * @private\n   */\n  _dispatchZoomAction: function () {\n    var range = this._range;\n    this.api.dispatchAction({\n      type: 'dataZoom',\n      from: this.uid,\n      dataZoomId: this.dataZoomModel.id,\n      start: range[0],\n      end: range[1]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _findCoordRect: function () {\n    // Find the grid coresponding to the first axis referred by dataZoom.\n    var rect;\n    each(this.getTargetCoordInfo(), function (coordInfoList) {\n      if (!rect && coordInfoList.length) {\n        var coordSys = coordInfoList[0].model.coordinateSystem;\n        rect = coordSys.getRect && coordSys.getRect();\n      }\n    });\n\n    if (!rect) {\n      var width = this.api.getWidth();\n      var height = this.api.getHeight();\n      rect = {\n        x: width * 0.2,\n        y: height * 0.2,\n        width: width * 0.6,\n        height: height * 0.6\n      };\n    }\n\n    return rect;\n  }\n});\n\nfunction getOtherDim(thisDim) {\n  // FIXME\n  // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好\n  var map = {\n    x: 'y',\n    y: 'x',\n    radius: 'angle',\n    angle: 'radius'\n  };\n  return map[thisDim];\n}\n\nfunction getCursor(orient) {\n  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n\nvar _default = SliderZoomView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 663:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(1);\n\nvar zrUtil = __webpack_require__(0);\n\nvar helper = __webpack_require__(563);\n\necharts.registerAction('dataZoom', function (payload, ecModel) {\n  var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {\n    return model.get(dimNames.axisIndex);\n  });\n  var effectedModels = [];\n  ecModel.eachComponent({\n    mainType: 'dataZoom',\n    query: payload\n  }, function (model, index) {\n    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);\n  });\n  zrUtil.each(effectedModels, function (dataZoomModel, index) {\n    dataZoomModel.setRawRange({\n      start: payload.start,\n      end: payload.end,\n      startValue: payload.startValue,\n      endValue: payload.endValue\n    });\n  });\n});\n\n/***/ }),\n\n/***/ 664:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(1);\n\necharts.registerProcessor(function (ecModel, api) {\n  ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n    // We calculate window and reset axis here but not in model\n    // init stage and not after action dispatch handler, because\n    // reset should be called after seriesData.restoreData.\n    dataZoomModel.eachTargetAxis(resetSingleAxis); // Caution: data zoom filtering is order sensitive when using\n    // percent range and no min/max/scale set on axis.\n    // For example, we have dataZoom definition:\n    // [\n    //      {xAxisIndex: 0, start: 30, end: 70},\n    //      {yAxisIndex: 0, start: 20, end: 80}\n    // ]\n    // In this case, [20, 80] of y-dataZoom should be based on data\n    // that have filtered by x-dataZoom using range of [30, 70],\n    // but should not be based on full raw data. Thus sliding\n    // x-dataZoom will change both ranges of xAxis and yAxis,\n    // while sliding y-dataZoom will only change the range of yAxis.\n    // So we should filter x-axis after reset x-axis immediately,\n    // and then reset y-axis and filter y-axis.\n\n    dataZoomModel.eachTargetAxis(filterSingleAxis);\n  });\n  ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n    // Fullfill all of the range props so that user\n    // is able to get them from chart.getOption().\n    var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n    var percentRange = axisProxy.getDataPercentWindow();\n    var valueRange = axisProxy.getDataValueWindow();\n    dataZoomModel.setRawRange({\n      start: percentRange[0],\n      end: percentRange[1],\n      startValue: valueRange[0],\n      endValue: valueRange[1]\n    }, true);\n  });\n});\n\nfunction resetSingleAxis(dimNames, axisIndex, dataZoomModel) {\n  dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);\n}\n\nfunction filterSingleAxis(dimNames, axisIndex, dataZoomModel) {\n  dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);\n}\n\n/***/ }),\n\n/***/ 665:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar RoamController = __webpack_require__(190);\n\nvar throttleUtil = __webpack_require__(75);\n\n// Only create one roam controller for each coordinate system.\n// one roam controller might be refered by two inside data zoom\n// components (for example, one for x and one for y). When user\n// pan or zoom, only dispatch one action for those data zoom\n// components.\nvar curry = zrUtil.curry;\nvar ATTR = '\\0_ec_dataZoom_roams';\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} dataZoomInfo\n * @param {string} dataZoomInfo.coordId\n * @param {Function} dataZoomInfo.containsPoint\n * @param {Array.<string>} dataZoomInfo.allCoordIds\n * @param {string} dataZoomInfo.dataZoomId\n * @param {number} dataZoomInfo.throttleRate\n * @param {Function} dataZoomInfo.panGetRange\n * @param {Function} dataZoomInfo.zoomGetRange\n * @param {boolean} [dataZoomInfo.zoomLock]\n * @param {boolean} [dataZoomInfo.disabled]\n */\n\nfunction register(api, dataZoomInfo) {\n  var store = giveStore(api);\n  var theDataZoomId = dataZoomInfo.dataZoomId;\n  var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system.\n  // Avoid memory leak, dispose all not-used-registered.\n\n  zrUtil.each(store, function (record, coordId) {\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {\n      delete dataZoomInfos[theDataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n  var record = store[theCoordId]; // Create if needed.\n\n  if (!record) {\n    record = store[theCoordId] = {\n      coordId: theCoordId,\n      dataZoomInfos: {},\n      count: 0\n    };\n    record.controller = createController(api, record);\n    record.dispatchAction = zrUtil.curry(dispatchAction, api);\n  } // Update reference of dataZoom.\n\n\n  !record.dataZoomInfos[theDataZoomId] && record.count++;\n  record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n  var controllerParams = mergeControllerParams(record.dataZoomInfos);\n  record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated.\n\n  record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle.\n\n  throttleUtil.createOrUpdate(record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate');\n}\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {string} dataZoomId\n */\n\n\nfunction unregister(api, dataZoomId) {\n  var store = giveStore(api);\n  zrUtil.each(store, function (record) {\n    record.controller.dispose();\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[dataZoomId]) {\n      delete dataZoomInfos[dataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n}\n/**\n * @public\n */\n\n\nfunction shouldRecordRange(payload, dataZoomId) {\n  if (payload && payload.type === 'dataZoom' && payload.batch) {\n    for (var i = 0, len = payload.batch.length; i < len; i++) {\n      if (payload.batch[i].dataZoomId === dataZoomId) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * @public\n */\n\n\nfunction generateCoordId(coordModel) {\n  return coordModel.type + '\\0_' + coordModel.id;\n}\n/**\n * Key: coordId, value: {dataZoomInfos: [], count, controller}\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(api) {\n  // Mount store on zrender instance, so that we do not\n  // need to worry about dispose.\n  var zr = api.getZr();\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n\nfunction createController(api, newRecord) {\n  var controller = new RoamController(api.getZr());\n  controller.on('pan', curry(onPan, newRecord));\n  controller.on('zoom', curry(onZoom, newRecord));\n  return controller;\n}\n\nfunction cleanStore(store) {\n  zrUtil.each(store, function (record, coordId) {\n    if (!record.count) {\n      record.controller.dispose();\n      delete store[coordId];\n    }\n  });\n}\n\nfunction onPan(record, dx, dy, oldX, oldY, newX, newY) {\n  wrapAndDispatch(record, function (info) {\n    return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);\n  });\n}\n\nfunction onZoom(record, scale, mouseX, mouseY) {\n  wrapAndDispatch(record, function (info) {\n    return info.zoomGetRange(record.controller, scale, mouseX, mouseY);\n  });\n}\n\nfunction wrapAndDispatch(record, getRange) {\n  var batch = [];\n  zrUtil.each(record.dataZoomInfos, function (info) {\n    var range = getRange(info);\n    !info.disabled && range && batch.push({\n      dataZoomId: info.dataZoomId,\n      start: range[0],\n      end: range[1]\n    });\n  });\n  record.dispatchAction(batch);\n}\n/**\n * This action will be throttled.\n */\n\n\nfunction dispatchAction(api, batch) {\n  api.dispatchAction({\n    type: 'dataZoom',\n    batch: batch\n  });\n}\n/**\n * Merge roamController settings when multiple dataZooms share one roamController.\n */\n\n\nfunction mergeControllerParams(dataZoomInfos) {\n  var controlType;\n  var opt = {};\n  var typePriority = {\n    'true': 2,\n    'move': 1,\n    'false': 0,\n    'undefined': -1\n  };\n  zrUtil.each(dataZoomInfos, function (dataZoomInfo) {\n    var oneType = dataZoomInfo.disabled ? false : dataZoomInfo.zoomLock ? 'move' : true;\n    typePriority[oneType] > typePriority[controlType] && (controlType = oneType); // Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys.\n\n    zrUtil.extend(opt, dataZoomInfo.roamControllerOpt);\n  });\n  return {\n    controlType: controlType,\n    opt: opt\n  };\n}\n\nexports.register = register;\nexports.unregister = unregister;\nexports.shouldRecordRange = shouldRecordRange;\nexports.generateCoordId = generateCoordId;\n\n/***/ }),\n\n/***/ 666:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(18);\n\nComponent.registerSubTypeDefaulter('dataZoom', function () {\n  // Default 'slider' when no type specified.\n  return 'slider';\n});\n\n/***/ }),\n\n/***/ 667:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(1);\n\n__webpack_require__(668);\n\n__webpack_require__(669);\n\necharts.registerPreprocessor(function (opt) {\n  // Make sure markLine component is enabled\n  opt.markLine = opt.markLine || {};\n});\n\n/***/ }),\n\n/***/ 668:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MarkerModel = __webpack_require__(670);\n\nvar _default = MarkerModel.extend({\n  type: 'markLine',\n  defaultOption: {\n    zlevel: 0,\n    z: 5,\n    symbol: ['circle', 'arrow'],\n    symbolSize: [8, 16],\n    //symbolRotate: 0,\n    precision: 2,\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      normal: {\n        show: true,\n        position: 'end'\n      },\n      emphasis: {\n        show: true\n      }\n    },\n    lineStyle: {\n      normal: {\n        type: 'dashed'\n      },\n      emphasis: {\n        width: 3\n      }\n    },\n    animationEasing: 'linear'\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 669:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar List = __webpack_require__(41);\n\nvar numberUtil = __webpack_require__(3);\n\nvar markerHelper = __webpack_require__(672);\n\nvar LineDraw = __webpack_require__(648);\n\nvar MarkerView = __webpack_require__(671);\n\nvar markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n  var data = seriesModel.getData(); // Special type markLine like 'min', 'max', 'average'\n\n  var mlType = item.type;\n\n  if (!zrUtil.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average' // In case\n  // data: [{\n  //   yAxis: 10\n  // }]\n  || item.xAxis != null || item.yAxis != null)) {\n    var valueAxis;\n    var valueDataDim;\n    var value;\n\n    if (item.yAxis != null || item.xAxis != null) {\n      valueDataDim = item.yAxis != null ? 'y' : 'x';\n      valueAxis = coordSys.getAxis(valueDataDim);\n      value = zrUtil.retrieve(item.yAxis, item.xAxis);\n    } else {\n      var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);\n      valueDataDim = axisInfo.valueDataDim;\n      valueAxis = axisInfo.valueAxis;\n      value = markerHelper.numCalculate(data, valueDataDim, mlType);\n    }\n\n    var valueIndex = valueDataDim === 'x' ? 0 : 1;\n    var baseIndex = 1 - valueIndex;\n    var mlFrom = zrUtil.clone(item);\n    var mlTo = {};\n    mlFrom.type = null;\n    mlFrom.coord = [];\n    mlTo.coord = [];\n    mlFrom.coord[baseIndex] = -Infinity;\n    mlTo.coord[baseIndex] = Infinity;\n    var precision = mlModel.get('precision');\n\n    if (precision >= 0 && typeof value === 'number') {\n      value = +value.toFixed(Math.min(precision, 20));\n    }\n\n    mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n    item = [mlFrom, mlTo, {\n      // Extra option for tooltip and label\n      type: mlType,\n      valueIndex: item.valueIndex,\n      // Force to use the value of calculated value.\n      value: value\n    }];\n  }\n\n  item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2])]; // Avoid line data type is extended by from(to) data type\n\n  item[2].type = item[2].type || ''; // Merge from option and to option into line option\n\n  zrUtil.merge(item[2], item[0]);\n  zrUtil.merge(item[2], item[1]);\n  return item;\n};\n\nfunction isInifinity(val) {\n  return !isNaN(val) && !isFinite(val);\n} // If a markLine has one dim\n\n\nfunction ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  var dimName = coordSys.dimensions[dimIndex];\n  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n}\n\nfunction markLineFilter(coordSys, item) {\n  if (coordSys.type === 'cartesian2d') {\n    var fromCoord = item[0].coord;\n    var toCoord = item[1].coord; // In case\n    // {\n    //  markLine: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n\n    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    }\n  }\n\n  return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);\n}\n\nfunction updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n  var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPoisition\n      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));\n    } else {\n      var dims = coordSys.dimensions;\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      point = coordSys.dataToPoint([x, y]);\n    } // Expand line to the edge of grid if value on one axis is Inifnity\n    // In case\n    //  markLine: {\n    //    data: [{\n    //      yAxis: 2\n    //      // or\n    //      type: 'average'\n    //    }]\n    //  }\n\n\n    if (coordSys.type === 'cartesian2d') {\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var dims = coordSys.dimensions;\n\n      if (isInifinity(data.get(dims[0], idx))) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n      } else if (isInifinity(data.get(dims[1], idx))) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n      }\n    } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n\n  data.setItemLayout(idx, point);\n}\n\nvar _default = MarkerView.extend({\n  type: 'markLine',\n  updateLayout: function (markLineModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mlModel = seriesModel.markLineModel;\n\n      if (mlModel) {\n        var mlData = mlModel.getData();\n        var fromData = mlModel.__from;\n        var toData = mlModel.__to; // Update visual and layout of from symbol and to symbol\n\n        fromData.each(function (idx) {\n          updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);\n          updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);\n        }); // Update layout of line\n\n        mlData.each(function (idx) {\n          mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);\n        });\n        this.markerGroupMap.get(seriesModel.id).updateLayout();\n      }\n    }, this);\n  },\n  renderSeries: function (seriesModel, mlModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var lineDrawMap = this.markerGroupMap;\n    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());\n    this.group.add(lineDraw.group);\n    var mlData = createList(coordSys, seriesModel, mlModel);\n    var fromData = mlData.from;\n    var toData = mlData.to;\n    var lineData = mlData.line;\n    mlModel.__from = fromData;\n    mlModel.__to = toData; // Line data for tooltip and formatter\n\n    mlModel.setData(lineData);\n    var symbolType = mlModel.get('symbol');\n    var symbolSize = mlModel.get('symbolSize');\n\n    if (!zrUtil.isArray(symbolType)) {\n      symbolType = [symbolType, symbolType];\n    }\n\n    if (typeof symbolSize === 'number') {\n      symbolSize = [symbolSize, symbolSize];\n    } // Update visual and layout of from symbol and to symbol\n\n\n    mlData.from.each(function (idx) {\n      updateDataVisualAndLayout(fromData, idx, true);\n      updateDataVisualAndLayout(toData, idx, false);\n    }); // Update visual and layout of line\n\n    lineData.each(function (idx) {\n      var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color');\n      lineData.setItemVisual(idx, {\n        color: lineColor || fromData.getItemVisual(idx, 'color')\n      });\n      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);\n      lineData.setItemVisual(idx, {\n        'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),\n        'fromSymbol': fromData.getItemVisual(idx, 'symbol'),\n        'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),\n        'toSymbol': toData.getItemVisual(idx, 'symbol')\n      });\n    });\n    lineDraw.updateData(lineData); // Set host model for tooltip\n    // FIXME\n\n    mlData.line.eachItemGraphicEl(function (el, idx) {\n      el.traverse(function (child) {\n        child.dataModel = mlModel;\n      });\n    });\n\n    function updateDataVisualAndLayout(data, idx, isFrom) {\n      var itemModel = data.getItemModel(idx);\n      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);\n      data.setItemVisual(idx, {\n        symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],\n        symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],\n        color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color')\n      });\n    }\n\n    lineDraw.__keep = true;\n    lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n  }\n});\n/**\n * @inner\n * @param {module:echarts/coord/*} coordSys\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\n\n\nfunction createList(coordSys, seriesModel, mlModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      info.name = coordDim;\n      return info;\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var fromData = new List(coordDimsInfos, mlModel);\n  var toData = new List(coordDimsInfos, mlModel); // No dimensions\n\n  var lineData = new List([], mlModel);\n  var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));\n\n  if (coordSys) {\n    optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));\n  }\n\n  var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {\n    return item.value;\n  };\n  fromData.initData(zrUtil.map(optData, function (item) {\n    return item[0];\n  }), null, dimValueGetter);\n  toData.initData(zrUtil.map(optData, function (item) {\n    return item[1];\n  }), null, dimValueGetter);\n  lineData.initData(zrUtil.map(optData, function (item) {\n    return item[2];\n  }));\n  lineData.hasItemOption = true;\n  return {\n    from: fromData,\n    to: toData,\n    line: lineData\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 670:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(5);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(1);\n\nvar zrUtil = __webpack_require__(0);\n\nvar env = __webpack_require__(11);\n\nvar modelUtil = __webpack_require__(4);\n\nvar formatUtil = __webpack_require__(7);\n\nvar addCommas = formatUtil.addCommas;\nvar encodeHTML = formatUtil.encodeHTML;\n\nfunction fillLabel(opt) {\n  modelUtil.defaultEmphasis(opt.label, ['show']);\n}\n\nvar MarkerModel = echarts.extendComponentModel({\n  type: 'marker',\n  dependencies: ['series', 'grid', 'polar', 'geo'],\n\n  /**\n   * @overrite\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var hostSeries = this.__hostSeries;\n    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n  },\n  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n    var MarkerModel = this.constructor;\n    var modelPropName = this.mainType + 'Model';\n\n    if (!createdBySelf) {\n      ecModel.eachSeries(function (seriesModel) {\n        var markerOpt = seriesModel.get(this.mainType);\n        var markerModel = seriesModel[modelPropName];\n\n        if (!markerOpt || !markerOpt.data) {\n          seriesModel[modelPropName] = null;\n          return;\n        }\n\n        if (!markerModel) {\n          if (isInit) {\n            // Default label emphasis `position` and `show`\n            fillLabel(markerOpt);\n          }\n\n          zrUtil.each(markerOpt.data, function (item) {\n            // FIXME Overwrite fillLabel method ?\n            if (item instanceof Array) {\n              fillLabel(item[0]);\n              fillLabel(item[1]);\n            } else {\n              fillLabel(item);\n            }\n          });\n          markerModel = new MarkerModel(markerOpt, this, ecModel);\n          zrUtil.extend(markerModel, {\n            mainType: this.mainType,\n            // Use the same series index and name\n            seriesIndex: seriesModel.seriesIndex,\n            name: seriesModel.name,\n            createdBySelf: true\n          });\n          markerModel.__hostSeries = seriesModel;\n        } else {\n          markerModel.mergeOption(markerOpt, ecModel, true);\n        }\n\n        seriesModel[modelPropName] = markerModel;\n      }, this);\n    }\n  },\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n    var name = data.getName(dataIndex);\n    var html = encodeHTML(this.name);\n\n    if (value != null || name) {\n      html += '<br />';\n    }\n\n    if (name) {\n      html += encodeHTML(name);\n\n      if (value != null) {\n        html += ' : ';\n      }\n    }\n\n    if (value != null) {\n      html += encodeHTML(formattedValue);\n    }\n\n    return html;\n  },\n  getData: function () {\n    return this._data;\n  },\n  setData: function (data) {\n    this._data = data;\n  }\n});\nzrUtil.mixin(MarkerModel, modelUtil.dataFormatMixin);\nvar _default = MarkerModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 671:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(1);\n\nvar zrUtil = __webpack_require__(0);\n\nvar _default = echarts.extendComponentView({\n  type: 'marker',\n  init: function () {\n    /**\n     * Markline grouped by series\n     * @private\n     * @type {module:zrender/core/util.HashMap}\n     */\n    this.markerGroupMap = zrUtil.createHashMap();\n  },\n  render: function (markerModel, ecModel, api) {\n    var markerGroupMap = this.markerGroupMap;\n    markerGroupMap.each(function (item) {\n      item.__keep = false;\n    });\n    var markerModelKey = this.type + 'Model';\n    ecModel.eachSeries(function (seriesModel) {\n      var markerModel = seriesModel[markerModelKey];\n      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n    }, this);\n    markerGroupMap.each(function (item) {\n      !item.__keep && this.group.remove(item.group);\n    }, this);\n  },\n  renderSeries: function () {}\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 672:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar numberUtil = __webpack_require__(3);\n\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n}\n\nfunction getPrecision(data, valueAxisDim, dataIndex) {\n  var precision = -1;\n\n  do {\n    precision = Math.max(numberUtil.getPrecision(data.get(valueAxisDim, dataIndex)), precision);\n    data = data.stackedOn;\n  } while (data);\n\n  return precision;\n}\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var value = numCalculate(data, targetDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(targetDataDim, value, true)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);\n  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);\n  var precision = getPrecision(data, targetDataDim, dataIndex);\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return coordArr;\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.\n\n      item.value = item.coord[targetCoordIndex];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];\n          coord[i] = numCalculate(data, dataDim, coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n    ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];\n  }\n\n  return ret;\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    }, true);\n    return sum / count;\n  } else {\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;\n\n/***/ }),\n\n/***/ 673:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Model = __webpack_require__(9);\n\nvar List = __webpack_require__(41);\n\nvar linkList = __webpack_require__(674);\n\nvar completeDimensions = __webpack_require__(42);\n\n/**\n * Tree data structure\n *\n * @module echarts/data/Tree\n */\n\n/**\n * @constructor module:echarts/data/Tree~TreeNode\n * @param {string} name\n * @param {module:echarts/data/Tree} hostTree\n */\nvar TreeNode = function (name, hostTree) {\n  /**\n   * @type {string}\n   */\n  this.name = name || '';\n  /**\n   * Depth of node\n   *\n   * @type {number}\n   * @readOnly\n   */\n\n  this.depth = 0;\n  /**\n   * Height of the subtree rooted at this node.\n   * @type {number}\n   * @readOnly\n   */\n\n  this.height = 0;\n  /**\n   * @type {module:echarts/data/Tree~TreeNode}\n   * @readOnly\n   */\n\n  this.parentNode = null;\n  /**\n   * Reference to list item.\n   * Do not persistent dataIndex outside,\n   * besause it may be changed by list.\n   * If dataIndex -1,\n   * this node is logical deleted (filtered) in list.\n   *\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.dataIndex = -1;\n  /**\n   * @type {Array.<module:echarts/data/Tree~TreeNode>}\n   * @readOnly\n   */\n\n  this.children = [];\n  /**\n   * @type {Array.<module:echarts/data/Tree~TreeNode>}\n   * @pubilc\n   */\n\n  this.viewChildren = [];\n  /**\n   * @type {moduel:echarts/data/Tree}\n   * @readOnly\n   */\n\n  this.hostTree = hostTree;\n};\n\nTreeNode.prototype = {\n  constructor: TreeNode,\n\n  /**\n   * The node is removed.\n   * @return {boolean} is removed.\n   */\n  isRemoved: function () {\n    return this.dataIndex < 0;\n  },\n\n  /**\n   * Travel this subtree (include this node).\n   * Usage:\n   *    node.eachNode(function () { ... }); // preorder\n   *    node.eachNode('preorder', function () { ... }); // preorder\n   *    node.eachNode('postorder', function () { ... }); // postorder\n   *    node.eachNode(\n   *        {order: 'postorder', attr: 'viewChildren'},\n   *        function () { ... }\n   *    ); // postorder\n   *\n   * @param {(Object|string)} options If string, means order.\n   * @param {string=} options.order 'preorder' or 'postorder'\n   * @param {string=} options.attr 'children' or 'viewChildren'\n   * @param {Function} cb If in preorder and return false,\n   *                      its subtree will not be visited.\n   * @param {Object} [context]\n   */\n  eachNode: function (options, cb, context) {\n    if (typeof options === 'function') {\n      context = cb;\n      cb = options;\n      options = null;\n    }\n\n    options = options || {};\n\n    if (zrUtil.isString(options)) {\n      options = {\n        order: options\n      };\n    }\n\n    var order = options.order || 'preorder';\n    var children = this[options.attr || 'children'];\n    var suppressVisitSub;\n    order === 'preorder' && (suppressVisitSub = cb.call(context, this));\n\n    for (var i = 0; !suppressVisitSub && i < children.length; i++) {\n      children[i].eachNode(options, cb, context);\n    }\n\n    order === 'postorder' && cb.call(context, this);\n  },\n\n  /**\n   * Update depth and height of this subtree.\n   *\n   * @param  {number} depth\n   */\n  updateDepthAndHeight: function (depth) {\n    var height = 0;\n    this.depth = depth;\n\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      child.updateDepthAndHeight(depth + 1);\n\n      if (child.height > height) {\n        height = child.height;\n      }\n    }\n\n    this.height = height + 1;\n  },\n\n  /**\n   * @param  {string} id\n   * @return {module:echarts/data/Tree~TreeNode}\n   */\n  getNodeById: function (id) {\n    if (this.getId() === id) {\n      return this;\n    }\n\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].getNodeById(id);\n\n      if (res) {\n        return res;\n      }\n    }\n  },\n\n  /**\n   * @param {module:echarts/data/Tree~TreeNode} node\n   * @return {boolean}\n   */\n  contains: function (node) {\n    if (node === this) {\n      return true;\n    }\n\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].contains(node);\n\n      if (res) {\n        return res;\n      }\n    }\n  },\n\n  /**\n   * @param {boolean} includeSelf Default false.\n   * @return {Array.<module:echarts/data/Tree~TreeNode>} order: [root, child, grandchild, ...]\n   */\n  getAncestors: function (includeSelf) {\n    var ancestors = [];\n    var node = includeSelf ? this : this.parentNode;\n\n    while (node) {\n      ancestors.push(node);\n      node = node.parentNode;\n    }\n\n    ancestors.reverse();\n    return ancestors;\n  },\n\n  /**\n   * @param {string|Array=} [dimension='value'] Default 'value'. can be 0, 1, 2, 3\n   * @return {number} Value.\n   */\n  getValue: function (dimension) {\n    var data = this.hostTree.data;\n    return data.get(data.getDimension(dimension || 'value'), this.dataIndex);\n  },\n\n  /**\n   * @param {Object} layout\n   * @param {boolean=} [merge=false]\n   */\n  setLayout: function (layout, merge) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);\n  },\n\n  /**\n   * @return {Object} layout\n   */\n  getLayout: function () {\n    return this.hostTree.data.getItemLayout(this.dataIndex);\n  },\n\n  /**\n   * @param {string} [path]\n   * @return {module:echarts/model/Model}\n   */\n  getModel: function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n\n    var hostTree = this.hostTree;\n    var itemModel = hostTree.data.getItemModel(this.dataIndex);\n    var levelModel = this.getLevelModel();\n    var leavesModel;\n\n    if (!levelModel && (this.children.length === 0 || this.children.length !== 0 && this.isExpand === false)) {\n      leavesModel = this.getLeavesModel();\n    }\n\n    return itemModel.getModel(path, (levelModel || leavesModel || hostTree.hostModel).getModel(path));\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getLevelModel: function () {\n    return (this.hostTree.levelModels || [])[this.depth];\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getLeavesModel: function () {\n    return this.hostTree.leavesModel;\n  },\n\n  /**\n   * @example\n   *  setItemVisual('color', color);\n   *  setItemVisual({\n   *      'color': color\n   *  });\n   */\n  setVisual: function (key, value) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);\n  },\n\n  /**\n   * Get item visual\n   */\n  getVisual: function (key, ignoreParent) {\n    return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent);\n  },\n\n  /**\n   * @public\n   * @return {number}\n   */\n  getRawIndex: function () {\n    return this.hostTree.data.getRawIndex(this.dataIndex);\n  },\n\n  /**\n   * @public\n   * @return {string}\n   */\n  getId: function () {\n    return this.hostTree.data.getId(this.dataIndex);\n  }\n};\n/**\n * @constructor\n * @alias module:echarts/data/Tree\n * @param {module:echarts/model/Model} hostModel\n * @param {Array.<Object>} levelOptions\n * @param {Object} leavesOption\n */\n\nfunction Tree(hostModel, levelOptions, leavesOption) {\n  /**\n   * @type {module:echarts/data/Tree~TreeNode}\n   * @readOnly\n   */\n  this.root;\n  /**\n   * @type {module:echarts/data/List}\n   * @readOnly\n   */\n\n  this.data;\n  /**\n   * Index of each item is the same as the raw index of coresponding list item.\n   * @private\n   * @type {Array.<module:echarts/data/Tree~TreeNode}\n   */\n\n  this._nodes = [];\n  /**\n   * @private\n   * @readOnly\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @private\n   * @readOnly\n   * @type {Array.<module:echarts/model/Model}\n   */\n\n  this.levelModels = zrUtil.map(levelOptions || [], function (levelDefine) {\n    return new Model(levelDefine, hostModel, hostModel.ecModel);\n  });\n  this.leavesModel = new Model(leavesOption || {}, hostModel, hostModel.ecModel);\n}\n\nTree.prototype = {\n  constructor: Tree,\n  type: 'tree',\n\n  /**\n   * Travel this subtree (include this node).\n   * Usage:\n   *    node.eachNode(function () { ... }); // preorder\n   *    node.eachNode('preorder', function () { ... }); // preorder\n   *    node.eachNode('postorder', function () { ... }); // postorder\n   *    node.eachNode(\n   *        {order: 'postorder', attr: 'viewChildren'},\n   *        function () { ... }\n   *    ); // postorder\n   *\n   * @param {(Object|string)} options If string, means order.\n   * @param {string=} options.order 'preorder' or 'postorder'\n   * @param {string=} options.attr 'children' or 'viewChildren'\n   * @param {Function} cb\n   * @param {Object}   [context]\n   */\n  eachNode: function (options, cb, context) {\n    this.root.eachNode(options, cb, context);\n  },\n\n  /**\n   * @param {number} dataIndex\n   * @return {module:echarts/data/Tree~TreeNode}\n   */\n  getNodeByDataIndex: function (dataIndex) {\n    var rawIndex = this.data.getRawIndex(dataIndex);\n    return this._nodes[rawIndex];\n  },\n\n  /**\n   * @param {string} name\n   * @return {module:echarts/data/Tree~TreeNode}\n   */\n  getNodeByName: function (name) {\n    return this.root.getNodeByName(name);\n  },\n\n  /**\n   * Update item available by list,\n   * when list has been performed options like 'filterSelf' or 'map'.\n   */\n  update: function () {\n    var data = this.data;\n    var nodes = this._nodes;\n\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n  },\n\n  /**\n   * Clear all layouts\n   */\n  clearLayouts: function () {\n    this.data.clearItemLayouts();\n  }\n};\n/**\n * data node format:\n * {\n *     name: ...\n *     value: ...\n *     children: [\n *         {\n *             name: ...\n *             value: ...\n *             children: ...\n *         },\n *         ...\n *     ]\n * }\n *\n * @static\n * @param {Object} dataRoot Root node.\n * @param {module:echarts/model/Model} hostModel\n * @param {Object} treeOptions\n * @param {Array.<Object>} treeOptions.levels\n * @param {Array.<Object>} treeOptions.leaves\n * @return module:echarts/data/Tree\n */\n\nTree.createTree = function (dataRoot, hostModel, treeOptions) {\n  var tree = new Tree(hostModel, treeOptions.levels, treeOptions.leaves);\n  var listData = [];\n  var dimMax = 1;\n  buildHierarchy(dataRoot);\n\n  function buildHierarchy(dataNode, parentNode) {\n    var value = dataNode.value;\n    dimMax = Math.max(dimMax, zrUtil.isArray(value) ? value.length : 1);\n    listData.push(dataNode);\n    var node = new TreeNode(dataNode.name, tree);\n    parentNode ? addChild(node, parentNode) : tree.root = node;\n\n    tree._nodes.push(node);\n\n    var children = dataNode.children;\n\n    if (children) {\n      for (var i = 0; i < children.length; i++) {\n        buildHierarchy(children[i], node);\n      }\n    }\n  }\n\n  tree.root.updateDepthAndHeight(0);\n  var dimensions = completeDimensions([{\n    name: 'value'\n  }], listData, {\n    dimCount: dimMax\n  });\n  var list = new List(dimensions, hostModel);\n  list.initData(listData);\n  linkList({\n    mainData: list,\n    struct: tree,\n    structAttr: 'tree'\n  });\n  tree.update();\n  return tree;\n};\n/**\n * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,\n * so this function is not ready and not necessary to be public.\n *\n * @param {(module:echarts/data/Tree~TreeNode|Object)} child\n */\n\n\nfunction addChild(child, node) {\n  var children = node.children;\n\n  if (child.parentNode === node) {\n    return;\n  }\n\n  children.push(child);\n  child.parentNode = node;\n}\n\nvar _default = Tree;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 674:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/**\n * Link lists and struct (graph or tree)\n */\nvar each = zrUtil.each;\nvar DATAS = '\\0__link_datas';\nvar MAIN_DATA = '\\0__link_mainData'; // Caution:\n// In most case, either list or its shallow clones (see list.cloneShallow)\n// is active in echarts process. So considering heap memory consumption,\n// we do not clone tree or graph, but share them among list and its shallow clones.\n// But in some rare case, we have to keep old list (like do animation in chart). So\n// please take care that both the old list and the new list share the same tree/graph.\n\n/**\n * @param {Object} opt\n * @param {module:echarts/data/List} opt.mainData\n * @param {Object} [opt.struct] For example, instance of Graph or Tree.\n * @param {string} [opt.structAttr] designation: list[structAttr] = struct;\n * @param {Object} [opt.datas] {dataType: data},\n *                 like: {node: nodeList, edge: edgeList}.\n *                 Should contain mainData.\n * @param {Object} [opt.datasAttr] {dataType: attr},\n *                 designation: struct[datasAttr[dataType]] = list;\n */\n\nfunction linkList(opt) {\n  var mainData = opt.mainData;\n  var datas = opt.datas;\n\n  if (!datas) {\n    datas = {\n      main: mainData\n    };\n    opt.datasAttr = {\n      main: 'data'\n    };\n  }\n\n  opt.datas = opt.mainData = null;\n  linkAll(mainData, datas, opt); // Porxy data original methods.\n\n  each(datas, function (data) {\n    each(mainData.TRANSFERABLE_METHODS, function (methodName) {\n      data.wrapMethod(methodName, zrUtil.curry(transferInjection, opt));\n    });\n  }); // Beyond transfer, additional features should be added to `cloneShallow`.\n\n  mainData.wrapMethod('cloneShallow', zrUtil.curry(cloneShallowInjection, opt)); // Only mainData trigger change, because struct.update may trigger\n  // another changable methods, which may bring about dead lock.\n\n  each(mainData.CHANGABLE_METHODS, function (methodName) {\n    mainData.wrapMethod(methodName, zrUtil.curry(changeInjection, opt));\n  }); // Make sure datas contains mainData.\n\n  zrUtil.assert(datas[mainData.dataType] === mainData);\n}\n\nfunction transferInjection(opt, res) {\n  if (isMainData(this)) {\n    // Transfer datas to new main data.\n    var datas = zrUtil.extend({}, this[DATAS]);\n    datas[this.dataType] = res;\n    linkAll(res, datas, opt);\n  } else {\n    // Modify the reference in main data to point newData.\n    linkSingle(res, this.dataType, this[MAIN_DATA], opt);\n  }\n\n  return res;\n}\n\nfunction changeInjection(opt, res) {\n  opt.struct && opt.struct.update(this);\n  return res;\n}\n\nfunction cloneShallowInjection(opt, res) {\n  // cloneShallow, which brings about some fragilities, may be inappropriate\n  // to be exposed as an API. So for implementation simplicity we can make\n  // the restriction that cloneShallow of not-mainData should not be invoked\n  // outside, but only be invoked here.\n  each(res[DATAS], function (data, dataType) {\n    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);\n  });\n  return res;\n}\n/**\n * Supplement method to List.\n *\n * @public\n * @param {string} [dataType] If not specified, return mainData.\n * @return {module:echarts/data/List}\n */\n\n\nfunction getLinkedData(dataType) {\n  var mainData = this[MAIN_DATA];\n  return dataType == null || mainData == null ? mainData : mainData[DATAS][dataType];\n}\n\nfunction isMainData(data) {\n  return data[MAIN_DATA] === data;\n}\n\nfunction linkAll(mainData, datas, opt) {\n  mainData[DATAS] = {};\n  each(datas, function (data, dataType) {\n    linkSingle(data, dataType, mainData, opt);\n  });\n}\n\nfunction linkSingle(data, dataType, mainData, opt) {\n  mainData[DATAS][dataType] = data;\n  data[MAIN_DATA] = mainData;\n  data.dataType = dataType;\n\n  if (opt.struct) {\n    data[opt.structAttr] = opt.struct;\n    opt.struct[opt.datasAttr[dataType]] = data;\n  } // Supplement method.\n\n\n  data.getLinkedData = getLinkedData;\n}\n\nvar _default = linkList;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 675:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/**\n * @param {number} [time=500] Time in ms\n * @param {string} [easing='linear']\n * @param {number} [delay=0]\n * @param {Function} [callback]\n *\n * @example\n *  // Animate position\n *  animation\n *      .createWrap()\n *      .add(el1, {position: [10, 10]})\n *      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)\n *      .done(function () { // done })\n *      .start('cubicOut');\n */\nfunction createWrap() {\n  var storage = [];\n  var elExistsMap = {};\n  var doneCallback;\n  return {\n    /**\n     * Caution: a el can only be added once, otherwise 'done'\n     * might not be called. This method checks this (by el.id),\n     * suppresses adding and returns false when existing el found.\n     *\n     * @param {modele:zrender/Element} el\n     * @param {Object} target\n     * @param {number} [time=500]\n     * @param {number} [delay=0]\n     * @param {string} [easing='linear']\n     * @return {boolean} Whether adding succeeded.\n     *\n     * @example\n     *     add(el, target, time, delay, easing);\n     *     add(el, target, time, easing);\n     *     add(el, target, time);\n     *     add(el, target);\n     */\n    add: function (el, target, time, delay, easing) {\n      if (zrUtil.isString(delay)) {\n        easing = delay;\n        delay = 0;\n      }\n\n      if (elExistsMap[el.id]) {\n        return false;\n      }\n\n      elExistsMap[el.id] = 1;\n      storage.push({\n        el: el,\n        target: target,\n        time: time,\n        delay: delay,\n        easing: easing\n      });\n      return true;\n    },\n\n    /**\n     * Only execute when animation finished. Will not execute when any\n     * of 'stop' or 'stopAnimation' called.\n     *\n     * @param {Function} callback\n     */\n    done: function (callback) {\n      doneCallback = callback;\n      return this;\n    },\n\n    /**\n     * Will stop exist animation firstly.\n     */\n    start: function () {\n      var count = storage.length;\n\n      for (var i = 0, len = storage.length; i < len; i++) {\n        var item = storage[i];\n        item.el.animateTo(item.target, item.time, item.delay, item.easing, done);\n      }\n\n      return this;\n\n      function done() {\n        count--;\n\n        if (!count) {\n          storage.length = 0;\n          elExistsMap = {};\n          doneCallback && doneCallback();\n        }\n      }\n    }\n  };\n}\n\nexports.createWrap = createWrap;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/44.bc7fe003206a95f49c0c.js","var zrUtil = require(\"zrender/lib/core/util\");\n\nfunction retrieveTargetInfo(payload, seriesModel) {\n  if (payload && (payload.type === 'treemapZoomToNode' || payload.type === 'treemapRootToNode')) {\n    var root = seriesModel.getData().tree.root;\n    var targetNode = payload.targetNode;\n\n    if (targetNode && root.contains(targetNode)) {\n      return {\n        node: targetNode\n      };\n    }\n\n    var targetNodeId = payload.targetNodeId;\n\n    if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {\n      return {\n        node: targetNode\n      };\n    }\n  }\n} // Not includes the given node at the last item.\n\n\nfunction getPathToRoot(node) {\n  var path = [];\n\n  while (node) {\n    node = node.parentNode;\n    node && path.push(node);\n  }\n\n  return path.reverse();\n}\n\nfunction aboveViewRoot(viewRoot, node) {\n  var viewPath = getPathToRoot(viewRoot);\n  return zrUtil.indexOf(viewPath, node) >= 0;\n} // From root to the input node (the input node will be included).\n\n\nfunction wrapTreePathInfo(node, seriesModel) {\n  var treePathInfo = [];\n\n  while (node) {\n    var nodeDataIndex = node.dataIndex;\n    treePathInfo.push({\n      name: node.name,\n      dataIndex: nodeDataIndex,\n      value: seriesModel.getRawValue(nodeDataIndex)\n    });\n    node = node.parentNode;\n  }\n\n  treePathInfo.reverse();\n  return treePathInfo;\n}\n\nexports.retrieveTargetInfo = retrieveTargetInfo;\nexports.getPathToRoot = getPathToRoot;\nexports.aboveViewRoot = aboveViewRoot;\nexports.wrapTreePathInfo = wrapTreePathInfo;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/chart/treemap/helper.js\n// module id = 533\n// module chunks = 44","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar helper = require(\"./helper\");\n\nvar AxisProxy = require(\"./AxisProxy\");\n\nvar each = zrUtil.each;\nvar eachAxisDim = helper.eachAxisDim;\nvar DataZoomModel = echarts.extendComponentModel({\n  type: 'dataZoom',\n  dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    zlevel: 0,\n    z: 4,\n    // Higher than normal component (z: 2).\n    orient: null,\n    // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n    xAxisIndex: null,\n    // Default the first horizontal category axis.\n    yAxisIndex: null,\n    // Default the first vertical category axis.\n    filterMode: 'filter',\n    // Possible values: 'filter' or 'empty' or 'weakFilter'.\n    // 'filter': data items which are out of window will be removed. This option is\n    //          applicable when filtering outliers. For each data item, it will be\n    //          filtered if one of the relevant dimensions is out of the window.\n    // 'weakFilter': data items which are out of window will be removed. This option\n    //          is applicable when filtering outliers. For each data item, it will be\n    //          filtered only if all  of the relevant dimensions are out of the same\n    //          side of the window.\n    // 'empty': data items which are out of window will be set to empty.\n    //          This option is applicable when user should not neglect\n    //          that there are some data items out of window.\n    // 'none': Do not filter.\n    // Taking line chart as an example, line will be broken in\n    // the filtered points when filterModel is set to 'empty', but\n    // be connected when set to 'filter'.\n    throttle: null,\n    // Dispatch action by the fixed rate, avoid frequency.\n    // default 100. Do not throttle when use null/undefined.\n    // If animation === true and animationDurationUpdate > 0,\n    // default value is 100, otherwise 20.\n    start: 0,\n    // Start percent. 0 ~ 100\n    end: 100,\n    // End percent. 0 ~ 100\n    startValue: null,\n    // Start value. If startValue specified, start is ignored.\n    endValue: null,\n    // End value. If endValue specified, end is ignored.\n    minSpan: null,\n    // 0 ~ 100\n    maxSpan: null,\n    // 0 ~ 100\n    minValueSpan: null,\n    // The range of dataZoom can not be smaller than that.\n    maxValueSpan: null,\n    // The range of dataZoom can not be larger than that.\n    rangeMode: null // Array, can be 'value' or 'percent'.\n\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel) {\n    /**\n     * key like x_0, y_1\n     * @private\n     * @type {Object}\n     */\n    this._dataIntervalByAxis = {};\n    /**\n     * @private\n     */\n\n    this._dataInfo = {};\n    /**\n     * key like x_0, y_1\n     * @private\n     */\n\n    this._axisProxies = {};\n    /**\n     * @readOnly\n     */\n\n    this.textStyleModel;\n    /**\n     * @private\n     */\n\n    this._autoThrottle = true;\n    /**\n     * 'percent' or 'value'\n     * @private\n     */\n\n    this._rangePropMode = ['percent', 'percent'];\n    var rawOption = retrieveRaw(option);\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (newOption) {\n    var rawOption = retrieveRaw(newOption); //FIX #2591\n\n    zrUtil.merge(this.option, newOption, true);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @protected\n   */\n  doInit: function (rawOption) {\n    var thisOption = this.option; // Disable realtime view update if canvas is not supported.\n\n    if (!env.canvasSupported) {\n      thisOption.realtime = false;\n    }\n\n    this._setDefaultThrottle(rawOption);\n\n    updateRangeUse(this, rawOption);\n    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = null;\n      } // Otherwise do nothing and use the merge result.\n\n    }, this);\n    this.textStyleModel = this.getModel('textStyle');\n\n    this._resetTarget();\n\n    this._giveAxisProxies();\n  },\n\n  /**\n   * @private\n   */\n  _giveAxisProxies: function () {\n    var axisProxies = this._axisProxies;\n    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n      var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.\n\n      var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.\n      axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME\n      // dispose __dzAxisProxy\n\n      axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetTarget: function () {\n    var thisOption = this.option;\n\n    var autoMode = this._judgeAutoMode();\n\n    eachAxisDim(function (dimNames) {\n      var axisIndexName = dimNames.axisIndex;\n      thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);\n    }, this);\n\n    if (autoMode === 'axisIndex') {\n      this._autoSetAxisIndex();\n    } else if (autoMode === 'orient') {\n      this._autoSetOrient();\n    }\n  },\n\n  /**\n   * @private\n   */\n  _judgeAutoMode: function () {\n    // Auto set only works for setOption at the first time.\n    // The following is user's reponsibility. So using merged\n    // option is OK.\n    var thisOption = this.option;\n    var hasIndexSpecified = false;\n    eachAxisDim(function (dimNames) {\n      // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occured.\n      if (thisOption[dimNames.axisIndex] != null) {\n        hasIndexSpecified = true;\n      }\n    }, this);\n    var orient = thisOption.orient;\n\n    if (orient == null && hasIndexSpecified) {\n      return 'orient';\n    } else if (!hasIndexSpecified) {\n      if (orient == null) {\n        thisOption.orient = 'horizontal';\n      }\n\n      return 'axisIndex';\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetAxisIndex: function () {\n    var autoAxisIndex = true;\n    var orient = this.get('orient', true);\n    var thisOption = this.option;\n    var dependentModels = this.dependentModels;\n\n    if (autoAxisIndex) {\n      // Find axis that parallel to dataZoom as default.\n      var dimName = orient === 'vertical' ? 'y' : 'x';\n\n      if (dependentModels[dimName + 'Axis'].length) {\n        thisOption[dimName + 'AxisIndex'] = [0];\n        autoAxisIndex = false;\n      } else {\n        each(dependentModels.singleAxis, function (singleAxisModel) {\n          if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n            autoAxisIndex = false;\n          }\n        });\n      }\n    }\n\n    if (autoAxisIndex) {\n      // Find the first category axis as default. (consider polar)\n      eachAxisDim(function (dimNames) {\n        if (!autoAxisIndex) {\n          return;\n        }\n\n        var axisIndices = [];\n        var axisModels = this.dependentModels[dimNames.axis];\n\n        if (axisModels.length && !axisIndices.length) {\n          for (var i = 0, len = axisModels.length; i < len; i++) {\n            if (axisModels[i].get('type') === 'category') {\n              axisIndices.push(i);\n            }\n          }\n        }\n\n        thisOption[dimNames.axisIndex] = axisIndices;\n\n        if (axisIndices.length) {\n          autoAxisIndex = false;\n        }\n      }, this);\n    }\n\n    if (autoAxisIndex) {\n      // FIXME\n      // 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），\n      // 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？\n      // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n      // dataZoom component auto adopts series that reference to\n      // both xAxis and yAxis which type is 'value'.\n      this.ecModel.eachSeries(function (seriesModel) {\n        if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n          eachAxisDim(function (dimNames) {\n            var axisIndices = thisOption[dimNames.axisIndex];\n            var axisIndex = seriesModel.get(dimNames.axisIndex);\n            var axisId = seriesModel.get(dimNames.axisId);\n            var axisModel = seriesModel.ecModel.queryComponents({\n              mainType: dimNames.axis,\n              index: axisIndex,\n              id: axisId\n            })[0];\n            axisIndex = axisModel.componentIndex;\n\n            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n              axisIndices.push(axisIndex);\n            }\n          });\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetOrient: function () {\n    var dim; // Find the first axis\n\n    this.eachTargetAxis(function (dimNames) {\n      !dim && (dim = dimNames.name);\n    }, this);\n    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n  },\n\n  /**\n   * @private\n   */\n  _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n    // FIXME\n    // 需要series的xAxisIndex和yAxisIndex都首先自动设置上。\n    // 例如series.type === scatter时。\n    var is = true;\n    eachAxisDim(function (dimNames) {\n      var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n      var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n      if (!axisModel || axisModel.get('type') !== axisType) {\n        is = false;\n      }\n    }, this);\n    return is;\n  },\n\n  /**\n   * @private\n   */\n  _setDefaultThrottle: function (rawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (rawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  },\n\n  /**\n   * @public\n   */\n  getFirstTargetAxisModel: function () {\n    var firstAxisModel;\n    eachAxisDim(function (dimNames) {\n      if (firstAxisModel == null) {\n        var indices = this.get(dimNames.axisIndex);\n\n        if (indices.length) {\n          firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n        }\n      }\n    }, this);\n    return firstAxisModel;\n  },\n\n  /**\n   * @public\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n   */\n  eachTargetAxis: function (callback, context) {\n    var ecModel = this.ecModel;\n    eachAxisDim(function (dimNames) {\n      each(this.get(dimNames.axisIndex), function (axisIndex) {\n        callback.call(context, dimNames, axisIndex, this, ecModel);\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n   */\n  getAxisProxy: function (dimName, axisIndex) {\n    return this._axisProxies[dimName + '_' + axisIndex];\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/model/Model} If not found, return null/undefined.\n   */\n  getAxisModel: function (dimName, axisIndex) {\n    var axisProxy = this.getAxisProxy(dimName, axisIndex);\n    return axisProxy && axisProxy.getAxisModel();\n  },\n\n  /**\n   * If not specified, set to undefined.\n   *\n   * @public\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   * @param {boolean} [ignoreUpdateRangeUsg=false]\n   */\n  setRawRange: function (opt, ignoreUpdateRangeUsg) {\n    var option = this.option;\n    each([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // If only one of 'start' and 'startValue' is not null/undefined, the other\n      // should be cleared, which enable clear the option.\n      // If both of them are not set, keep option with the original value, which\n      // enable use only set start but not set end when calling `dispatchAction`.\n      // The same as 'end' and 'endValue'.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        option[names[0]] = opt[names[0]];\n        option[names[1]] = opt[names[1]];\n      }\n    }, this);\n    !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n  },\n\n  /**\n   * @public\n   * @return {Array.<number>} [startPercent, endPercent]\n   */\n  getPercentRange: function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  },\n\n  /**\n   * @public\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n   *\n   * @param {string} [axisDimName]\n   * @param {number} [axisIndex]\n   * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n   */\n  getValueRange: function (axisDimName, axisIndex) {\n    if (axisDimName == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n    }\n  },\n\n  /**\n   * @public\n   * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n   *      corresponding to the axisModel\n   * @return {module:echarts/component/dataZoom/AxisProxy}\n   */\n  findRepresentativeAxisProxy: function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    } // Find the first hosted axisProxy\n\n\n    var axisProxies = this._axisProxies;\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    } // If no hosted axis find not hosted axisProxy.\n    // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n    // and the option.start or option.end settings are different. The percentRange\n    // should follow axisProxy.\n    // (We encounter this problem in toolbox data zoom.)\n\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    }\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getRangePropMode: function () {\n    return this._rangePropMode.slice();\n  }\n});\n\nfunction retrieveRaw(option) {\n  var ret = {};\n  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n\nfunction updateRangeUse(dataZoomModel, rawOption) {\n  var rangePropMode = dataZoomModel._rangePropMode;\n  var rangeModeInOption = dataZoomModel.get('rangeMode');\n  each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n    var percentSpecified = rawOption[names[0]] != null;\n    var valueSpecified = rawOption[names[1]] != null;\n\n    if (percentSpecified && !valueSpecified) {\n      rangePropMode[index] = 'percent';\n    } else if (!percentSpecified && valueSpecified) {\n      rangePropMode[index] = 'value';\n    } else if (rangeModeInOption) {\n      rangePropMode[index] = rangeModeInOption[index];\n    } else if (percentSpecified) {\n      // percentSpecified && valueSpecified\n      rangePropMode[index] = 'percent';\n    } // else remain its original setting.\n\n  });\n}\n\nvar _default = DataZoomModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/DataZoomModel.js\n// module id = 561\n// module chunks = 44","var ComponentView = require(\"../../view/Component\");\n\nvar _default = ComponentView.extend({\n  type: 'dataZoom',\n  render: function (dataZoomModel, ecModel, api, payload) {\n    this.dataZoomModel = dataZoomModel;\n    this.ecModel = ecModel;\n    this.api = api;\n  },\n\n  /**\n   * Find the first target coordinate system.\n   *\n   * @protected\n   * @return {Object} {\n   *                   grid: [\n   *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n   *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n   *                       ...\n   *                   ],  // cartesians must not be null/undefined.\n   *                   polar: [\n   *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n   *                       ...\n   *                   ],  // polars must not be null/undefined.\n   *                   singleAxis: [\n   *                       {model: coord0, axisModels: [], coordIndex: 0}\n   *                   ]\n   */\n  getTargetCoordInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var ecModel = this.ecModel;\n    var coordSysLists = {};\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n\n      if (axisModel) {\n        var coordModel = axisModel.getCoordSysModel();\n        coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);\n      }\n    }, this);\n\n    function save(coordModel, axisModel, store, coordIndex) {\n      var item;\n\n      for (var i = 0; i < store.length; i++) {\n        if (store[i].model === coordModel) {\n          item = store[i];\n          break;\n        }\n      }\n\n      if (!item) {\n        store.push(item = {\n          model: coordModel,\n          axisModels: [],\n          coordIndex: coordIndex\n        });\n      }\n\n      item.axisModels.push(axisModel);\n    }\n\n    return coordSysLists;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/DataZoomView.js\n// module id = 562\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.\n\nvar COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n/**\n * @param {string} coordType\n * @return {boolean}\n */\n\nfunction isCoordSupported(coordType) {\n  return zrUtil.indexOf(COORDS, coordType) >= 0;\n}\n/**\n * Create \"each\" method to iterate names.\n *\n * @pubilc\n * @param  {Array.<string>} names\n * @param  {Array.<string>=} attrs\n * @return {Function}\n */\n\n\nfunction createNameEach(names, attrs) {\n  names = names.slice();\n  var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n  attrs = (attrs || []).slice();\n  var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n  return function (callback, context) {\n    zrUtil.each(names, function (name, index) {\n      var nameObj = {\n        name: name,\n        capital: capitalNames[index]\n      };\n\n      for (var j = 0; j < attrs.length; j++) {\n        nameObj[attrs[j]] = name + capitalAttrs[j];\n      }\n\n      callback.call(context, nameObj);\n    });\n  };\n}\n/**\n * Iterate each dimension name.\n *\n * @public\n * @param {Function} callback The parameter is like:\n *                            {\n *                                name: 'angle',\n *                                capital: 'Angle',\n *                                axis: 'angleAxis',\n *                                axisIndex: 'angleAixs',\n *                                index: 'angleIndex'\n *                            }\n * @param {Object} context\n */\n\n\nvar eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n/**\n * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n * dataZoomModels and 'links' make up one or more graphics.\n * This function finds the graphic where the source dataZoomModel is in.\n *\n * @public\n * @param {Function} forEachNode Node iterator.\n * @param {Function} forEachEdgeType edgeType iterator\n * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n */\n\nfunction createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {\n  return function (sourceNode) {\n    var result = {\n      nodes: [],\n      records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n\n    };\n    forEachEdgeType(function (edgeType) {\n      result.records[edgeType.name] = {};\n    });\n\n    if (!sourceNode) {\n      return result;\n    }\n\n    absorb(sourceNode, result);\n    var existsLink;\n\n    do {\n      existsLink = false;\n      forEachNode(processSingleNode);\n    } while (existsLink);\n\n    function processSingleNode(node) {\n      if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n        absorb(node, result);\n        existsLink = true;\n      }\n    }\n\n    return result;\n  };\n\n  function isNodeAbsorded(node, result) {\n    return zrUtil.indexOf(result.nodes, node) >= 0;\n  }\n\n  function isLinked(node, result) {\n    var hasLink = false;\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] && (hasLink = true);\n      });\n    });\n    return hasLink;\n  }\n\n  function absorb(node, result) {\n    result.nodes.push(node);\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] = true;\n      });\n    });\n  }\n}\n\nexports.isCoordSupported = isCoordSupported;\nexports.createNameEach = createNameEach;\nexports.eachAxisDim = eachAxisDim;\nexports.createLinkedNodesFinder = createLinkedNodesFinder;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/helper.js\n// module id = 563\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar vector = require(\"zrender/lib/core/vector\");\n\nvar symbolUtil = require(\"../../util/symbol\");\n\nvar LinePath = require(\"./LinePath\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar round = _number.round;\n\n/**\n * @module echarts/chart/helper/Line\n */\nvar SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];\n\nfunction makeSymbolTypeKey(symbolCategory) {\n  return '_' + symbolCategory + 'Type';\n}\n/**\n * @inner\n */\n\n\nfunction createSymbol(name, lineData, idx) {\n  var color = lineData.getItemVisual(idx, 'color');\n  var symbolType = lineData.getItemVisual(idx, name);\n  var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n\n  if (!symbolType || symbolType === 'none') {\n    return;\n  }\n\n  if (!zrUtil.isArray(symbolSize)) {\n    symbolSize = [symbolSize, symbolSize];\n  }\n\n  var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);\n  symbolPath.name = name;\n  return symbolPath;\n}\n\nfunction createLine(points) {\n  var line = new LinePath({\n    name: 'line'\n  });\n  setLinePoints(line.shape, points);\n  return line;\n}\n\nfunction setLinePoints(targetShape, points) {\n  var p1 = points[0];\n  var p2 = points[1];\n  var cp1 = points[2];\n  targetShape.x1 = p1[0];\n  targetShape.y1 = p1[1];\n  targetShape.x2 = p2[0];\n  targetShape.y2 = p2[1];\n  targetShape.percent = 1;\n\n  if (cp1) {\n    targetShape.cpx1 = cp1[0];\n    targetShape.cpy1 = cp1[1];\n  } else {\n    targetShape.cpx1 = NaN;\n    targetShape.cpy1 = NaN;\n  }\n}\n\nfunction updateSymbolAndLabelBeforeLineUpdate() {\n  var lineGroup = this;\n  var symbolFrom = lineGroup.childOfName('fromSymbol');\n  var symbolTo = lineGroup.childOfName('toSymbol');\n  var label = lineGroup.childOfName('label'); // Quick reject\n\n  if (!symbolFrom && !symbolTo && label.ignore) {\n    return;\n  }\n\n  var invScale = 1;\n  var parentNode = this.parent;\n\n  while (parentNode) {\n    if (parentNode.scale) {\n      invScale /= parentNode.scale[0];\n    }\n\n    parentNode = parentNode.parent;\n  }\n\n  var line = lineGroup.childOfName('line'); // If line not changed\n  // FIXME Parent scale changed\n\n  if (!this.__dirty && !line.__dirty) {\n    return;\n  }\n\n  var percent = line.shape.percent;\n  var fromPos = line.pointAt(0);\n  var toPos = line.pointAt(percent);\n  var d = vector.sub([], toPos, fromPos);\n  vector.normalize(d, d);\n\n  if (symbolFrom) {\n    symbolFrom.attr('position', fromPos);\n    var tangent = line.tangentAt(0);\n    symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));\n    symbolFrom.attr('scale', [invScale * percent, invScale * percent]);\n  }\n\n  if (symbolTo) {\n    symbolTo.attr('position', toPos);\n    var tangent = line.tangentAt(1);\n    symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));\n    symbolTo.attr('scale', [invScale * percent, invScale * percent]);\n  }\n\n  if (!label.ignore) {\n    label.attr('position', toPos);\n    var textPosition;\n    var textAlign;\n    var textVerticalAlign;\n    var distance = 5 * invScale; // End\n\n    if (label.__position === 'end') {\n      textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];\n      textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';\n      textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';\n    } // Middle\n    else if (label.__position === 'middle') {\n        var halfPercent = percent / 2;\n        var tangent = line.tangentAt(halfPercent);\n        var n = [tangent[1], -tangent[0]];\n        var cp = line.pointAt(halfPercent);\n\n        if (n[1] > 0) {\n          n[0] = -n[0];\n          n[1] = -n[1];\n        }\n\n        textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];\n        textAlign = 'center';\n        textVerticalAlign = 'bottom';\n        var rotation = -Math.atan2(tangent[1], tangent[0]);\n\n        if (toPos[0] < fromPos[0]) {\n          rotation = Math.PI + rotation;\n        }\n\n        label.attr('rotation', rotation);\n      } // Start\n      else {\n          textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];\n          textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';\n          textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';\n        }\n\n    label.attr({\n      style: {\n        // Use the user specified text align and baseline first\n        textVerticalAlign: label.__verticalAlign || textVerticalAlign,\n        textAlign: label.__textAlign || textAlign\n      },\n      position: textPosition,\n      scale: [invScale, invScale]\n    });\n  }\n}\n/**\n * @constructor\n * @extends {module:zrender/graphic/Group}\n * @alias {module:echarts/chart/helper/Line}\n */\n\n\nfunction Line(lineData, idx, seriesScope) {\n  graphic.Group.call(this);\n\n  this._createLine(lineData, idx, seriesScope);\n}\n\nvar lineProto = Line.prototype; // Update symbol position and rotation\n\nlineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;\n\nlineProto._createLine = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var linePoints = lineData.getItemLayout(idx);\n  var line = createLine(linePoints);\n  line.shape.percent = 0;\n  graphic.initProps(line, {\n    shape: {\n      percent: 1\n    }\n  }, seriesModel, idx);\n  this.add(line);\n  var label = new graphic.Text({\n    name: 'label'\n  });\n  this.add(label);\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbol = createSymbol(symbolCategory, lineData, idx); // symbols must added after line to make sure\n    // it will be updated after line#update.\n    // Or symbol position and rotation update in line#beforeUpdate will be one frame slow\n\n    this.add(symbol);\n    this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);\n  }, this);\n\n  this._updateCommonStl(lineData, idx, seriesScope);\n};\n\nlineProto.updateData = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var line = this.childOfName('line');\n  var linePoints = lineData.getItemLayout(idx);\n  var target = {\n    shape: {}\n  };\n  setLinePoints(target.shape, linePoints);\n  graphic.updateProps(line, target, seriesModel, idx);\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbolType = lineData.getItemVisual(idx, symbolCategory);\n    var key = makeSymbolTypeKey(symbolCategory); // Symbol changed\n\n    if (this[key] !== symbolType) {\n      this.remove(this.childOfName(symbolCategory));\n      var symbol = createSymbol(symbolCategory, lineData, idx);\n      this.add(symbol);\n    }\n\n    this[key] = symbolType;\n  }, this);\n\n  this._updateCommonStl(lineData, idx, seriesScope);\n};\n\nlineProto._updateCommonStl = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var line = this.childOfName('line');\n  var lineStyle = seriesScope && seriesScope.lineStyle;\n  var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; // Optimization for large dataset\n\n  if (!seriesScope || lineData.hasItemOption) {\n    var itemModel = lineData.getItemModel(idx);\n    lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();\n    hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n    labelModel = itemModel.getModel('label.normal');\n    hoverLabelModel = itemModel.getModel('label.emphasis');\n  }\n\n  var visualColor = lineData.getItemVisual(idx, 'color');\n  var visualOpacity = zrUtil.retrieve3(lineData.getItemVisual(idx, 'opacity'), lineStyle.opacity, 1);\n  line.useStyle(zrUtil.defaults({\n    strokeNoScale: true,\n    fill: 'none',\n    stroke: visualColor,\n    opacity: visualOpacity\n  }, lineStyle));\n  line.hoverStyle = hoverLineStyle; // Update symbol\n\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbol = this.childOfName(symbolCategory);\n\n    if (symbol) {\n      symbol.setColor(visualColor);\n      symbol.setStyle({\n        opacity: visualOpacity\n      });\n    }\n  }, this);\n  var showLabel = labelModel.getShallow('show');\n  var hoverShowLabel = hoverLabelModel.getShallow('show');\n  var label = this.childOfName('label');\n  var defaultLabelColor;\n  var defaultText;\n  var normalText;\n  var emphasisText;\n\n  if (showLabel || hoverShowLabel) {\n    var rawVal = seriesModel.getRawValue(idx);\n    defaultText = rawVal == null ? defaultText = lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal;\n    defaultLabelColor = visualColor || '#000';\n    normalText = zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType), defaultText);\n    emphasisText = zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), normalText);\n  } // label.afterUpdate = lineAfterUpdate;\n\n\n  if (showLabel) {\n    var labelStyle = graphic.setTextStyle(label.style, labelModel, {\n      text: normalText\n    }, {\n      autoColor: defaultLabelColor\n    });\n    label.__textAlign = labelStyle.textAlign;\n    label.__verticalAlign = labelStyle.textVerticalAlign; // 'start', 'middle', 'end'\n\n    label.__position = labelModel.get('position') || 'middle';\n  } else {\n    label.setStyle('text', null);\n  }\n\n  if (hoverShowLabel) {\n    // Only these properties supported in this emphasis style here.\n    label.hoverStyle = {\n      text: emphasisText,\n      textFill: hoverLabelModel.getTextColor(true),\n      // For merging hover style to normal style, do not use\n      // `hoverLabelModel.getFont()` here.\n      fontStyle: hoverLabelModel.getShallow('fontStyle'),\n      fontWeight: hoverLabelModel.getShallow('fontWeight'),\n      fontSize: hoverLabelModel.getShallow('fontSize'),\n      fontFamily: hoverLabelModel.getShallow('fontFamily')\n    };\n  } else {\n    label.hoverStyle = {\n      text: null\n    };\n  }\n\n  label.ignore = !showLabel && !hoverShowLabel;\n  graphic.setHoverStyle(this);\n};\n\nlineProto.highlight = function () {\n  this.trigger('emphasis');\n};\n\nlineProto.downplay = function () {\n  this.trigger('normal');\n};\n\nlineProto.updateLayout = function (lineData, idx) {\n  this.setLinePoints(lineData.getItemLayout(idx));\n};\n\nlineProto.setLinePoints = function (points) {\n  var linePath = this.childOfName('line');\n  setLinePoints(linePath.shape, points);\n  linePath.dirty();\n};\n\nzrUtil.inherits(Line, graphic.Group);\nvar _default = Line;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/chart/helper/Line.js\n// module id = 647\n// module chunks = 44","var graphic = require(\"../../util/graphic\");\n\nvar LineGroup = require(\"./Line\");\n\n/**\n * @module echarts/chart/helper/LineDraw\n */\nfunction isPointNaN(pt) {\n  return isNaN(pt[0]) || isNaN(pt[1]);\n}\n\nfunction lineNeedsDraw(pts) {\n  return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);\n}\n/**\n * @alias module:echarts/component/marker/LineDraw\n * @constructor\n */\n\n\nfunction LineDraw(ctor) {\n  this._ctor = ctor || LineGroup;\n  this.group = new graphic.Group();\n}\n\nvar lineDrawProto = LineDraw.prototype;\n/**\n * @param {module:echarts/data/List} lineData\n */\n\nlineDrawProto.updateData = function (lineData) {\n  var oldLineData = this._lineData;\n  var group = this.group;\n  var LineCtor = this._ctor;\n  var hostModel = lineData.hostModel;\n  var seriesScope = {\n    lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(),\n    hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(),\n    labelModel: hostModel.getModel('label.normal'),\n    hoverLabelModel: hostModel.getModel('label.emphasis')\n  };\n  lineData.diff(oldLineData).add(function (idx) {\n    if (!lineNeedsDraw(lineData.getItemLayout(idx))) {\n      return;\n    }\n\n    var lineGroup = new LineCtor(lineData, idx, seriesScope);\n    lineData.setItemGraphicEl(idx, lineGroup);\n    group.add(lineGroup);\n  }).update(function (newIdx, oldIdx) {\n    var lineGroup = oldLineData.getItemGraphicEl(oldIdx);\n\n    if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) {\n      group.remove(lineGroup);\n      return;\n    }\n\n    if (!lineGroup) {\n      lineGroup = new LineCtor(lineData, newIdx, seriesScope);\n    } else {\n      lineGroup.updateData(lineData, newIdx, seriesScope);\n    }\n\n    lineData.setItemGraphicEl(newIdx, lineGroup);\n    group.add(lineGroup);\n  }).remove(function (idx) {\n    group.remove(oldLineData.getItemGraphicEl(idx));\n  }).execute();\n  this._lineData = lineData;\n};\n\nlineDrawProto.updateLayout = function () {\n  var lineData = this._lineData;\n  lineData.eachItemGraphicEl(function (el, idx) {\n    el.updateLayout(lineData, idx);\n  }, this);\n};\n\nlineDrawProto.remove = function () {\n  this.group.removeAll();\n};\n\nvar _default = LineDraw;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/chart/helper/LineDraw.js\n// module id = 648\n// module chunks = 44","var graphic = require(\"../../util/graphic\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\n/**\n * Line path for bezier and straight line draw\n */\nvar straightLineProto = graphic.Line.prototype;\nvar bezierCurveProto = graphic.BezierCurve.prototype;\n\nfunction isLine(shape) {\n  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);\n}\n\nvar _default = graphic.extendShape({\n  type: 'ec-line',\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    percent: 1,\n    cpx1: null,\n    cpy1: null\n  },\n  buildPath: function (ctx, shape) {\n    (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);\n  },\n  pointAt: function (t) {\n    return isLine(this.shape) ? straightLineProto.pointAt.call(this, t) : bezierCurveProto.pointAt.call(this, t);\n  },\n  tangentAt: function (t) {\n    var shape = this.shape;\n    var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/chart/helper/LinePath.js\n// module id = 649\n// module chunks = 44","var echarts = require(\"../echarts\");\n\nrequire(\"./treemap/TreemapSeries\");\n\nrequire(\"./treemap/TreemapView\");\n\nrequire(\"./treemap/treemapAction\");\n\nvar treemapVisual = require(\"./treemap/treemapVisual\");\n\nvar treemapLayout = require(\"./treemap/treemapLayout\");\n\necharts.registerVisual(treemapVisual);\necharts.registerLayout(treemapLayout);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/chart/treemap.js\n// module id = 650\n// module chunks = 44","var graphic = require(\"../../util/graphic\");\n\nvar layout = require(\"../../util/layout\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _helper = require(\"./helper\");\n\nvar wrapTreePathInfo = _helper.wrapTreePathInfo;\nvar TEXT_PADDING = 8;\nvar ITEM_GAP = 8;\nvar ARRAY_LENGTH = 5;\n\nfunction Breadcrumb(containerGroup) {\n  /**\n   * @private\n   * @type {module:zrender/container/Group}\n   */\n  this.group = new graphic.Group();\n  containerGroup.add(this.group);\n}\n\nBreadcrumb.prototype = {\n  constructor: Breadcrumb,\n  render: function (seriesModel, api, targetNode, onSelect) {\n    var model = seriesModel.getModel('breadcrumb');\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n\n    if (!model.get('show') || !targetNode) {\n      return;\n    }\n\n    var normalStyleModel = model.getModel('itemStyle.normal'); // var emphasisStyleModel = model.getModel('itemStyle.emphasis');\n\n    var textStyleModel = normalStyleModel.getModel('textStyle');\n    var layoutParam = {\n      pos: {\n        left: model.get('left'),\n        right: model.get('right'),\n        top: model.get('top'),\n        bottom: model.get('bottom')\n      },\n      box: {\n        width: api.getWidth(),\n        height: api.getHeight()\n      },\n      emptyItemWidth: model.get('emptyItemWidth'),\n      totalWidth: 0,\n      renderList: []\n    };\n\n    this._prepare(targetNode, layoutParam, textStyleModel);\n\n    this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);\n\n    layout.positionElement(thisGroup, layoutParam.pos, layoutParam.box);\n  },\n\n  /**\n   * Prepare render list and total width\n   * @private\n   */\n  _prepare: function (targetNode, layoutParam, textStyleModel) {\n    for (var node = targetNode; node; node = node.parentNode) {\n      var text = node.getModel().get('name');\n      var textRect = textStyleModel.getTextRect(text);\n      var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);\n      layoutParam.totalWidth += itemWidth + ITEM_GAP;\n      layoutParam.renderList.push({\n        node: node,\n        text: text,\n        width: itemWidth\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _renderContent: function (seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {\n    // Start rendering.\n    var lastX = 0;\n    var emptyItemWidth = layoutParam.emptyItemWidth;\n    var height = seriesModel.get('breadcrumb.height');\n    var availableSize = layout.getAvailableSize(layoutParam.pos, layoutParam.box);\n    var totalWidth = layoutParam.totalWidth;\n    var renderList = layoutParam.renderList;\n\n    for (var i = renderList.length - 1; i >= 0; i--) {\n      var item = renderList[i];\n      var itemNode = item.node;\n      var itemWidth = item.width;\n      var text = item.text; // Hdie text and shorten width if necessary.\n\n      if (totalWidth > availableSize.width) {\n        totalWidth -= itemWidth - emptyItemWidth;\n        itemWidth = emptyItemWidth;\n        text = null;\n      }\n\n      var el = new graphic.Polygon({\n        shape: {\n          points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)\n        },\n        style: zrUtil.defaults(normalStyleModel.getItemStyle(), {\n          lineJoin: 'bevel',\n          text: text,\n          textFill: textStyleModel.getTextColor(),\n          textFont: textStyleModel.getFont()\n        }),\n        z: 10,\n        onclick: zrUtil.curry(onSelect, itemNode)\n      });\n      this.group.add(el);\n      packEventData(el, seriesModel, itemNode);\n      lastX += itemWidth + ITEM_GAP;\n    }\n  },\n\n  /**\n   * @override\n   */\n  remove: function () {\n    this.group.removeAll();\n  }\n};\n\nfunction makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {\n  var points = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];\n  !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);\n  !head && points.push([x, y + itemHeight / 2]);\n  return points;\n} // Package custom mouse event.\n\n\nfunction packEventData(el, seriesModel, itemNode) {\n  el.eventData = {\n    componentType: 'series',\n    componentSubType: 'treemap',\n    seriesIndex: seriesModel.componentIndex,\n    seriesName: seriesModel.name,\n    seriesType: 'treemap',\n    selfType: 'breadcrumb',\n    // Distinguish with click event on treemap node.\n    nodeData: {\n      dataIndex: itemNode && itemNode.dataIndex,\n      name: itemNode && itemNode.name\n    },\n    treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)\n  };\n}\n\nvar _default = Breadcrumb;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/chart/treemap/Breadcrumb.js\n// module id = 651\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar Tree = require(\"../../data/Tree\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _format = require(\"../../util/format\");\n\nvar encodeHTML = _format.encodeHTML;\nvar addCommas = _format.addCommas;\n\nvar _helper = require(\"./helper\");\n\nvar wrapTreePathInfo = _helper.wrapTreePathInfo;\n\nvar _default = SeriesModel.extend({\n  type: 'series.treemap',\n  layoutMode: 'box',\n  dependencies: ['grid', 'polar'],\n\n  /**\n   * @type {module:echarts/data/Tree~Node}\n   */\n  _viewRoot: null,\n  defaultOption: {\n    // Disable progressive rendering\n    progressive: 0,\n    hoverLayerThreshold: Infinity,\n    // center: ['50%', '50%'],          // not supported in ec3.\n    // size: ['80%', '80%'],            // deprecated, compatible with ec2.\n    left: 'center',\n    top: 'middle',\n    right: null,\n    bottom: null,\n    width: '80%',\n    height: '80%',\n    sort: true,\n    // Can be null or false or true\n    // (order by desc default, asc not supported yet (strange effect))\n    clipWindow: 'origin',\n    // Size of clipped window when zooming. 'origin' or 'fullscreen'\n    squareRatio: 0.5 * (1 + Math.sqrt(5)),\n    // golden ratio\n    leafDepth: null,\n    // Nodes on depth from root are regarded as leaves.\n    // Count from zero (zero represents only view root).\n    drillDownIcon: '▶',\n    // Use html character temporarily because it is complicated\n    // to align specialized icon. ▷▶❒❐▼✚\n    zoomToNodeRatio: 0.32 * 0.32,\n    // Be effective when using zoomToNode. Specify the proportion of the\n    // target node area in the view area.\n    roam: true,\n    // true, false, 'scale' or 'zoom', 'move'.\n    nodeClick: 'zoomToNode',\n    // Leaf node click behaviour: 'zoomToNode', 'link', false.\n    // If leafDepth is set and clicking a node which has children but\n    // be on left depth, the behaviour would be changing root. Otherwise\n    // use behavious defined above.\n    animation: true,\n    animationDurationUpdate: 900,\n    animationEasing: 'quinticInOut',\n    breadcrumb: {\n      show: true,\n      height: 22,\n      left: 'center',\n      top: 'bottom',\n      // right\n      // bottom\n      emptyItemWidth: 25,\n      // Width of empty node.\n      itemStyle: {\n        normal: {\n          color: 'rgba(0,0,0,0.7)',\n          //'#5793f3',\n          borderColor: 'rgba(255,255,255,0.7)',\n          borderWidth: 1,\n          shadowColor: 'rgba(150,150,150,1)',\n          shadowBlur: 3,\n          shadowOffsetX: 0,\n          shadowOffsetY: 0,\n          textStyle: {\n            color: '#fff'\n          }\n        },\n        emphasis: {\n          textStyle: {}\n        }\n      }\n    },\n    label: {\n      normal: {\n        show: true,\n        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.\n        distance: 0,\n        padding: 5,\n        position: 'inside',\n        // Can be [5, '5%'] or position stirng like 'insideTopLeft', ...\n        // formatter: null,\n        color: '#fff',\n        ellipsis: true // align\n        // verticalAlign\n\n      }\n    },\n    upperLabel: {\n      // Label when node is parent.\n      normal: {\n        show: false,\n        position: [0, '50%'],\n        height: 20,\n        // formatter: null,\n        color: '#fff',\n        ellipsis: true,\n        // align: null,\n        verticalAlign: 'middle'\n      },\n      emphasis: {\n        show: true,\n        position: [0, '50%'],\n        color: '#fff',\n        ellipsis: true,\n        verticalAlign: 'middle'\n      }\n    },\n    itemStyle: {\n      normal: {\n        color: null,\n        // Can be 'none' if not necessary.\n        colorAlpha: null,\n        // Can be 'none' if not necessary.\n        colorSaturation: null,\n        // Can be 'none' if not necessary.\n        borderWidth: 0,\n        gapWidth: 0,\n        borderColor: '#fff',\n        borderColorSaturation: null // If specified, borderColor will be ineffective, and the\n        // border color is evaluated by color of current node and\n        // borderColorSaturation.\n\n      },\n      emphasis: {}\n    },\n    visualDimension: 0,\n    // Can be 0, 1, 2, 3.\n    visualMin: null,\n    visualMax: null,\n    color: [],\n    // + treemapSeries.color should not be modified. Please only modified\n    // level[n].color (if necessary).\n    // + Specify color list of each level. level[0].color would be global\n    // color list if not specified. (see method `setDefault`).\n    // + But set as a empty array to forbid fetch color from global palette\n    // when using nodeModel.get('color'), otherwise nodes on deep level\n    // will always has color palette set and are not able to inherit color\n    // from parent node.\n    // + TreemapSeries.color can not be set as 'none', otherwise effect\n    // legend color fetching (see seriesColor.js).\n    colorAlpha: null,\n    // Array. Specify color alpha range of each level, like [0.2, 0.8]\n    colorSaturation: null,\n    // Array. Specify color saturation of each level, like [0.2, 0.5]\n    colorMappingBy: 'index',\n    // 'value' or 'index' or 'id'.\n    visibleMin: 10,\n    // If area less than this threshold (unit: pixel^2), node will not\n    // be rendered. Only works when sort is 'asc' or 'desc'.\n    childrenVisibleMin: null,\n    // If area of a node less than this threshold (unit: pixel^2),\n    // grandchildren will not show.\n    // Why grandchildren? If not grandchildren but children,\n    // some siblings show children and some not,\n    // the appearance may be mess and not consistent,\n    levels: [] // Each item: {\n    //     visibleMin, itemStyle, visualDimension, label\n    // }\n    // data: {\n    //      value: [],\n    //      children: [],\n    //      link: 'http://xxx.xxx.xxx',\n    //      target: 'blank' or 'self'\n    // }\n\n  },\n\n  /**\n   * @override\n   */\n  getInitialData: function (option, ecModel) {\n    // Create a virtual root.\n    var root = {\n      name: option.name,\n      children: option.data\n    };\n    completeTreeValue(root);\n    var levels = option.levels || [];\n    levels = option.levels = setDefault(levels, ecModel);\n    var treeOption = {};\n    treeOption.levels = levels; // Make sure always a new tree is created when setOption,\n    // in TreemapView, we check whether oldTree === newTree\n    // to choose mappings approach among old shapes and new shapes.\n\n    return Tree.createTree(root, this, treeOption).data;\n  },\n  optionUpdated: function () {\n    this.resetViewRoot();\n  },\n\n  /**\n   * @override\n   * @param {number} dataIndex\n   * @param {boolean} [mutipleSeries=false]\n   */\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? addCommas(value[0]) : addCommas(value);\n    var name = data.getName(dataIndex);\n    return encodeHTML(name + ': ' + formattedValue);\n  },\n\n  /**\n   * Add tree path to tooltip param\n   *\n   * @override\n   * @param {number} dataIndex\n   * @return {Object}\n   */\n  getDataParams: function (dataIndex) {\n    var params = SeriesModel.prototype.getDataParams.apply(this, arguments);\n    var node = this.getData().tree.getNodeByDataIndex(dataIndex);\n    params.treePathInfo = wrapTreePathInfo(node, this);\n    return params;\n  },\n\n  /**\n   * @public\n   * @param {Object} layoutInfo {\n   *                                x: containerGroup x\n   *                                y: containerGroup y\n   *                                width: containerGroup width\n   *                                height: containerGroup height\n   *                            }\n   */\n  setLayoutInfo: function (layoutInfo) {\n    /**\n     * @readOnly\n     * @type {Object}\n     */\n    this.layoutInfo = this.layoutInfo || {};\n    zrUtil.extend(this.layoutInfo, layoutInfo);\n  },\n\n  /**\n   * @param  {string} id\n   * @return {number} index\n   */\n  mapIdToIndex: function (id) {\n    // A feature is implemented:\n    // index is monotone increasing with the sequence of\n    // input id at the first time.\n    // This feature can make sure that each data item and its\n    // mapped color have the same index between data list and\n    // color list at the beginning, which is useful for user\n    // to adjust data-color mapping.\n\n    /**\n     * @private\n     * @type {Object}\n     */\n    var idIndexMap = this._idIndexMap;\n\n    if (!idIndexMap) {\n      idIndexMap = this._idIndexMap = zrUtil.createHashMap();\n      /**\n       * @private\n       * @type {number}\n       */\n\n      this._idIndexMapCount = 0;\n    }\n\n    var index = idIndexMap.get(id);\n\n    if (index == null) {\n      idIndexMap.set(id, index = this._idIndexMapCount++);\n    }\n\n    return index;\n  },\n  getViewRoot: function () {\n    return this._viewRoot;\n  },\n\n  /**\n   * @param {module:echarts/data/Tree~Node} [viewRoot]\n   */\n  resetViewRoot: function (viewRoot) {\n    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;\n    var root = this.getData().tree.root;\n\n    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {\n      this._viewRoot = root;\n    }\n  }\n});\n/**\n * @param {Object} dataNode\n */\n\n\nfunction completeTreeValue(dataNode) {\n  // Postorder travel tree.\n  // If value of none-leaf node is not set,\n  // calculate it by suming up the value of all children.\n  var sum = 0;\n  zrUtil.each(dataNode.children, function (child) {\n    completeTreeValue(child);\n    var childValue = child.value;\n    zrUtil.isArray(childValue) && (childValue = childValue[0]);\n    sum += childValue;\n  });\n  var thisValue = dataNode.value;\n\n  if (zrUtil.isArray(thisValue)) {\n    thisValue = thisValue[0];\n  }\n\n  if (thisValue == null || isNaN(thisValue)) {\n    thisValue = sum;\n  } // Value should not less than 0.\n\n\n  if (thisValue < 0) {\n    thisValue = 0;\n  }\n\n  zrUtil.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;\n}\n/**\n * set default to level configuration\n */\n\n\nfunction setDefault(levels, ecModel) {\n  var globalColorList = ecModel.get('color');\n\n  if (!globalColorList) {\n    return;\n  }\n\n  levels = levels || [];\n  var hasColorDefine;\n  zrUtil.each(levels, function (levelDefine) {\n    var model = new Model(levelDefine);\n    var modelColor = model.get('color');\n\n    if (model.get('itemStyle.normal.color') || modelColor && modelColor !== 'none') {\n      hasColorDefine = true;\n    }\n  });\n\n  if (!hasColorDefine) {\n    var level0 = levels[0] || (levels[0] = {});\n    level0.color = globalColorList.slice();\n  }\n\n  return levels;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/chart/treemap/TreemapSeries.js\n// module id = 652\n// module chunks = 44","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\nvar helper = require(\"./helper\");\n\nvar Breadcrumb = require(\"./Breadcrumb\");\n\nvar RoamController = require(\"../../component/helper/RoamController\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar matrix = require(\"zrender/lib/core/matrix\");\n\nvar animationUtil = require(\"../../util/animation\");\n\nvar makeStyleMapper = require(\"../../model/mixin/makeStyleMapper\");\n\nvar bind = zrUtil.bind;\nvar Group = graphic.Group;\nvar Rect = graphic.Rect;\nvar each = zrUtil.each;\nvar DRAG_THRESHOLD = 3;\nvar PATH_LABEL_NOAMAL = ['label', 'normal'];\nvar PATH_LABEL_EMPHASIS = ['label', 'emphasis'];\nvar PATH_UPPERLABEL_NORMAL = ['upperLabel', 'normal'];\nvar PATH_UPPERLABEL_EMPHASIS = ['upperLabel', 'emphasis'];\nvar Z_BASE = 10; // Should bigger than every z.\n\nvar Z_BG = 1;\nvar Z_CONTENT = 2;\nvar getItemStyleEmphasis = makeStyleMapper([['fill', 'color'], // `borderColor` and `borderWidth` has been occupied,\n// so use `stroke` to indicate the stroke of the rect.\n['stroke', 'strokeColor'], ['lineWidth', 'strokeWidth'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\n\nvar getItemStyleNormal = function (model) {\n  // Normal style props should include emphasis style props.\n  var itemStyle = getItemStyleEmphasis(model); // Clear styles set by emphasis.\n\n  itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;\n  return itemStyle;\n};\n\nvar _default = echarts.extendChartView({\n  type: 'treemap',\n\n  /**\n   * @override\n   */\n  init: function (o, api) {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this._containerGroup;\n    /**\n     * @private\n     * @type {Object.<string, Array.<module:zrender/container/Group>>}\n     */\n\n    this._storage = createStorage();\n    /**\n     * @private\n     * @type {module:echarts/data/Tree}\n     */\n\n    this._oldTree;\n    /**\n     * @private\n     * @type {module:echarts/chart/treemap/Breadcrumb}\n     */\n\n    this._breadcrumb;\n    /**\n     * @private\n     * @type {module:echarts/component/helper/RoamController}\n     */\n\n    this._controller;\n    /**\n     * 'ready', 'animating'\n     * @private\n     */\n\n    this._state = 'ready';\n  },\n\n  /**\n   * @override\n   */\n  render: function (seriesModel, ecModel, api, payload) {\n    var models = ecModel.findComponents({\n      mainType: 'series',\n      subType: 'treemap',\n      query: payload\n    });\n\n    if (zrUtil.indexOf(models, seriesModel) < 0) {\n      return;\n    }\n\n    this.seriesModel = seriesModel;\n    this.api = api;\n    this.ecModel = ecModel;\n    var targetInfo = helper.retrieveTargetInfo(payload, seriesModel);\n    var payloadType = payload && payload.type;\n    var layoutInfo = seriesModel.layoutInfo;\n    var isInit = !this._oldTree;\n    var thisStorage = this._storage; // Mark new root when action is treemapRootToNode.\n\n    var reRoot = payloadType === 'treemapRootToNode' && targetInfo && thisStorage ? {\n      rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],\n      direction: payload.direction\n    } : null;\n\n    var containerGroup = this._giveContainerGroup(layoutInfo);\n\n    var renderResult = this._doRender(containerGroup, seriesModel, reRoot);\n\n    !isInit && (!payloadType || payloadType === 'treemapZoomToNode' || payloadType === 'treemapRootToNode') ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();\n\n    this._resetController(api);\n\n    this._renderBreadcrumb(seriesModel, api, targetInfo);\n  },\n\n  /**\n   * @private\n   */\n  _giveContainerGroup: function (layoutInfo) {\n    var containerGroup = this._containerGroup;\n\n    if (!containerGroup) {\n      // FIXME\n      // 加一层containerGroup是为了clip，但是现在clip功能并没有实现。\n      containerGroup = this._containerGroup = new Group();\n\n      this._initEvents(containerGroup);\n\n      this.group.add(containerGroup);\n    }\n\n    containerGroup.attr('position', [layoutInfo.x, layoutInfo.y]);\n    return containerGroup;\n  },\n\n  /**\n   * @private\n   */\n  _doRender: function (containerGroup, seriesModel, reRoot) {\n    var thisTree = seriesModel.getData().tree;\n    var oldTree = this._oldTree; // Clear last shape records.\n\n    var lastsForAnimation = createStorage();\n    var thisStorage = createStorage();\n    var oldStorage = this._storage;\n    var willInvisibleEls = [];\n    var doRenderNode = zrUtil.curry(renderNode, seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls); // Notice: when thisTree and oldTree are the same tree (see list.cloneShallow),\n    // the oldTree is actually losted, so we can not find all of the old graphic\n    // elements from tree. So we use this stragegy: make element storage, move\n    // from old storage to new storage, clear old storage.\n\n    dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0); // Process all removing.\n\n    var willDeleteEls = clearStorage(oldStorage);\n    this._oldTree = thisTree;\n    this._storage = thisStorage;\n    return {\n      lastsForAnimation: lastsForAnimation,\n      willDeleteEls: willDeleteEls,\n      renderFinally: renderFinally\n    };\n\n    function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {\n      // When 'render' is triggered by action,\n      // 'this' and 'old' may be the same tree,\n      // we use rawIndex in that case.\n      if (sameTree) {\n        oldViewChildren = thisViewChildren;\n        each(thisViewChildren, function (child, index) {\n          !child.isRemoved() && processNode(index, index);\n        });\n      } // Diff hierarchically (diff only in each subtree, but not whole).\n      // because, consistency of view is important.\n      else {\n          new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove(zrUtil.curry(processNode, null)).execute();\n        }\n\n      function getKey(node) {\n        // Identify by name or raw index.\n        return node.getId();\n      }\n\n      function processNode(newIndex, oldIndex) {\n        var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;\n        var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;\n        var group = doRenderNode(thisNode, oldNode, parentGroup, depth);\n        group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);\n      }\n    }\n\n    function clearStorage(storage) {\n      var willDeleteEls = createStorage();\n      storage && each(storage, function (store, storageName) {\n        var delEls = willDeleteEls[storageName];\n        each(store, function (el) {\n          el && (delEls.push(el), el.__tmWillDelete = 1);\n        });\n      });\n      return willDeleteEls;\n    }\n\n    function renderFinally() {\n      each(willDeleteEls, function (els) {\n        each(els, function (el) {\n          el.parent && el.parent.remove(el);\n        });\n      });\n      each(willInvisibleEls, function (el) {\n        el.invisible = true; // Setting invisible is for optimizing, so no need to set dirty,\n        // just mark as invisible.\n\n        el.dirty();\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _doAnimation: function (containerGroup, renderResult, seriesModel, reRoot) {\n    if (!seriesModel.get('animation')) {\n      return;\n    }\n\n    var duration = seriesModel.get('animationDurationUpdate');\n    var easing = seriesModel.get('animationEasing');\n    var animationWrap = animationUtil.createWrap(); // Make delete animations.\n\n    each(renderResult.willDeleteEls, function (store, storageName) {\n      each(store, function (el, rawIndex) {\n        if (el.invisible) {\n          return;\n        }\n\n        var parent = el.parent; // Always has parent, and parent is nodeGroup.\n\n        var target;\n\n        if (reRoot && reRoot.direction === 'drillDown') {\n          target = parent === reRoot.rootNodeGroup // This is the content element of view root.\n          // Only `content` will enter this branch, because\n          // `background` and `nodeGroup` will not be deleted.\n          ? {\n            shape: {\n              x: 0,\n              y: 0,\n              width: parent.__tmNodeWidth,\n              height: parent.__tmNodeHeight\n            },\n            style: {\n              opacity: 0\n            } // Others.\n\n          } : {\n            style: {\n              opacity: 0\n            }\n          };\n        } else {\n          var targetX = 0;\n          var targetY = 0;\n\n          if (!parent.__tmWillDelete) {\n            // Let node animate to right-bottom corner, cooperating with fadeout,\n            // which is appropriate for user understanding.\n            // Divided by 2 for reRoot rolling up effect.\n            targetX = parent.__tmNodeWidth / 2;\n            targetY = parent.__tmNodeHeight / 2;\n          }\n\n          target = storageName === 'nodeGroup' ? {\n            position: [targetX, targetY],\n            style: {\n              opacity: 0\n            }\n          } : {\n            shape: {\n              x: targetX,\n              y: targetY,\n              width: 0,\n              height: 0\n            },\n            style: {\n              opacity: 0\n            }\n          };\n        }\n\n        target && animationWrap.add(el, target, duration, easing);\n      });\n    }); // Make other animations\n\n    each(this._storage, function (store, storageName) {\n      each(store, function (el, rawIndex) {\n        var last = renderResult.lastsForAnimation[storageName][rawIndex];\n        var target = {};\n\n        if (!last) {\n          return;\n        }\n\n        if (storageName === 'nodeGroup') {\n          if (last.old) {\n            target.position = el.position.slice();\n            el.attr('position', last.old);\n          }\n        } else {\n          if (last.old) {\n            target.shape = zrUtil.extend({}, el.shape);\n            el.setShape(last.old);\n          }\n\n          if (last.fadein) {\n            el.setStyle('opacity', 0);\n            target.style = {\n              opacity: 1\n            };\n          } // When animation is stopped for succedent animation starting,\n          // el.style.opacity might not be 1\n          else if (el.style.opacity !== 1) {\n              target.style = {\n                opacity: 1\n              };\n            }\n        }\n\n        animationWrap.add(el, target, duration, easing);\n      });\n    }, this);\n    this._state = 'animating';\n    animationWrap.done(bind(function () {\n      this._state = 'ready';\n      renderResult.renderFinally();\n    }, this)).start();\n  },\n\n  /**\n   * @private\n   */\n  _resetController: function (api) {\n    var controller = this._controller; // Init controller.\n\n    if (!controller) {\n      controller = this._controller = new RoamController(api.getZr());\n      controller.enable(this.seriesModel.get('roam'));\n      controller.on('pan', bind(this._onPan, this));\n      controller.on('zoom', bind(this._onZoom, this));\n    }\n\n    var rect = new BoundingRect(0, 0, api.getWidth(), api.getHeight());\n    controller.setPointerChecker(function (e, x, y) {\n      return rect.contain(x, y);\n    });\n  },\n\n  /**\n   * @private\n   */\n  _clearController: function () {\n    var controller = this._controller;\n\n    if (controller) {\n      controller.dispose();\n      controller = null;\n    }\n  },\n\n  /**\n   * @private\n   */\n  _onPan: function (dx, dy) {\n    if (this._state !== 'animating' && (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD)) {\n      // These param must not be cached.\n      var root = this.seriesModel.getData().tree.root;\n\n      if (!root) {\n        return;\n      }\n\n      var rootLayout = root.getLayout();\n\n      if (!rootLayout) {\n        return;\n      }\n\n      this.api.dispatchAction({\n        type: 'treemapMove',\n        from: this.uid,\n        seriesId: this.seriesModel.id,\n        rootRect: {\n          x: rootLayout.x + dx,\n          y: rootLayout.y + dy,\n          width: rootLayout.width,\n          height: rootLayout.height\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _onZoom: function (scale, mouseX, mouseY) {\n    if (this._state !== 'animating') {\n      // These param must not be cached.\n      var root = this.seriesModel.getData().tree.root;\n\n      if (!root) {\n        return;\n      }\n\n      var rootLayout = root.getLayout();\n\n      if (!rootLayout) {\n        return;\n      }\n\n      var rect = new BoundingRect(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);\n      var layoutInfo = this.seriesModel.layoutInfo; // Transform mouse coord from global to containerGroup.\n\n      mouseX -= layoutInfo.x;\n      mouseY -= layoutInfo.y; // Scale root bounding rect.\n\n      var m = matrix.create();\n      matrix.translate(m, m, [-mouseX, -mouseY]);\n      matrix.scale(m, m, [scale, scale]);\n      matrix.translate(m, m, [mouseX, mouseY]);\n      rect.applyTransform(m);\n      this.api.dispatchAction({\n        type: 'treemapRender',\n        from: this.uid,\n        seriesId: this.seriesModel.id,\n        rootRect: {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _initEvents: function (containerGroup) {\n    containerGroup.on('click', function (e) {\n      if (this._state !== 'ready') {\n        return;\n      }\n\n      var nodeClick = this.seriesModel.get('nodeClick', true);\n\n      if (!nodeClick) {\n        return;\n      }\n\n      var targetInfo = this.findTarget(e.offsetX, e.offsetY);\n\n      if (!targetInfo) {\n        return;\n      }\n\n      var node = targetInfo.node;\n\n      if (node.getLayout().isLeafRoot) {\n        this._rootToNode(targetInfo);\n      } else {\n        if (nodeClick === 'zoomToNode') {\n          this._zoomToNode(targetInfo);\n        } else if (nodeClick === 'link') {\n          var itemModel = node.hostTree.data.getItemModel(node.dataIndex);\n          var link = itemModel.get('link', true);\n          var linkTarget = itemModel.get('target', true) || 'blank';\n          link && window.open(link, linkTarget);\n        }\n      }\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _renderBreadcrumb: function (seriesModel, api, targetInfo) {\n    if (!targetInfo) {\n      targetInfo = seriesModel.get('leafDepth', true) != null ? {\n        node: seriesModel.getViewRoot() // FIXME\n        // better way?\n        // Find breadcrumb tail on center of containerGroup.\n\n      } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);\n\n      if (!targetInfo) {\n        targetInfo = {\n          node: seriesModel.getData().tree.root\n        };\n      }\n    }\n\n    (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group))).render(seriesModel, api, targetInfo.node, bind(onSelect, this));\n\n    function onSelect(node) {\n      if (this._state !== 'animating') {\n        helper.aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({\n          node: node\n        }) : this._zoomToNode({\n          node: node\n        });\n      }\n    }\n  },\n\n  /**\n   * @override\n   */\n  remove: function () {\n    this._clearController();\n\n    this._containerGroup && this._containerGroup.removeAll();\n    this._storage = createStorage();\n    this._state = 'ready';\n    this._breadcrumb && this._breadcrumb.remove();\n  },\n  dispose: function () {\n    this._clearController();\n  },\n\n  /**\n   * @private\n   */\n  _zoomToNode: function (targetInfo) {\n    this.api.dispatchAction({\n      type: 'treemapZoomToNode',\n      from: this.uid,\n      seriesId: this.seriesModel.id,\n      targetNode: targetInfo.node\n    });\n  },\n\n  /**\n   * @private\n   */\n  _rootToNode: function (targetInfo) {\n    this.api.dispatchAction({\n      type: 'treemapRootToNode',\n      from: this.uid,\n      seriesId: this.seriesModel.id,\n      targetNode: targetInfo.node\n    });\n  },\n\n  /**\n   * @public\n   * @param {number} x Global coord x.\n   * @param {number} y Global coord y.\n   * @return {Object} info If not found, return undefined;\n   * @return {number} info.node Target node.\n   * @return {number} info.offsetX x refer to target node.\n   * @return {number} info.offsetY y refer to target node.\n   */\n  findTarget: function (x, y) {\n    var targetInfo;\n    var viewRoot = this.seriesModel.getViewRoot();\n    viewRoot.eachNode({\n      attr: 'viewChildren',\n      order: 'preorder'\n    }, function (node) {\n      var bgEl = this._storage.background[node.getRawIndex()]; // If invisible, there might be no element.\n\n\n      if (bgEl) {\n        var point = bgEl.transformCoordToLocal(x, y);\n        var shape = bgEl.shape; // For performance consideration, dont use 'getBoundingRect'.\n\n        if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {\n          targetInfo = {\n            node: node,\n            offsetX: point[0],\n            offsetY: point[1]\n          };\n        } else {\n          return false; // Suppress visit subtree.\n        }\n      }\n    }, this);\n    return targetInfo;\n  }\n});\n/**\n * @inner\n */\n\n\nfunction createStorage() {\n  return {\n    nodeGroup: [],\n    background: [],\n    content: []\n  };\n}\n/**\n * @inner\n * @return Return undefined means do not travel further.\n */\n\n\nfunction renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {\n  // Whether under viewRoot.\n  if (!thisNode) {\n    // Deleting nodes will be performed finally. This method just find\n    // element from old storage, or create new element, set them to new\n    // storage, and set styles.\n    return;\n  } // -------------------------------------------------------------------\n  // Start of closure variables available in \"Procedures in renderNode\".\n\n\n  var thisLayout = thisNode.getLayout();\n\n  if (!thisLayout || !thisLayout.isInView) {\n    return;\n  }\n\n  var thisWidth = thisLayout.width;\n  var thisHeight = thisLayout.height;\n  var borderWidth = thisLayout.borderWidth;\n  var thisInvisible = thisLayout.invisible;\n  var thisRawIndex = thisNode.getRawIndex();\n  var oldRawIndex = oldNode && oldNode.getRawIndex();\n  var thisViewChildren = thisNode.viewChildren;\n  var upperHeight = thisLayout.upperHeight;\n  var isParent = thisViewChildren && thisViewChildren.length;\n  var itemStyleNormalModel = thisNode.getModel('itemStyle.normal');\n  var itemStyleEmphasisModel = thisNode.getModel('itemStyle.emphasis'); // End of closure ariables available in \"Procedures in renderNode\".\n  // -----------------------------------------------------------------\n  // Node group\n\n  var group = giveGraphic('nodeGroup', Group);\n\n  if (!group) {\n    return;\n  }\n\n  parentGroup.add(group); // x,y are not set when el is above view root.\n\n  group.attr('position', [thisLayout.x || 0, thisLayout.y || 0]);\n  group.__tmNodeWidth = thisWidth;\n  group.__tmNodeHeight = thisHeight;\n\n  if (thisLayout.isAboveViewRoot) {\n    return group;\n  } // Background\n\n\n  var bg = giveGraphic('background', Rect, depth, Z_BG);\n  bg && renderBackground(group, bg, isParent && thisLayout.upperHeight); // No children, render content.\n\n  if (!isParent) {\n    var content = giveGraphic('content', Rect, depth, Z_CONTENT);\n    content && renderContent(group, content);\n  }\n\n  return group; // ----------------------------\n  // | Procedures in renderNode |\n  // ----------------------------\n\n  function renderBackground(group, bg, useUpperLabel) {\n    // For tooltip.\n    bg.dataIndex = thisNode.dataIndex;\n    bg.seriesIndex = seriesModel.seriesIndex;\n    bg.setShape({\n      x: 0,\n      y: 0,\n      width: thisWidth,\n      height: thisHeight\n    });\n    var visualBorderColor = thisNode.getVisual('borderColor', true);\n    var emphasisBorderColor = itemStyleEmphasisModel.get('borderColor');\n    updateStyle(bg, function () {\n      var normalStyle = getItemStyleNormal(itemStyleNormalModel);\n      normalStyle.fill = visualBorderColor;\n      var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);\n      emphasisStyle.fill = emphasisBorderColor;\n\n      if (useUpperLabel) {\n        var upperLabelWidth = thisWidth - 2 * borderWidth;\n        prepareText(normalStyle, emphasisStyle, visualBorderColor, upperLabelWidth, upperHeight, {\n          x: borderWidth,\n          y: 0,\n          width: upperLabelWidth,\n          height: upperHeight\n        });\n      } // For old bg.\n      else {\n          normalStyle.text = emphasisStyle.text = null;\n        }\n\n      bg.setStyle(normalStyle);\n      graphic.setHoverStyle(bg, emphasisStyle);\n    });\n    group.add(bg);\n  }\n\n  function renderContent(group, content) {\n    // For tooltip.\n    content.dataIndex = thisNode.dataIndex;\n    content.seriesIndex = seriesModel.seriesIndex;\n    var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);\n    var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);\n    content.culling = true;\n    content.setShape({\n      x: borderWidth,\n      y: borderWidth,\n      width: contentWidth,\n      height: contentHeight\n    });\n    var visualColor = thisNode.getVisual('color', true);\n    updateStyle(content, function () {\n      var normalStyle = getItemStyleNormal(itemStyleNormalModel);\n      normalStyle.fill = visualColor;\n      var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);\n      prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight);\n      content.setStyle(normalStyle);\n      graphic.setHoverStyle(content, emphasisStyle);\n    });\n    group.add(content);\n  }\n\n  function updateStyle(element, cb) {\n    if (!thisInvisible) {\n      // If invisible, do not set visual, otherwise the element will\n      // change immediately before animation. We think it is OK to\n      // remain its origin color when moving out of the view window.\n      cb();\n\n      if (!element.__tmWillVisible) {\n        element.invisible = false;\n      }\n    } else {\n      // Delay invisible setting utill animation finished,\n      // avoid element vanish suddenly before animation.\n      !element.invisible && willInvisibleEls.push(element);\n    }\n  }\n\n  function prepareText(normalStyle, emphasisStyle, visualColor, width, height, upperLabelRect) {\n    var nodeModel = thisNode.getModel();\n    var text = zrUtil.retrieve(seriesModel.getFormattedLabel(thisNode.dataIndex, 'normal', null, null, upperLabelRect ? 'upperLabel' : 'label'), nodeModel.get('name'));\n\n    if (!upperLabelRect && thisLayout.isLeafRoot) {\n      var iconChar = seriesModel.get('drillDownIcon', true);\n      text = iconChar ? iconChar + ' ' + text : text;\n    }\n\n    var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);\n    var emphasisLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_EMPHASIS : PATH_LABEL_EMPHASIS);\n    var isShow = normalLabelModel.getShallow('show');\n    graphic.setLabelStyle(normalStyle, emphasisStyle, normalLabelModel, emphasisLabelModel, {\n      defaultText: isShow ? text : null,\n      autoColor: visualColor,\n      isRectText: true\n    });\n    upperLabelRect && (normalStyle.textRect = zrUtil.clone(upperLabelRect));\n    normalStyle.truncate = isShow && normalLabelModel.get('ellipsis') ? {\n      outerWidth: width,\n      outerHeight: height,\n      minChar: 2\n    } : null;\n  }\n\n  function giveGraphic(storageName, Ctor, depth, z) {\n    var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];\n    var lasts = lastsForAnimation[storageName];\n\n    if (element) {\n      // Remove from oldStorage\n      oldStorage[storageName][oldRawIndex] = null;\n      prepareAnimationWhenHasOld(lasts, element, storageName);\n    } // If invisible and no old element, do not create new element (for optimizing).\n    else if (!thisInvisible) {\n        element = new Ctor({\n          z: calculateZ(depth, z)\n        });\n        element.__tmDepth = depth;\n        element.__tmStorageName = storageName;\n        prepareAnimationWhenNoOld(lasts, element, storageName);\n      } // Set to thisStorage\n\n\n    return thisStorage[storageName][thisRawIndex] = element;\n  }\n\n  function prepareAnimationWhenHasOld(lasts, element, storageName) {\n    var lastCfg = lasts[thisRawIndex] = {};\n    lastCfg.old = storageName === 'nodeGroup' ? element.position.slice() : zrUtil.extend({}, element.shape);\n  } // If a element is new, we need to find the animation start point carefully,\n  // otherwise it will looks strange when 'zoomToNode'.\n\n\n  function prepareAnimationWhenNoOld(lasts, element, storageName) {\n    var lastCfg = lasts[thisRawIndex] = {};\n    var parentNode = thisNode.parentNode;\n\n    if (parentNode && (!reRoot || reRoot.direction === 'drillDown')) {\n      var parentOldX = 0;\n      var parentOldY = 0; // New nodes appear from right-bottom corner in 'zoomToNode' animation.\n      // For convenience, get old bounding rect from background.\n\n      var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];\n\n      if (!reRoot && parentOldBg && parentOldBg.old) {\n        parentOldX = parentOldBg.old.width;\n        parentOldY = parentOldBg.old.height;\n      } // When no parent old shape found, its parent is new too,\n      // so we can just use {x:0, y:0}.\n\n\n      lastCfg.old = storageName === 'nodeGroup' ? [0, parentOldY] : {\n        x: parentOldX,\n        y: parentOldY,\n        width: 0,\n        height: 0\n      };\n    } // Fade in, user can be aware that these nodes are new.\n\n\n    lastCfg.fadein = storageName !== 'nodeGroup';\n  }\n} // We can not set all backgroud with the same z, Because the behaviour of\n// drill down and roll up differ background creation sequence from tree\n// hierarchy sequence, which cause that lowser background element overlap\n// upper ones. So we calculate z based on depth.\n// Moreover, we try to shrink down z interval to [0, 1] to avoid that\n// treemap with large z overlaps other components.\n\n\nfunction calculateZ(depth, zInLevel) {\n  var zb = depth * Z_BASE + zInLevel;\n  return (zb - 1) / zb;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/chart/treemap/TreemapView.js\n// module id = 653\n// module chunks = 44","var echarts = require(\"../../echarts\");\n\nvar helper = require(\"./helper\");\n\n/**\n * @file Treemap action\n */\nvar noop = function () {};\n\nvar actionTypes = ['treemapZoomToNode', 'treemapRender', 'treemapMove'];\n\nfor (var i = 0; i < actionTypes.length; i++) {\n  echarts.registerAction({\n    type: actionTypes[i],\n    update: 'updateView'\n  }, noop);\n}\n\necharts.registerAction({\n  type: 'treemapRootToNode',\n  update: 'updateView'\n}, function (payload, ecModel) {\n  ecModel.eachComponent({\n    mainType: 'series',\n    subType: 'treemap',\n    query: payload\n  }, handleRootToNode);\n\n  function handleRootToNode(model, index) {\n    var targetInfo = helper.retrieveTargetInfo(payload, model);\n\n    if (targetInfo) {\n      var originViewRoot = model.getViewRoot();\n\n      if (originViewRoot) {\n        payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';\n      }\n\n      model.resetViewRoot(targetInfo.node);\n    }\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/chart/treemap/treemapAction.js\n// module id = 654\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar MAX_SAFE_INTEGER = _number.MAX_SAFE_INTEGER;\n\nvar layout = require(\"../../util/layout\");\n\nvar helper = require(\"./helper\");\n\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar retrieveValue = zrUtil.retrieve;\nvar each = zrUtil.each;\nvar PATH_BORDER_WIDTH = ['itemStyle', 'normal', 'borderWidth'];\nvar PATH_GAP_WIDTH = ['itemStyle', 'normal', 'gapWidth'];\nvar PATH_UPPER_LABEL_SHOW = ['upperLabel', 'normal', 'show'];\nvar PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'normal', 'height'];\n/**\n * @public\n */\n\nfunction _default(ecModel, api, payload) {\n  // Layout result in each node:\n  // {x, y, width, height, area, borderWidth}\n  var condition = {\n    mainType: 'series',\n    subType: 'treemap',\n    query: payload\n  };\n  ecModel.eachComponent(condition, function (seriesModel) {\n    var ecWidth = api.getWidth();\n    var ecHeight = api.getHeight();\n    var seriesOption = seriesModel.option;\n    var layoutInfo = layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    var size = seriesOption.size || []; // Compatible with ec2.\n\n    var containerWidth = parsePercent(retrieveValue(layoutInfo.width, size[0]), ecWidth);\n    var containerHeight = parsePercent(retrieveValue(layoutInfo.height, size[1]), ecHeight); // Fetch payload info.\n\n    var payloadType = payload && payload.type;\n    var targetInfo = helper.retrieveTargetInfo(payload, seriesModel);\n    var rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null;\n    var viewRoot = seriesModel.getViewRoot();\n    var viewAbovePath = helper.getPathToRoot(viewRoot);\n\n    if (payloadType !== 'treemapMove') {\n      var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];\n      var sort = seriesOption.sort;\n\n      if (sort && sort !== 'asc' && sort !== 'desc') {\n        sort = 'desc';\n      }\n\n      var options = {\n        squareRatio: seriesOption.squareRatio,\n        sort: sort,\n        leafDepth: seriesOption.leafDepth\n      }; // layout should be cleared because using updateView but not update.\n\n      viewRoot.hostTree.clearLayouts(); // TODO\n      // optimize: if out of view clip, do not layout.\n      // But take care that if do not render node out of view clip,\n      // how to calculate start po\n\n      var viewRootLayout = {\n        x: 0,\n        y: 0,\n        width: rootSize[0],\n        height: rootSize[1],\n        area: rootSize[0] * rootSize[1]\n      };\n      viewRoot.setLayout(viewRootLayout);\n      squarify(viewRoot, options, false, 0); // Supplement layout.\n\n      var viewRootLayout = viewRoot.getLayout();\n      each(viewAbovePath, function (node, index) {\n        var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();\n        node.setLayout(zrUtil.extend({\n          dataExtent: [childValue, childValue],\n          borderWidth: 0,\n          upperHeight: 0\n        }, viewRootLayout));\n      });\n    }\n\n    var treeRoot = seriesModel.getData().tree.root;\n    treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);\n    seriesModel.setLayoutInfo(layoutInfo); // FIXME\n    // 现在没有clip功能，暂时取ec高宽。\n\n    prunning(treeRoot, // Transform to base element coordinate system.\n    new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);\n  });\n}\n/**\n * Layout treemap with squarify algorithm.\n * @see https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf\n * @see https://github.com/mbostock/d3/blob/master/src/layout/treemap.js\n *\n * @protected\n * @param {module:echarts/data/Tree~TreeNode} node\n * @param {Object} options\n * @param {string} options.sort 'asc' or 'desc'\n * @param {number} options.squareRatio\n * @param {boolean} hideChildren\n * @param {number} depth\n */\n\n\nfunction squarify(node, options, hideChildren, depth) {\n  var width;\n  var height;\n\n  if (node.isRemoved()) {\n    return;\n  }\n\n  var thisLayout = node.getLayout();\n  width = thisLayout.width;\n  height = thisLayout.height; // Considering border and gap\n\n  var nodeModel = node.getModel();\n  var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);\n  var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;\n  var upperLabelHeight = getUpperLabelHeight(nodeModel);\n  var upperHeight = Math.max(borderWidth, upperLabelHeight);\n  var layoutOffset = borderWidth - halfGapWidth;\n  var layoutOffsetUpper = upperHeight - halfGapWidth;\n  var nodeModel = node.getModel();\n  node.setLayout({\n    borderWidth: borderWidth,\n    upperHeight: upperHeight,\n    upperLabelHeight: upperLabelHeight\n  }, true);\n  width = mathMax(width - 2 * layoutOffset, 0);\n  height = mathMax(height - layoutOffset - layoutOffsetUpper, 0);\n  var totalArea = width * height;\n  var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);\n\n  if (!viewChildren.length) {\n    return;\n  }\n\n  var rect = {\n    x: layoutOffset,\n    y: layoutOffsetUpper,\n    width: width,\n    height: height\n  };\n  var rowFixedLength = mathMin(width, height);\n  var best = Infinity; // the best row score so far\n\n  var row = [];\n  row.area = 0;\n\n  for (var i = 0, len = viewChildren.length; i < len;) {\n    var child = viewChildren[i];\n    row.push(child);\n    row.area += child.getLayout().area;\n    var score = worst(row, rowFixedLength, options.squareRatio); // continue with this orientation\n\n    if (score <= best) {\n      i++;\n      best = score;\n    } // abort, and try a different orientation\n    else {\n        row.area -= row.pop().getLayout().area;\n        position(row, rowFixedLength, rect, halfGapWidth, false);\n        rowFixedLength = mathMin(rect.width, rect.height);\n        row.length = row.area = 0;\n        best = Infinity;\n      }\n  }\n\n  if (row.length) {\n    position(row, rowFixedLength, rect, halfGapWidth, true);\n  }\n\n  if (!hideChildren) {\n    var childrenVisibleMin = nodeModel.get('childrenVisibleMin');\n\n    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {\n      hideChildren = true;\n    }\n  }\n\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    squarify(viewChildren[i], options, hideChildren, depth + 1);\n  }\n}\n/**\n * Set area to each child, and calculate data extent for visual coding.\n */\n\n\nfunction initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {\n  var viewChildren = node.children || [];\n  var orderBy = options.sort;\n  orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);\n  var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth; // leafDepth has higher priority.\n\n  if (hideChildren && !overLeafDepth) {\n    return node.viewChildren = [];\n  } // Sort children, order by desc.\n\n\n  viewChildren = zrUtil.filter(viewChildren, function (child) {\n    return !child.isRemoved();\n  });\n  sort(viewChildren, orderBy);\n  var info = statistic(nodeModel, viewChildren, orderBy);\n\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  }\n\n  info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);\n\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  } // Set area to each child.\n\n\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    var area = viewChildren[i].getValue() / info.sum * totalArea; // Do not use setLayout({...}, true), because it is needed to clear last layout.\n\n    viewChildren[i].setLayout({\n      area: area\n    });\n  }\n\n  if (overLeafDepth) {\n    viewChildren.length && node.setLayout({\n      isLeafRoot: true\n    }, true);\n    viewChildren.length = 0;\n  }\n\n  node.viewChildren = viewChildren;\n  node.setLayout({\n    dataExtent: info.dataExtent\n  }, true);\n  return viewChildren;\n}\n/**\n * Consider 'visibleMin'. Modify viewChildren and get new sum.\n */\n\n\nfunction filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {\n  // visibleMin is not supported yet when no option.sort.\n  if (!orderBy) {\n    return sum;\n  }\n\n  var visibleMin = nodeModel.get('visibleMin');\n  var len = orderedChildren.length;\n  var deletePoint = len; // Always travel from little value to big value.\n\n  for (var i = len - 1; i >= 0; i--) {\n    var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();\n\n    if (value / sum * totalArea < visibleMin) {\n      deletePoint = i;\n      sum -= value;\n    }\n  }\n\n  orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);\n  return sum;\n}\n/**\n * Sort\n */\n\n\nfunction sort(viewChildren, orderBy) {\n  if (orderBy) {\n    viewChildren.sort(function (a, b) {\n      var diff = orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();\n      return diff === 0 ? orderBy === 'asc' ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;\n    });\n  }\n\n  return viewChildren;\n}\n/**\n * Statistic\n */\n\n\nfunction statistic(nodeModel, children, orderBy) {\n  // Calculate sum.\n  var sum = 0;\n\n  for (var i = 0, len = children.length; i < len; i++) {\n    sum += children[i].getValue();\n  } // Statistic data extent for latter visual coding.\n  // Notice: data extent should be calculate based on raw children\n  // but not filtered view children, otherwise visual mapping will not\n  // be stable when zoom (where children is filtered by visibleMin).\n\n\n  var dimension = nodeModel.get('visualDimension');\n  var dataExtent; // The same as area dimension.\n\n  if (!children || !children.length) {\n    dataExtent = [NaN, NaN];\n  } else if (dimension === 'value' && orderBy) {\n    dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];\n    orderBy === 'asc' && dataExtent.reverse();\n  } // Other dimension.\n  else {\n      var dataExtent = [Infinity, -Infinity];\n      each(children, function (child) {\n        var value = child.getValue(dimension);\n        value < dataExtent[0] && (dataExtent[0] = value);\n        value > dataExtent[1] && (dataExtent[1] = value);\n      });\n    }\n\n  return {\n    sum: sum,\n    dataExtent: dataExtent\n  };\n}\n/**\n * Computes the score for the specified row,\n * as the worst aspect ratio.\n */\n\n\nfunction worst(row, rowFixedLength, ratio) {\n  var areaMax = 0;\n  var areaMin = Infinity;\n\n  for (var i = 0, area, len = row.length; i < len; i++) {\n    area = row[i].getLayout().area;\n\n    if (area) {\n      area < areaMin && (areaMin = area);\n      area > areaMax && (areaMax = area);\n    }\n  }\n\n  var squareArea = row.area * row.area;\n  var f = rowFixedLength * rowFixedLength * ratio;\n  return squareArea ? mathMax(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;\n}\n/**\n * Positions the specified row of nodes. Modifies `rect`.\n */\n\n\nfunction position(row, rowFixedLength, rect, halfGapWidth, flush) {\n  // When rowFixedLength === rect.width,\n  // it is horizontal subdivision,\n  // rowFixedLength is the width of the subdivision,\n  // rowOtherLength is the height of the subdivision,\n  // and nodes will be positioned from left to right.\n  // wh[idx0WhenH] means: when horizontal,\n  //      wh[idx0WhenH] => wh[0] => 'width'.\n  //      xy[idx1WhenH] => xy[1] => 'y'.\n  var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;\n  var idx1WhenH = 1 - idx0WhenH;\n  var xy = ['x', 'y'];\n  var wh = ['width', 'height'];\n  var last = rect[xy[idx0WhenH]];\n  var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;\n\n  if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {\n    rowOtherLength = rect[wh[idx1WhenH]]; // over+underflow\n  }\n\n  for (var i = 0, rowLen = row.length; i < rowLen; i++) {\n    var node = row[i];\n    var nodeLayout = {};\n    var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;\n    var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0); // We use Math.max/min to avoid negative width/height when considering gap width.\n\n    var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;\n    var modWH = i === rowLen - 1 || remain < step ? remain : step;\n    var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);\n    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);\n    nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);\n    last += modWH;\n    node.setLayout(nodeLayout, true);\n  }\n\n  rect[xy[idx1WhenH]] += rowOtherLength;\n  rect[wh[idx1WhenH]] -= rowOtherLength;\n} // Return [containerWidth, containerHeight] as defualt.\n\n\nfunction estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {\n  // If targetInfo.node exists, we zoom to the node,\n  // so estimate whold width and heigth by target node.\n  var currNode = (targetInfo || {}).node;\n  var defaultSize = [containerWidth, containerHeight];\n\n  if (!currNode || currNode === viewRoot) {\n    return defaultSize;\n  }\n\n  var parent;\n  var viewArea = containerWidth * containerHeight;\n  var area = viewArea * seriesModel.option.zoomToNodeRatio;\n\n  while (parent = currNode.parentNode) {\n    // jshint ignore:line\n    var sum = 0;\n    var siblings = parent.children;\n\n    for (var i = 0, len = siblings.length; i < len; i++) {\n      sum += siblings[i].getValue();\n    }\n\n    var currNodeValue = currNode.getValue();\n\n    if (currNodeValue === 0) {\n      return defaultSize;\n    }\n\n    area *= sum / currNodeValue; // Considering border, suppose aspect ratio is 1.\n\n    var parentModel = parent.getModel();\n    var borderWidth = parentModel.get(PATH_BORDER_WIDTH);\n    var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel, borderWidth));\n    area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);\n    area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);\n    currNode = parent;\n  }\n\n  area < viewArea && (area = viewArea);\n  var scale = Math.pow(area / viewArea, 0.5);\n  return [containerWidth * scale, containerHeight * scale];\n} // Root postion base on coord of containerGroup\n\n\nfunction calculateRootPosition(layoutInfo, rootRect, targetInfo) {\n  if (rootRect) {\n    return {\n      x: rootRect.x,\n      y: rootRect.y\n    };\n  }\n\n  var defaultPosition = {\n    x: 0,\n    y: 0\n  };\n\n  if (!targetInfo) {\n    return defaultPosition;\n  } // If targetInfo is fetched by 'retrieveTargetInfo',\n  // old tree and new tree are the same tree,\n  // so the node still exists and we can visit it.\n\n\n  var targetNode = targetInfo.node;\n  var layout = targetNode.getLayout();\n\n  if (!layout) {\n    return defaultPosition;\n  } // Transform coord from local to container.\n\n\n  var targetCenter = [layout.width / 2, layout.height / 2];\n  var node = targetNode;\n\n  while (node) {\n    var nodeLayout = node.getLayout();\n    targetCenter[0] += nodeLayout.x;\n    targetCenter[1] += nodeLayout.y;\n    node = node.parentNode;\n  }\n\n  return {\n    x: layoutInfo.width / 2 - targetCenter[0],\n    y: layoutInfo.height / 2 - targetCenter[1]\n  };\n} // Mark nodes visible for prunning when visual coding and rendering.\n// Prunning depends on layout and root position, so we have to do it after layout.\n\n\nfunction prunning(node, clipRect, viewAbovePath, viewRoot, depth) {\n  var nodeLayout = node.getLayout();\n  var nodeInViewAbovePath = viewAbovePath[depth];\n  var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;\n\n  if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {\n    return;\n  }\n\n  node.setLayout({\n    // isInView means: viewRoot sub tree + viewAbovePath\n    isInView: true,\n    // invisible only means: outside view clip so that the node can not\n    // see but still layout for animation preparation but not render.\n    invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),\n    isAboveViewRoot: isAboveViewRoot\n  }, true); // Transform to child coordinate.\n\n  var childClipRect = new BoundingRect(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);\n  each(node.viewChildren || [], function (child) {\n    prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);\n  });\n}\n\nfunction getUpperLabelHeight(model) {\n  return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/chart/treemap/treemapLayout.js\n// module id = 655\n// module chunks = 44","var VisualMapping = require(\"../../visual/VisualMapping\");\n\nvar zrColor = require(\"zrender/lib/tool/color\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar isArray = zrUtil.isArray;\nvar ITEM_STYLE_NORMAL = 'itemStyle.normal';\n\nfunction _default(ecModel, api, payload) {\n  var condition = {\n    mainType: 'series',\n    subType: 'treemap',\n    query: payload\n  };\n  ecModel.eachComponent(condition, function (seriesModel) {\n    var tree = seriesModel.getData().tree;\n    var root = tree.root;\n    var seriesItemStyleModel = seriesModel.getModel(ITEM_STYLE_NORMAL);\n\n    if (root.isRemoved()) {\n      return;\n    }\n\n    var levelItemStyles = zrUtil.map(tree.levelModels, function (levelModel) {\n      return levelModel ? levelModel.get(ITEM_STYLE_NORMAL) : null;\n    });\n    travelTree(root, // Visual should calculate from tree root but not view root.\n    {}, levelItemStyles, seriesItemStyleModel, seriesModel.getViewRoot().getAncestors(), seriesModel);\n  });\n}\n\nfunction travelTree(node, designatedVisual, levelItemStyles, seriesItemStyleModel, viewRootAncestors, seriesModel) {\n  var nodeModel = node.getModel();\n  var nodeLayout = node.getLayout(); // Optimize\n\n  if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {\n    return;\n  }\n\n  var nodeItemStyleModel = node.getModel(ITEM_STYLE_NORMAL);\n  var levelItemStyle = levelItemStyles[node.depth];\n  var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel); // calculate border color\n\n  var borderColor = nodeItemStyleModel.get('borderColor');\n  var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');\n  var thisNodeColor;\n\n  if (borderColorSaturation != null) {\n    // For performance, do not always execute 'calculateColor'.\n    thisNodeColor = calculateColor(visuals, node);\n    borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);\n  }\n\n  node.setVisual('borderColor', borderColor);\n  var viewChildren = node.viewChildren;\n\n  if (!viewChildren || !viewChildren.length) {\n    thisNodeColor = calculateColor(visuals, node); // Apply visual to this node.\n\n    node.setVisual('color', thisNodeColor);\n  } else {\n    var mapping = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren); // Designate visual to children.\n\n    zrUtil.each(viewChildren, function (child, index) {\n      // If higher than viewRoot, only ancestors of viewRoot is needed to visit.\n      if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {\n        var childVisual = mapVisual(nodeModel, visuals, child, index, mapping, seriesModel);\n        travelTree(child, childVisual, levelItemStyles, seriesItemStyleModel, viewRootAncestors, seriesModel);\n      }\n    });\n  }\n}\n\nfunction buildVisuals(nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel) {\n  var visuals = zrUtil.extend({}, designatedVisual);\n  zrUtil.each(['color', 'colorAlpha', 'colorSaturation'], function (visualName) {\n    // Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel\n    var val = nodeItemStyleModel.get(visualName, true); // Ignore parent\n\n    val == null && levelItemStyle && (val = levelItemStyle[visualName]);\n    val == null && (val = designatedVisual[visualName]);\n    val == null && (val = seriesItemStyleModel.get(visualName));\n    val != null && (visuals[visualName] = val);\n  });\n  return visuals;\n}\n\nfunction calculateColor(visuals) {\n  var color = getValueVisualDefine(visuals, 'color');\n\n  if (color) {\n    var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');\n    var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');\n\n    if (colorSaturation) {\n      color = zrColor.modifyHSL(color, null, null, colorSaturation);\n    }\n\n    if (colorAlpha) {\n      color = zrColor.modifyAlpha(color, colorAlpha);\n    }\n\n    return color;\n  }\n}\n\nfunction calculateBorderColor(borderColorSaturation, thisNodeColor) {\n  return thisNodeColor != null ? zrColor.modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;\n}\n\nfunction getValueVisualDefine(visuals, name) {\n  var value = visuals[name];\n\n  if (value != null && value !== 'none') {\n    return value;\n  }\n}\n\nfunction buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {\n  if (!viewChildren || !viewChildren.length) {\n    return;\n  }\n\n  var rangeVisual = getRangeVisual(nodeModel, 'color') || visuals.color != null && visuals.color !== 'none' && (getRangeVisual(nodeModel, 'colorAlpha') || getRangeVisual(nodeModel, 'colorSaturation'));\n\n  if (!rangeVisual) {\n    return;\n  }\n\n  var visualMin = nodeModel.get('visualMin');\n  var visualMax = nodeModel.get('visualMax');\n  var dataExtent = nodeLayout.dataExtent.slice();\n  visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);\n  visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);\n  var colorMappingBy = nodeModel.get('colorMappingBy');\n  var opt = {\n    type: rangeVisual.name,\n    dataExtent: dataExtent,\n    visual: rangeVisual.range\n  };\n\n  if (opt.type === 'color' && (colorMappingBy === 'index' || colorMappingBy === 'id')) {\n    opt.mappingMethod = 'category';\n    opt.loop = true; // categories is ordinal, so do not set opt.categories.\n  } else {\n    opt.mappingMethod = 'linear';\n  }\n\n  var mapping = new VisualMapping(opt);\n  mapping.__drColorMappingBy = colorMappingBy;\n  return mapping;\n} // Notice: If we dont have the attribute 'colorRange', but only use\n// attribute 'color' to represent both concepts of 'colorRange' and 'color',\n// (It means 'colorRange' when 'color' is Array, means 'color' when not array),\n// this problem will be encountered:\n// If a level-1 node dont have children, and its siblings has children,\n// and colorRange is set on level-1, then the node can not be colored.\n// So we separate 'colorRange' and 'color' to different attributes.\n\n\nfunction getRangeVisual(nodeModel, name) {\n  // 'colorRange', 'colorARange', 'colorSRange'.\n  // If not exsits on this node, fetch from levels and series.\n  var range = nodeModel.get(name);\n  return isArray(range) && range.length ? {\n    name: name,\n    range: range\n  } : null;\n}\n\nfunction mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {\n  var childVisuals = zrUtil.extend({}, visuals);\n\n  if (mapping) {\n    var mappingType = mapping.type;\n    var colorMappingBy = mappingType === 'color' && mapping.__drColorMappingBy;\n    var value = colorMappingBy === 'index' ? index : colorMappingBy === 'id' ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get('visualDimension'));\n    childVisuals[mappingType] = mapping.mapValueToVisual(value);\n  }\n\n  return childVisuals;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/chart/treemap/treemapVisual.js\n// module id = 656\n// module chunks = 44","require(\"./dataZoom/typeDefaulter\");\n\nrequire(\"./dataZoom/DataZoomModel\");\n\nrequire(\"./dataZoom/DataZoomView\");\n\nrequire(\"./dataZoom/SliderZoomModel\");\n\nrequire(\"./dataZoom/SliderZoomView\");\n\nrequire(\"./dataZoom/InsideZoomModel\");\n\nrequire(\"./dataZoom/InsideZoomView\");\n\nrequire(\"./dataZoom/dataZoomProcessor\");\n\nrequire(\"./dataZoom/dataZoomAction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom.js\n// module id = 657\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar helper = require(\"./helper\");\n\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [opt.start, opt.end];\n    var valueWindow = [];\n    each(['startValue', 'endValue'], function (prop) {\n      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n    }); // Normalize bound.\n\n    each([0, 1], function (idx) {\n      var boundValue = valueWindow[idx];\n      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n      // for cases that a dataZoom component controls multiple axes with different\n      // unit or extent, and the latter one is suitable for accurate zoom by pixel\n      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n      // but it is awkward that `percentProp` can not be obtained from `valueProp`\n      // accurately (because all of values that are overflow the `dataExtent` will\n      // be calculated to percent '100%'). So we have to use\n      // `dataZoom.getRangePropMode()` to mark which prop is used.\n      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n      // it remains its original value.\n\n      if (rangePropMode[idx] === 'percent') {\n        if (boundPercent == null) {\n          boundPercent = percentExtent[idx];\n        } // Use scale.parse to math round for category or time axis.\n\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));\n      } else {\n        // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    return {\n      valueWindow: asc(valueWindow),\n      percentWindow: asc(percentWindow)\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    } // Culculate data window and data extent, and record them.\n\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, this.getTargetSeriesModels());\n    var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow;\n    setMinMaxSpan(this); // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n\n\n    var otherAxisModel = this.getOtherAxisModel();\n\n    if (dataZoomModel.get('$fromToolbox') && otherAxisModel && otherAxisModel.get('type') === 'category') {\n      filterMode = 'empty';\n    } // Process series data\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesModel.coordDimToDataDim(axisDim);\n\n      if (filterMode === 'weakFilter') {\n        seriesData && seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        seriesData && each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            seriesData.filterSelf(dim, isInWindow);\n          }\n        });\n      }\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n        var seriesExtent = seriesData.getDataExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && (axisModel.get('data') || []).length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  each(['min', 'max'], function (minMax) {\n    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n\n    if (valueSpan != null) {\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n\n      if (valueSpan != null) {\n        var dataExtent = axisProxy._dataExtent;\n        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      }\n    }\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/AxisProxy.js\n// module id = 658\n// module chunks = 44","var DataZoomModel = require(\"./DataZoomModel\");\n\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    disabled: false,\n    // Whether disable this inside zoom.\n    zoomLock: false,\n    // Whether disable zoom but only pan.\n    zoomOnMouseWheel: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    moveOnMouseMove: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    preventDefaultMouseMove: true\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/InsideZoomModel.js\n// module id = 659\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar DataZoomView = require(\"./DataZoomView\");\n\nvar sliderMove = require(\"../helper/sliderMove\");\n\nvar roams = require(\"./roams\");\n\nvar bind = zrUtil.bind;\nvar InsideZoomView = DataZoomView.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @override\n   */\n  init: function (ecModel, api) {\n    /**\n     * 'throttle' is used in this.dispatchAction, so we save range\n     * to avoid missing some 'pan' info.\n     * @private\n     * @type {Array.<number>}\n     */\n    this._range;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    InsideZoomView.superApply(this, 'render', arguments); // Notice: origin this._range should be maintained, and should not be re-fetched\n    // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'\n    // info will be missed because of 'throttle' of this.dispatchAction.\n\n    if (roams.shouldRecordRange(payload, dataZoomModel.id)) {\n      this._range = dataZoomModel.getPercentRange();\n    } // Reset controllers.\n\n\n    zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {\n      var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {\n        return roams.generateCoordId(coordInfo.model);\n      });\n      zrUtil.each(coordInfoList, function (coordInfo) {\n        var coordModel = coordInfo.model;\n        var dataZoomOption = dataZoomModel.option;\n        roams.register(api, {\n          coordId: roams.generateCoordId(coordModel),\n          allCoordIds: allCoordIds,\n          containsPoint: function (e, x, y) {\n            return coordModel.coordinateSystem.containPoint([x, y]);\n          },\n          dataZoomId: dataZoomModel.id,\n          throttleRate: dataZoomModel.get('throttle', true),\n          panGetRange: bind(this._onPan, this, coordInfo, coordSysName),\n          zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName),\n          zoomLock: dataZoomOption.zoomLock,\n          disabled: dataZoomOption.disabled,\n          roamControllerOpt: {\n            zoomOnMouseWheel: dataZoomOption.zoomOnMouseWheel,\n            moveOnMouseMove: dataZoomOption.moveOnMouseMove,\n            preventDefaultMouseMove: dataZoomOption.preventDefaultMouseMove\n          }\n        });\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    roams.unregister(this.api, this.dataZoomModel.id);\n    InsideZoomView.superApply(this, 'dispose', arguments);\n    this._range = null;\n  },\n\n  /**\n   * @private\n   */\n  _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName]([oldX, oldY], [newX, newY], axisModel, controller, coordInfo);\n    var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;\n    sliderMove(percentDelta, range, [0, 100], 'all');\n    return this._range = range;\n  },\n\n  /**\n   * @private\n   */\n  _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName](null, [mouseX, mouseY], axisModel, controller, coordInfo);\n    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n    scale = Math.max(1 / scale, 0);\n    range[0] = (range[0] - percentPoint) * scale + percentPoint;\n    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.\n\n    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);\n    return this._range = range;\n  }\n});\nvar getDirectionInfo = {\n  grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.dim === 'x') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // axis.dim === 'y'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var polar = coordInfo.model.coordinateSystem;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var angleExtent = polar.getAngleAxis().getExtent();\n    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n    newPoint = polar.pointToCoord(newPoint);\n\n    if (axisModel.mainType === 'radiusAxis') {\n      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n\n      ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n      ret.pixelStart = radiusExtent[0];\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'angleAxis'\n      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n\n      ret.pixelLength = angleExtent[1] - angleExtent[0];\n      ret.pixelStart = angleExtent[0];\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    var ret = {};\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.orient === 'horizontal') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'vertical'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  }\n};\nvar _default = InsideZoomView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/InsideZoomView.js\n// module id = 660\n// module chunks = 44","var DataZoomModel = require(\"./DataZoomModel\");\n\nvar SliderZoomModel = DataZoomModel.extend({\n  type: 'dataZoom.slider',\n  layoutMode: 'box',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    show: true,\n    // ph => placeholder. Using placehoder here because\n    // deault value can only be drived in view stage.\n    right: 'ph',\n    // Default align to grid rect.\n    top: 'ph',\n    // Default align to grid rect.\n    width: 'ph',\n    // Default align to grid rect.\n    height: 'ph',\n    // Default align to grid rect.\n    left: null,\n    // Default align to grid rect.\n    bottom: null,\n    // Default align to grid rect.\n    backgroundColor: 'rgba(47,69,84,0)',\n    // Background of slider zoom component.\n    // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,\n    // highest priority, remain for compatibility of\n    // previous version, but not recommended any more.\n    dataBackground: {\n      lineStyle: {\n        color: '#2f4554',\n        width: 0.5,\n        opacity: 0.3\n      },\n      areaStyle: {\n        color: 'rgba(47,69,84,0.3)',\n        opacity: 0.3\n      }\n    },\n    borderColor: '#ddd',\n    // border color of the box. For compatibility,\n    // if dataBackgroundColor is set, borderColor\n    // is ignored.\n    fillerColor: 'rgba(167,183,204,0.4)',\n    // Color of selected area.\n    // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.\n    // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',\n    handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',\n    // Percent of the slider height\n    handleSize: '100%',\n    handleStyle: {\n      color: '#a7b7cc'\n    },\n    labelPrecision: null,\n    labelFormatter: null,\n    showDetail: true,\n    showDataShadow: 'auto',\n    // Default auto decision.\n    realtime: true,\n    zoomLock: false,\n    // Whether disable zoom.\n    textStyle: {\n      color: '#333'\n    }\n  }\n});\nvar _default = SliderZoomModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/SliderZoomModel.js\n// module id = 661\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar throttle = require(\"../../util/throttle\");\n\nvar DataZoomView = require(\"./DataZoomView\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar layout = require(\"../../util/layout\");\n\nvar sliderMove = require(\"../helper/sliderMove\");\n\nvar Rect = graphic.Rect;\nvar linearMap = numberUtil.linearMap;\nvar asc = numberUtil.asc;\nvar bind = zrUtil.bind;\nvar each = zrUtil.each; // Constants\n\nvar DEFAULT_LOCATION_EDGE_GAP = 7;\nvar DEFAULT_FRAME_BORDER_WIDTH = 1;\nvar DEFAULT_FILLER_SIZE = 30;\nvar HORIZONTAL = 'horizontal';\nvar VERTICAL = 'vertical';\nvar LABEL_GAP = 5;\nvar SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\nvar SliderZoomView = DataZoomView.extend({\n  type: 'dataZoom.slider',\n  init: function (ecModel, api) {\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._displayables = {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this._orient;\n    /**\n     * [0, 100]\n     * @private\n     */\n\n    this._range;\n    /**\n     * [coord of the first handle, coord of the second handle]\n     * @private\n     */\n\n    this._handleEnds;\n    /**\n     * [length, thick]\n     * @private\n     * @type {Array.<number>}\n     */\n\n    this._size;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleWidth;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleHeight;\n    /**\n     * @private\n     */\n\n    this._location;\n    /**\n     * @private\n     */\n\n    this._dragging;\n    /**\n     * @private\n     */\n\n    this._dataShadowInfo;\n    this.api = api;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    SliderZoomView.superApply(this, 'render', arguments);\n    throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');\n    this._orient = dataZoomModel.get('orient');\n\n    if (this.dataZoomModel.get('show') === false) {\n      this.group.removeAll();\n      return;\n    } // Notice: this._resetInterval() should not be executed when payload.type\n    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n\n\n    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n      this._buildView();\n    }\n\n    this._updateView();\n  },\n\n  /**\n   * @override\n   */\n  remove: function () {\n    SliderZoomView.superApply(this, 'remove', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    SliderZoomView.superApply(this, 'dispose', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n  _buildView: function () {\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n\n    this._resetLocation();\n\n    this._resetInterval();\n\n    var barGroup = this._displayables.barGroup = new graphic.Group();\n\n    this._renderBackground();\n\n    this._renderHandle();\n\n    this._renderDataShadow();\n\n    thisGroup.add(barGroup);\n\n    this._positionGroup();\n  },\n\n  /**\n   * @private\n   */\n  _resetLocation: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var api = this.api; // If some of x/y/width/height are not specified,\n    // auto-adapt according to target grid.\n\n    var coordRect = this._findCoordRect();\n\n    var ecSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    }; // Default align by coordinate system rect.\n\n    var positionInfo = this._orient === HORIZONTAL ? {\n      // Why using 'right', because right should be used in vertical,\n      // and it is better to be consistent for dealing with position param merge.\n      right: ecSize.width - coordRect.x - coordRect.width,\n      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,\n      width: coordRect.width,\n      height: DEFAULT_FILLER_SIZE\n    } : {\n      // vertical\n      right: DEFAULT_LOCATION_EDGE_GAP,\n      top: coordRect.y,\n      width: DEFAULT_FILLER_SIZE,\n      height: coordRect.height\n    }; // Do not write back to option and replace value 'ph', because\n    // the 'ph' value should be recalculated when resize.\n\n    var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.\n\n    zrUtil.each(['right', 'top', 'width', 'height'], function (name) {\n      if (layoutParams[name] === 'ph') {\n        layoutParams[name] = positionInfo[name];\n      }\n    });\n    var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);\n    this._location = {\n      x: layoutRect.x,\n      y: layoutRect.y\n    };\n    this._size = [layoutRect.width, layoutRect.height];\n    this._orient === VERTICAL && this._size.reverse();\n  },\n\n  /**\n   * @private\n   */\n  _positionGroup: function () {\n    var thisGroup = this.group;\n    var location = this._location;\n    var orient = this._orient; // Just use the first axis to determine mapping.\n\n    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n    var inverse = targetAxisModel && targetAxisModel.get('inverse');\n    var barGroup = this._displayables.barGroup;\n    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.\n\n    barGroup.attr(orient === HORIZONTAL && !inverse ? {\n      scale: otherAxisInverse ? [1, 1] : [1, -1]\n    } : orient === HORIZONTAL && inverse ? {\n      scale: otherAxisInverse ? [-1, 1] : [-1, -1]\n    } : orient === VERTICAL && !inverse ? {\n      scale: otherAxisInverse ? [1, -1] : [1, 1],\n      rotation: Math.PI / 2 // Dont use Math.PI, considering shadow direction.\n\n    } : {\n      scale: otherAxisInverse ? [-1, -1] : [-1, 1],\n      rotation: Math.PI / 2\n    }); // Position barGroup\n\n    var rect = thisGroup.getBoundingRect([barGroup]);\n    thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);\n  },\n\n  /**\n   * @private\n   */\n  _getViewExtent: function () {\n    return [0, this._size[0]];\n  },\n  _renderBackground: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var size = this._size;\n    var barGroup = this._displayables.barGroup;\n    barGroup.add(new Rect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: dataZoomModel.get('backgroundColor')\n      },\n      z2: -40\n    })); // Click panel, over shadow, below handles.\n\n    barGroup.add(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: 'transparent'\n      },\n      z2: 0,\n      onclick: zrUtil.bind(this._onClickPanelClick, this)\n    }));\n  },\n  _renderDataShadow: function () {\n    var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n    if (!info) {\n      return;\n    }\n\n    var size = this._size;\n    var seriesModel = info.series;\n    var data = seriesModel.getRawData();\n    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick\n    : info.otherDim;\n\n    if (otherDim == null) {\n      return;\n    }\n\n    var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.\n\n    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];\n    var otherShadowExtent = [0, size[1]];\n    var thisShadowExtent = [0, size[0]];\n    var areaPoints = [[size[0], 0], [0, 0]];\n    var linePoints = [];\n    var step = thisShadowExtent[1] / (data.count() - 1);\n    var thisCoord = 0; // Optimize for large data shadow\n\n    var stride = Math.round(data.count() / size[0]);\n    var lastIsEmpty;\n    data.each([otherDim], function (value, index) {\n      if (stride > 0 && index % stride) {\n        thisCoord += step;\n        return;\n      } // FIXME\n      // Should consider axis.min/axis.max when drawing dataShadow.\n      // FIXME\n      // 应该使用统一的空判断？还是在list里进行空判断？\n\n\n      var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.\n\n      var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.\n\n      if (isEmpty && !lastIsEmpty && index) {\n        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n        linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n      } else if (!isEmpty && lastIsEmpty) {\n        areaPoints.push([thisCoord, 0]);\n        linePoints.push([thisCoord, 0]);\n      }\n\n      areaPoints.push([thisCoord, otherCoord]);\n      linePoints.push([thisCoord, otherCoord]);\n      thisCoord += step;\n      lastIsEmpty = isEmpty;\n    });\n    var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n\n    this._displayables.barGroup.add(new graphic.Polygon({\n      shape: {\n        points: areaPoints\n      },\n      style: zrUtil.defaults({\n        fill: dataZoomModel.get('dataBackgroundColor')\n      }, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),\n      silent: true,\n      z2: -20\n    }));\n\n    this._displayables.barGroup.add(new graphic.Polyline({\n      shape: {\n        points: linePoints\n      },\n      style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),\n      silent: true,\n      z2: -19\n    }));\n  },\n  _prepareDataShadowInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var showDataShadow = dataZoomModel.get('showDataShadow');\n\n    if (showDataShadow === false) {\n      return;\n    } // Find a representative series.\n\n\n    var result;\n    var ecModel = this.ecModel;\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();\n      zrUtil.each(seriesModels, function (seriesModel) {\n        if (result) {\n          return;\n        }\n\n        if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {\n          return;\n        }\n\n        var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;\n        var otherDim = getOtherDim(dimNames.name);\n        var otherAxisInverse;\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (otherDim != null && coordSys.getOtherAxis) {\n          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n        }\n\n        result = {\n          thisAxis: thisAxis,\n          series: seriesModel,\n          thisDim: dimNames.name,\n          otherDim: otherDim,\n          otherAxisInverse: otherAxisInverse\n        };\n      }, this);\n    }, this);\n    return result;\n  },\n  _renderHandle: function () {\n    var displaybles = this._displayables;\n    var handles = displaybles.handles = [];\n    var handleLabels = displaybles.handleLabels = [];\n    var barGroup = this._displayables.barGroup;\n    var size = this._size;\n    var dataZoomModel = this.dataZoomModel;\n    barGroup.add(displaybles.filler = new Rect({\n      draggable: true,\n      cursor: getCursor(this._orient),\n      drift: bind(this._onDragMove, this, 'all'),\n      onmousemove: function (e) {\n        // Fot mobile devicem, prevent screen slider on the button.\n        eventTool.stop(e.event);\n      },\n      ondragstart: bind(this._showDataInfo, this, true),\n      ondragend: bind(this._onDragEnd, this),\n      onmouseover: bind(this._showDataInfo, this, true),\n      onmouseout: bind(this._showDataInfo, this, false),\n      style: {\n        fill: dataZoomModel.get('fillerColor'),\n        textPosition: 'inside'\n      }\n    })); // Frame border.\n\n    barGroup.add(new Rect(graphic.subPixelOptimizeRect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),\n        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n        fill: 'rgba(0,0,0,0)'\n      }\n    })));\n    each([0, 1], function (handleIndex) {\n      var path = graphic.createIcon(dataZoomModel.get('handleIcon'), {\n        cursor: getCursor(this._orient),\n        draggable: true,\n        drift: bind(this._onDragMove, this, handleIndex),\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        ondragend: bind(this._onDragEnd, this),\n        onmouseover: bind(this._showDataInfo, this, true),\n        onmouseout: bind(this._showDataInfo, this, false)\n      }, {\n        x: -1,\n        y: 0,\n        width: 2,\n        height: 2\n      });\n      var bRect = path.getBoundingRect();\n      this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);\n      this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n      var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version\n\n      if (handleColor != null) {\n        path.style.fill = handleColor;\n      }\n\n      barGroup.add(handles[handleIndex] = path);\n      var textStyleModel = dataZoomModel.textStyleModel;\n      this.group.add(handleLabels[handleIndex] = new graphic.Text({\n        silent: true,\n        invisible: true,\n        style: {\n          x: 0,\n          y: 0,\n          text: '',\n          textVerticalAlign: 'middle',\n          textAlign: 'center',\n          textFill: textStyleModel.getTextColor(),\n          textFont: textStyleModel.getFont()\n        },\n        z2: 10\n      }));\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetInterval: function () {\n    var range = this._range = this.dataZoomModel.getPercentRange();\n\n    var viewExtent = this._getViewExtent();\n\n    this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];\n  },\n\n  /**\n   * @private\n   * @param {(number|string)} handleIndex 0 or 1 or 'all'\n   * @param {number} delta\n   */\n  _updateInterval: function (handleIndex, delta) {\n    var dataZoomModel = this.dataZoomModel;\n    var handleEnds = this._handleEnds;\n\n    var viewExtend = this._getViewExtent();\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    var percentExtent = [0, 100];\n    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);\n    this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);\n  },\n\n  /**\n   * @private\n   */\n  _updateView: function (nonRealtime) {\n    var displaybles = this._displayables;\n    var handleEnds = this._handleEnds;\n    var handleInterval = asc(handleEnds.slice());\n    var size = this._size;\n    each([0, 1], function (handleIndex) {\n      // Handles\n      var handle = displaybles.handles[handleIndex];\n      var handleHeight = this._handleHeight;\n      handle.attr({\n        scale: [handleHeight / 2, handleHeight / 2],\n        position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]\n      });\n    }, this); // Filler\n\n    displaybles.filler.setShape({\n      x: handleInterval[0],\n      y: 0,\n      width: handleInterval[1] - handleInterval[0],\n      height: size[1]\n    });\n\n    this._updateDataInfo(nonRealtime);\n  },\n\n  /**\n   * @private\n   */\n  _updateDataInfo: function (nonRealtime) {\n    var dataZoomModel = this.dataZoomModel;\n    var displaybles = this._displayables;\n    var handleLabels = displaybles.handleLabels;\n    var orient = this._orient;\n    var labelTexts = ['', '']; // FIXME\n    // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）\n\n    if (dataZoomModel.get('showDetail')) {\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        var axis = axisProxy.getAxisModel().axis;\n        var range = this._range;\n        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.\n        ? axisProxy.calculateDataWindow({\n          start: range[0],\n          end: range[1]\n        }).valueWindow : axisProxy.getDataValueWindow();\n        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];\n      }\n    }\n\n    var orderedHandleEnds = asc(this._handleEnds.slice());\n    setLabel.call(this, 0);\n    setLabel.call(this, 1);\n\n    function setLabel(handleIndex) {\n      // Label\n      // Text should not transform by barGroup.\n      // Ignore handlers transform\n      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);\n      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);\n      var offset = this._handleWidth / 2 + LABEL_GAP;\n      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);\n      handleLabels[handleIndex].setStyle({\n        x: textPoint[0],\n        y: textPoint[1],\n        textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n        textAlign: orient === HORIZONTAL ? direction : 'center',\n        text: labelTexts[handleIndex]\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _formatLabel: function (value, axis) {\n    var dataZoomModel = this.dataZoomModel;\n    var labelFormatter = dataZoomModel.get('labelFormatter');\n    var labelPrecision = dataZoomModel.get('labelPrecision');\n\n    if (labelPrecision == null || labelPrecision === 'auto') {\n      labelPrecision = axis.getPixelPrecision();\n    }\n\n    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code\n    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20.\n    : value.toFixed(Math.min(labelPrecision, 20));\n    return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;\n  },\n\n  /**\n   * @private\n   * @param {boolean} showOrHide true: show, false: hide\n   */\n  _showDataInfo: function (showOrHide) {\n    // Always show when drgging.\n    showOrHide = this._dragging || showOrHide;\n    var handleLabels = this._displayables.handleLabels;\n    handleLabels[0].attr('invisible', !showOrHide);\n    handleLabels[1].attr('invisible', !showOrHide);\n  },\n  _onDragMove: function (handleIndex, dx, dy) {\n    this._dragging = true; // Transform dx, dy to bar coordination.\n\n    var barTransform = this._displayables.barGroup.getLocalTransform();\n\n    var vertex = graphic.applyTransform([dx, dy], barTransform, true);\n\n    this._updateInterval(handleIndex, vertex[0]);\n\n    var realtime = this.dataZoomModel.get('realtime');\n\n    this._updateView(!realtime);\n\n    if (realtime) {\n      realtime && this._dispatchZoomAction();\n    }\n  },\n  _onDragEnd: function () {\n    this._dragging = false;\n\n    this._showDataInfo(false);\n\n    this._dispatchZoomAction();\n  },\n  _onClickPanelClick: function (e) {\n    var size = this._size;\n\n    var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);\n\n    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {\n      return;\n    }\n\n    var handleEnds = this._handleEnds;\n    var center = (handleEnds[0] + handleEnds[1]) / 2;\n\n    this._updateInterval('all', localPoint[0] - center);\n\n    this._updateView();\n\n    this._dispatchZoomAction();\n  },\n\n  /**\n   * This action will be throttled.\n   * @private\n   */\n  _dispatchZoomAction: function () {\n    var range = this._range;\n    this.api.dispatchAction({\n      type: 'dataZoom',\n      from: this.uid,\n      dataZoomId: this.dataZoomModel.id,\n      start: range[0],\n      end: range[1]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _findCoordRect: function () {\n    // Find the grid coresponding to the first axis referred by dataZoom.\n    var rect;\n    each(this.getTargetCoordInfo(), function (coordInfoList) {\n      if (!rect && coordInfoList.length) {\n        var coordSys = coordInfoList[0].model.coordinateSystem;\n        rect = coordSys.getRect && coordSys.getRect();\n      }\n    });\n\n    if (!rect) {\n      var width = this.api.getWidth();\n      var height = this.api.getHeight();\n      rect = {\n        x: width * 0.2,\n        y: height * 0.2,\n        width: width * 0.6,\n        height: height * 0.6\n      };\n    }\n\n    return rect;\n  }\n});\n\nfunction getOtherDim(thisDim) {\n  // FIXME\n  // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好\n  var map = {\n    x: 'y',\n    y: 'x',\n    radius: 'angle',\n    angle: 'radius'\n  };\n  return map[thisDim];\n}\n\nfunction getCursor(orient) {\n  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n\nvar _default = SliderZoomView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/SliderZoomView.js\n// module id = 662\n// module chunks = 44","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar helper = require(\"./helper\");\n\necharts.registerAction('dataZoom', function (payload, ecModel) {\n  var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {\n    return model.get(dimNames.axisIndex);\n  });\n  var effectedModels = [];\n  ecModel.eachComponent({\n    mainType: 'dataZoom',\n    query: payload\n  }, function (model, index) {\n    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);\n  });\n  zrUtil.each(effectedModels, function (dataZoomModel, index) {\n    dataZoomModel.setRawRange({\n      start: payload.start,\n      end: payload.end,\n      startValue: payload.startValue,\n      endValue: payload.endValue\n    });\n  });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/dataZoomAction.js\n// module id = 663\n// module chunks = 44","var echarts = require(\"../../echarts\");\n\necharts.registerProcessor(function (ecModel, api) {\n  ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n    // We calculate window and reset axis here but not in model\n    // init stage and not after action dispatch handler, because\n    // reset should be called after seriesData.restoreData.\n    dataZoomModel.eachTargetAxis(resetSingleAxis); // Caution: data zoom filtering is order sensitive when using\n    // percent range and no min/max/scale set on axis.\n    // For example, we have dataZoom definition:\n    // [\n    //      {xAxisIndex: 0, start: 30, end: 70},\n    //      {yAxisIndex: 0, start: 20, end: 80}\n    // ]\n    // In this case, [20, 80] of y-dataZoom should be based on data\n    // that have filtered by x-dataZoom using range of [30, 70],\n    // but should not be based on full raw data. Thus sliding\n    // x-dataZoom will change both ranges of xAxis and yAxis,\n    // while sliding y-dataZoom will only change the range of yAxis.\n    // So we should filter x-axis after reset x-axis immediately,\n    // and then reset y-axis and filter y-axis.\n\n    dataZoomModel.eachTargetAxis(filterSingleAxis);\n  });\n  ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n    // Fullfill all of the range props so that user\n    // is able to get them from chart.getOption().\n    var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n    var percentRange = axisProxy.getDataPercentWindow();\n    var valueRange = axisProxy.getDataValueWindow();\n    dataZoomModel.setRawRange({\n      start: percentRange[0],\n      end: percentRange[1],\n      startValue: valueRange[0],\n      endValue: valueRange[1]\n    }, true);\n  });\n});\n\nfunction resetSingleAxis(dimNames, axisIndex, dataZoomModel) {\n  dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);\n}\n\nfunction filterSingleAxis(dimNames, axisIndex, dataZoomModel) {\n  dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/dataZoomProcessor.js\n// module id = 664\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar RoamController = require(\"../../component/helper/RoamController\");\n\nvar throttleUtil = require(\"../../util/throttle\");\n\n// Only create one roam controller for each coordinate system.\n// one roam controller might be refered by two inside data zoom\n// components (for example, one for x and one for y). When user\n// pan or zoom, only dispatch one action for those data zoom\n// components.\nvar curry = zrUtil.curry;\nvar ATTR = '\\0_ec_dataZoom_roams';\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} dataZoomInfo\n * @param {string} dataZoomInfo.coordId\n * @param {Function} dataZoomInfo.containsPoint\n * @param {Array.<string>} dataZoomInfo.allCoordIds\n * @param {string} dataZoomInfo.dataZoomId\n * @param {number} dataZoomInfo.throttleRate\n * @param {Function} dataZoomInfo.panGetRange\n * @param {Function} dataZoomInfo.zoomGetRange\n * @param {boolean} [dataZoomInfo.zoomLock]\n * @param {boolean} [dataZoomInfo.disabled]\n */\n\nfunction register(api, dataZoomInfo) {\n  var store = giveStore(api);\n  var theDataZoomId = dataZoomInfo.dataZoomId;\n  var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system.\n  // Avoid memory leak, dispose all not-used-registered.\n\n  zrUtil.each(store, function (record, coordId) {\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {\n      delete dataZoomInfos[theDataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n  var record = store[theCoordId]; // Create if needed.\n\n  if (!record) {\n    record = store[theCoordId] = {\n      coordId: theCoordId,\n      dataZoomInfos: {},\n      count: 0\n    };\n    record.controller = createController(api, record);\n    record.dispatchAction = zrUtil.curry(dispatchAction, api);\n  } // Update reference of dataZoom.\n\n\n  !record.dataZoomInfos[theDataZoomId] && record.count++;\n  record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n  var controllerParams = mergeControllerParams(record.dataZoomInfos);\n  record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated.\n\n  record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle.\n\n  throttleUtil.createOrUpdate(record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate');\n}\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {string} dataZoomId\n */\n\n\nfunction unregister(api, dataZoomId) {\n  var store = giveStore(api);\n  zrUtil.each(store, function (record) {\n    record.controller.dispose();\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[dataZoomId]) {\n      delete dataZoomInfos[dataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n}\n/**\n * @public\n */\n\n\nfunction shouldRecordRange(payload, dataZoomId) {\n  if (payload && payload.type === 'dataZoom' && payload.batch) {\n    for (var i = 0, len = payload.batch.length; i < len; i++) {\n      if (payload.batch[i].dataZoomId === dataZoomId) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * @public\n */\n\n\nfunction generateCoordId(coordModel) {\n  return coordModel.type + '\\0_' + coordModel.id;\n}\n/**\n * Key: coordId, value: {dataZoomInfos: [], count, controller}\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(api) {\n  // Mount store on zrender instance, so that we do not\n  // need to worry about dispose.\n  var zr = api.getZr();\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n\nfunction createController(api, newRecord) {\n  var controller = new RoamController(api.getZr());\n  controller.on('pan', curry(onPan, newRecord));\n  controller.on('zoom', curry(onZoom, newRecord));\n  return controller;\n}\n\nfunction cleanStore(store) {\n  zrUtil.each(store, function (record, coordId) {\n    if (!record.count) {\n      record.controller.dispose();\n      delete store[coordId];\n    }\n  });\n}\n\nfunction onPan(record, dx, dy, oldX, oldY, newX, newY) {\n  wrapAndDispatch(record, function (info) {\n    return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);\n  });\n}\n\nfunction onZoom(record, scale, mouseX, mouseY) {\n  wrapAndDispatch(record, function (info) {\n    return info.zoomGetRange(record.controller, scale, mouseX, mouseY);\n  });\n}\n\nfunction wrapAndDispatch(record, getRange) {\n  var batch = [];\n  zrUtil.each(record.dataZoomInfos, function (info) {\n    var range = getRange(info);\n    !info.disabled && range && batch.push({\n      dataZoomId: info.dataZoomId,\n      start: range[0],\n      end: range[1]\n    });\n  });\n  record.dispatchAction(batch);\n}\n/**\n * This action will be throttled.\n */\n\n\nfunction dispatchAction(api, batch) {\n  api.dispatchAction({\n    type: 'dataZoom',\n    batch: batch\n  });\n}\n/**\n * Merge roamController settings when multiple dataZooms share one roamController.\n */\n\n\nfunction mergeControllerParams(dataZoomInfos) {\n  var controlType;\n  var opt = {};\n  var typePriority = {\n    'true': 2,\n    'move': 1,\n    'false': 0,\n    'undefined': -1\n  };\n  zrUtil.each(dataZoomInfos, function (dataZoomInfo) {\n    var oneType = dataZoomInfo.disabled ? false : dataZoomInfo.zoomLock ? 'move' : true;\n    typePriority[oneType] > typePriority[controlType] && (controlType = oneType); // Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys.\n\n    zrUtil.extend(opt, dataZoomInfo.roamControllerOpt);\n  });\n  return {\n    controlType: controlType,\n    opt: opt\n  };\n}\n\nexports.register = register;\nexports.unregister = unregister;\nexports.shouldRecordRange = shouldRecordRange;\nexports.generateCoordId = generateCoordId;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/roams.js\n// module id = 665\n// module chunks = 44","var Component = require(\"../../model/Component\");\n\nComponent.registerSubTypeDefaulter('dataZoom', function () {\n  // Default 'slider' when no type specified.\n  return 'slider';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/dataZoom/typeDefaulter.js\n// module id = 666\n// module chunks = 44","var echarts = require(\"../echarts\");\n\nrequire(\"./marker/MarkLineModel\");\n\nrequire(\"./marker/MarkLineView\");\n\necharts.registerPreprocessor(function (opt) {\n  // Make sure markLine component is enabled\n  opt.markLine = opt.markLine || {};\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/markLine.js\n// module id = 667\n// module chunks = 44","var MarkerModel = require(\"./MarkerModel\");\n\nvar _default = MarkerModel.extend({\n  type: 'markLine',\n  defaultOption: {\n    zlevel: 0,\n    z: 5,\n    symbol: ['circle', 'arrow'],\n    symbolSize: [8, 16],\n    //symbolRotate: 0,\n    precision: 2,\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      normal: {\n        show: true,\n        position: 'end'\n      },\n      emphasis: {\n        show: true\n      }\n    },\n    lineStyle: {\n      normal: {\n        type: 'dashed'\n      },\n      emphasis: {\n        width: 3\n      }\n    },\n    animationEasing: 'linear'\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/marker/MarkLineModel.js\n// module id = 668\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar List = require(\"../../data/List\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar markerHelper = require(\"./markerHelper\");\n\nvar LineDraw = require(\"../../chart/helper/LineDraw\");\n\nvar MarkerView = require(\"./MarkerView\");\n\nvar markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n  var data = seriesModel.getData(); // Special type markLine like 'min', 'max', 'average'\n\n  var mlType = item.type;\n\n  if (!zrUtil.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average' // In case\n  // data: [{\n  //   yAxis: 10\n  // }]\n  || item.xAxis != null || item.yAxis != null)) {\n    var valueAxis;\n    var valueDataDim;\n    var value;\n\n    if (item.yAxis != null || item.xAxis != null) {\n      valueDataDim = item.yAxis != null ? 'y' : 'x';\n      valueAxis = coordSys.getAxis(valueDataDim);\n      value = zrUtil.retrieve(item.yAxis, item.xAxis);\n    } else {\n      var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);\n      valueDataDim = axisInfo.valueDataDim;\n      valueAxis = axisInfo.valueAxis;\n      value = markerHelper.numCalculate(data, valueDataDim, mlType);\n    }\n\n    var valueIndex = valueDataDim === 'x' ? 0 : 1;\n    var baseIndex = 1 - valueIndex;\n    var mlFrom = zrUtil.clone(item);\n    var mlTo = {};\n    mlFrom.type = null;\n    mlFrom.coord = [];\n    mlTo.coord = [];\n    mlFrom.coord[baseIndex] = -Infinity;\n    mlTo.coord[baseIndex] = Infinity;\n    var precision = mlModel.get('precision');\n\n    if (precision >= 0 && typeof value === 'number') {\n      value = +value.toFixed(Math.min(precision, 20));\n    }\n\n    mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n    item = [mlFrom, mlTo, {\n      // Extra option for tooltip and label\n      type: mlType,\n      valueIndex: item.valueIndex,\n      // Force to use the value of calculated value.\n      value: value\n    }];\n  }\n\n  item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2])]; // Avoid line data type is extended by from(to) data type\n\n  item[2].type = item[2].type || ''; // Merge from option and to option into line option\n\n  zrUtil.merge(item[2], item[0]);\n  zrUtil.merge(item[2], item[1]);\n  return item;\n};\n\nfunction isInifinity(val) {\n  return !isNaN(val) && !isFinite(val);\n} // If a markLine has one dim\n\n\nfunction ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  var dimName = coordSys.dimensions[dimIndex];\n  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n}\n\nfunction markLineFilter(coordSys, item) {\n  if (coordSys.type === 'cartesian2d') {\n    var fromCoord = item[0].coord;\n    var toCoord = item[1].coord; // In case\n    // {\n    //  markLine: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n\n    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    }\n  }\n\n  return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);\n}\n\nfunction updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n  var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPoisition\n      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));\n    } else {\n      var dims = coordSys.dimensions;\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      point = coordSys.dataToPoint([x, y]);\n    } // Expand line to the edge of grid if value on one axis is Inifnity\n    // In case\n    //  markLine: {\n    //    data: [{\n    //      yAxis: 2\n    //      // or\n    //      type: 'average'\n    //    }]\n    //  }\n\n\n    if (coordSys.type === 'cartesian2d') {\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var dims = coordSys.dimensions;\n\n      if (isInifinity(data.get(dims[0], idx))) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n      } else if (isInifinity(data.get(dims[1], idx))) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n      }\n    } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n\n  data.setItemLayout(idx, point);\n}\n\nvar _default = MarkerView.extend({\n  type: 'markLine',\n  updateLayout: function (markLineModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mlModel = seriesModel.markLineModel;\n\n      if (mlModel) {\n        var mlData = mlModel.getData();\n        var fromData = mlModel.__from;\n        var toData = mlModel.__to; // Update visual and layout of from symbol and to symbol\n\n        fromData.each(function (idx) {\n          updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);\n          updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);\n        }); // Update layout of line\n\n        mlData.each(function (idx) {\n          mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);\n        });\n        this.markerGroupMap.get(seriesModel.id).updateLayout();\n      }\n    }, this);\n  },\n  renderSeries: function (seriesModel, mlModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var lineDrawMap = this.markerGroupMap;\n    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());\n    this.group.add(lineDraw.group);\n    var mlData = createList(coordSys, seriesModel, mlModel);\n    var fromData = mlData.from;\n    var toData = mlData.to;\n    var lineData = mlData.line;\n    mlModel.__from = fromData;\n    mlModel.__to = toData; // Line data for tooltip and formatter\n\n    mlModel.setData(lineData);\n    var symbolType = mlModel.get('symbol');\n    var symbolSize = mlModel.get('symbolSize');\n\n    if (!zrUtil.isArray(symbolType)) {\n      symbolType = [symbolType, symbolType];\n    }\n\n    if (typeof symbolSize === 'number') {\n      symbolSize = [symbolSize, symbolSize];\n    } // Update visual and layout of from symbol and to symbol\n\n\n    mlData.from.each(function (idx) {\n      updateDataVisualAndLayout(fromData, idx, true);\n      updateDataVisualAndLayout(toData, idx, false);\n    }); // Update visual and layout of line\n\n    lineData.each(function (idx) {\n      var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color');\n      lineData.setItemVisual(idx, {\n        color: lineColor || fromData.getItemVisual(idx, 'color')\n      });\n      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);\n      lineData.setItemVisual(idx, {\n        'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),\n        'fromSymbol': fromData.getItemVisual(idx, 'symbol'),\n        'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),\n        'toSymbol': toData.getItemVisual(idx, 'symbol')\n      });\n    });\n    lineDraw.updateData(lineData); // Set host model for tooltip\n    // FIXME\n\n    mlData.line.eachItemGraphicEl(function (el, idx) {\n      el.traverse(function (child) {\n        child.dataModel = mlModel;\n      });\n    });\n\n    function updateDataVisualAndLayout(data, idx, isFrom) {\n      var itemModel = data.getItemModel(idx);\n      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);\n      data.setItemVisual(idx, {\n        symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],\n        symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],\n        color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color')\n      });\n    }\n\n    lineDraw.__keep = true;\n    lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n  }\n});\n/**\n * @inner\n * @param {module:echarts/coord/*} coordSys\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\n\n\nfunction createList(coordSys, seriesModel, mlModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      info.name = coordDim;\n      return info;\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var fromData = new List(coordDimsInfos, mlModel);\n  var toData = new List(coordDimsInfos, mlModel); // No dimensions\n\n  var lineData = new List([], mlModel);\n  var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));\n\n  if (coordSys) {\n    optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));\n  }\n\n  var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {\n    return item.value;\n  };\n  fromData.initData(zrUtil.map(optData, function (item) {\n    return item[0];\n  }), null, dimValueGetter);\n  toData.initData(zrUtil.map(optData, function (item) {\n    return item[1];\n  }), null, dimValueGetter);\n  lineData.initData(zrUtil.map(optData, function (item) {\n    return item[2];\n  }));\n  lineData.hasItemOption = true;\n  return {\n    from: fromData,\n    to: toData,\n    line: lineData\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/marker/MarkLineView.js\n// module id = 669\n// module chunks = 44","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar addCommas = formatUtil.addCommas;\nvar encodeHTML = formatUtil.encodeHTML;\n\nfunction fillLabel(opt) {\n  modelUtil.defaultEmphasis(opt.label, ['show']);\n}\n\nvar MarkerModel = echarts.extendComponentModel({\n  type: 'marker',\n  dependencies: ['series', 'grid', 'polar', 'geo'],\n\n  /**\n   * @overrite\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var hostSeries = this.__hostSeries;\n    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n  },\n  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n    var MarkerModel = this.constructor;\n    var modelPropName = this.mainType + 'Model';\n\n    if (!createdBySelf) {\n      ecModel.eachSeries(function (seriesModel) {\n        var markerOpt = seriesModel.get(this.mainType);\n        var markerModel = seriesModel[modelPropName];\n\n        if (!markerOpt || !markerOpt.data) {\n          seriesModel[modelPropName] = null;\n          return;\n        }\n\n        if (!markerModel) {\n          if (isInit) {\n            // Default label emphasis `position` and `show`\n            fillLabel(markerOpt);\n          }\n\n          zrUtil.each(markerOpt.data, function (item) {\n            // FIXME Overwrite fillLabel method ?\n            if (item instanceof Array) {\n              fillLabel(item[0]);\n              fillLabel(item[1]);\n            } else {\n              fillLabel(item);\n            }\n          });\n          markerModel = new MarkerModel(markerOpt, this, ecModel);\n          zrUtil.extend(markerModel, {\n            mainType: this.mainType,\n            // Use the same series index and name\n            seriesIndex: seriesModel.seriesIndex,\n            name: seriesModel.name,\n            createdBySelf: true\n          });\n          markerModel.__hostSeries = seriesModel;\n        } else {\n          markerModel.mergeOption(markerOpt, ecModel, true);\n        }\n\n        seriesModel[modelPropName] = markerModel;\n      }, this);\n    }\n  },\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n    var name = data.getName(dataIndex);\n    var html = encodeHTML(this.name);\n\n    if (value != null || name) {\n      html += '<br />';\n    }\n\n    if (name) {\n      html += encodeHTML(name);\n\n      if (value != null) {\n        html += ' : ';\n      }\n    }\n\n    if (value != null) {\n      html += encodeHTML(formattedValue);\n    }\n\n    return html;\n  },\n  getData: function () {\n    return this._data;\n  },\n  setData: function (data) {\n    this._data = data;\n  }\n});\nzrUtil.mixin(MarkerModel, modelUtil.dataFormatMixin);\nvar _default = MarkerModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/marker/MarkerModel.js\n// module id = 670\n// module chunks = 44","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _default = echarts.extendComponentView({\n  type: 'marker',\n  init: function () {\n    /**\n     * Markline grouped by series\n     * @private\n     * @type {module:zrender/core/util.HashMap}\n     */\n    this.markerGroupMap = zrUtil.createHashMap();\n  },\n  render: function (markerModel, ecModel, api) {\n    var markerGroupMap = this.markerGroupMap;\n    markerGroupMap.each(function (item) {\n      item.__keep = false;\n    });\n    var markerModelKey = this.type + 'Model';\n    ecModel.eachSeries(function (seriesModel) {\n      var markerModel = seriesModel[markerModelKey];\n      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n    }, this);\n    markerGroupMap.each(function (item) {\n      !item.__keep && this.group.remove(item.group);\n    }, this);\n  },\n  renderSeries: function () {}\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/marker/MarkerView.js\n// module id = 671\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n}\n\nfunction getPrecision(data, valueAxisDim, dataIndex) {\n  var precision = -1;\n\n  do {\n    precision = Math.max(numberUtil.getPrecision(data.get(valueAxisDim, dataIndex)), precision);\n    data = data.stackedOn;\n  } while (data);\n\n  return precision;\n}\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var value = numCalculate(data, targetDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(targetDataDim, value, true)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);\n  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);\n  var precision = getPrecision(data, targetDataDim, dataIndex);\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return coordArr;\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.\n\n      item.value = item.coord[targetCoordIndex];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];\n          coord[i] = numCalculate(data, dataDim, coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n    ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];\n  }\n\n  return ret;\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    }, true);\n    return sum / count;\n  } else {\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/component/marker/markerHelper.js\n// module id = 672\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar List = require(\"./List\");\n\nvar linkList = require(\"./helper/linkList\");\n\nvar completeDimensions = require(\"./helper/completeDimensions\");\n\n/**\n * Tree data structure\n *\n * @module echarts/data/Tree\n */\n\n/**\n * @constructor module:echarts/data/Tree~TreeNode\n * @param {string} name\n * @param {module:echarts/data/Tree} hostTree\n */\nvar TreeNode = function (name, hostTree) {\n  /**\n   * @type {string}\n   */\n  this.name = name || '';\n  /**\n   * Depth of node\n   *\n   * @type {number}\n   * @readOnly\n   */\n\n  this.depth = 0;\n  /**\n   * Height of the subtree rooted at this node.\n   * @type {number}\n   * @readOnly\n   */\n\n  this.height = 0;\n  /**\n   * @type {module:echarts/data/Tree~TreeNode}\n   * @readOnly\n   */\n\n  this.parentNode = null;\n  /**\n   * Reference to list item.\n   * Do not persistent dataIndex outside,\n   * besause it may be changed by list.\n   * If dataIndex -1,\n   * this node is logical deleted (filtered) in list.\n   *\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.dataIndex = -1;\n  /**\n   * @type {Array.<module:echarts/data/Tree~TreeNode>}\n   * @readOnly\n   */\n\n  this.children = [];\n  /**\n   * @type {Array.<module:echarts/data/Tree~TreeNode>}\n   * @pubilc\n   */\n\n  this.viewChildren = [];\n  /**\n   * @type {moduel:echarts/data/Tree}\n   * @readOnly\n   */\n\n  this.hostTree = hostTree;\n};\n\nTreeNode.prototype = {\n  constructor: TreeNode,\n\n  /**\n   * The node is removed.\n   * @return {boolean} is removed.\n   */\n  isRemoved: function () {\n    return this.dataIndex < 0;\n  },\n\n  /**\n   * Travel this subtree (include this node).\n   * Usage:\n   *    node.eachNode(function () { ... }); // preorder\n   *    node.eachNode('preorder', function () { ... }); // preorder\n   *    node.eachNode('postorder', function () { ... }); // postorder\n   *    node.eachNode(\n   *        {order: 'postorder', attr: 'viewChildren'},\n   *        function () { ... }\n   *    ); // postorder\n   *\n   * @param {(Object|string)} options If string, means order.\n   * @param {string=} options.order 'preorder' or 'postorder'\n   * @param {string=} options.attr 'children' or 'viewChildren'\n   * @param {Function} cb If in preorder and return false,\n   *                      its subtree will not be visited.\n   * @param {Object} [context]\n   */\n  eachNode: function (options, cb, context) {\n    if (typeof options === 'function') {\n      context = cb;\n      cb = options;\n      options = null;\n    }\n\n    options = options || {};\n\n    if (zrUtil.isString(options)) {\n      options = {\n        order: options\n      };\n    }\n\n    var order = options.order || 'preorder';\n    var children = this[options.attr || 'children'];\n    var suppressVisitSub;\n    order === 'preorder' && (suppressVisitSub = cb.call(context, this));\n\n    for (var i = 0; !suppressVisitSub && i < children.length; i++) {\n      children[i].eachNode(options, cb, context);\n    }\n\n    order === 'postorder' && cb.call(context, this);\n  },\n\n  /**\n   * Update depth and height of this subtree.\n   *\n   * @param  {number} depth\n   */\n  updateDepthAndHeight: function (depth) {\n    var height = 0;\n    this.depth = depth;\n\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      child.updateDepthAndHeight(depth + 1);\n\n      if (child.height > height) {\n        height = child.height;\n      }\n    }\n\n    this.height = height + 1;\n  },\n\n  /**\n   * @param  {string} id\n   * @return {module:echarts/data/Tree~TreeNode}\n   */\n  getNodeById: function (id) {\n    if (this.getId() === id) {\n      return this;\n    }\n\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].getNodeById(id);\n\n      if (res) {\n        return res;\n      }\n    }\n  },\n\n  /**\n   * @param {module:echarts/data/Tree~TreeNode} node\n   * @return {boolean}\n   */\n  contains: function (node) {\n    if (node === this) {\n      return true;\n    }\n\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].contains(node);\n\n      if (res) {\n        return res;\n      }\n    }\n  },\n\n  /**\n   * @param {boolean} includeSelf Default false.\n   * @return {Array.<module:echarts/data/Tree~TreeNode>} order: [root, child, grandchild, ...]\n   */\n  getAncestors: function (includeSelf) {\n    var ancestors = [];\n    var node = includeSelf ? this : this.parentNode;\n\n    while (node) {\n      ancestors.push(node);\n      node = node.parentNode;\n    }\n\n    ancestors.reverse();\n    return ancestors;\n  },\n\n  /**\n   * @param {string|Array=} [dimension='value'] Default 'value'. can be 0, 1, 2, 3\n   * @return {number} Value.\n   */\n  getValue: function (dimension) {\n    var data = this.hostTree.data;\n    return data.get(data.getDimension(dimension || 'value'), this.dataIndex);\n  },\n\n  /**\n   * @param {Object} layout\n   * @param {boolean=} [merge=false]\n   */\n  setLayout: function (layout, merge) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);\n  },\n\n  /**\n   * @return {Object} layout\n   */\n  getLayout: function () {\n    return this.hostTree.data.getItemLayout(this.dataIndex);\n  },\n\n  /**\n   * @param {string} [path]\n   * @return {module:echarts/model/Model}\n   */\n  getModel: function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n\n    var hostTree = this.hostTree;\n    var itemModel = hostTree.data.getItemModel(this.dataIndex);\n    var levelModel = this.getLevelModel();\n    var leavesModel;\n\n    if (!levelModel && (this.children.length === 0 || this.children.length !== 0 && this.isExpand === false)) {\n      leavesModel = this.getLeavesModel();\n    }\n\n    return itemModel.getModel(path, (levelModel || leavesModel || hostTree.hostModel).getModel(path));\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getLevelModel: function () {\n    return (this.hostTree.levelModels || [])[this.depth];\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getLeavesModel: function () {\n    return this.hostTree.leavesModel;\n  },\n\n  /**\n   * @example\n   *  setItemVisual('color', color);\n   *  setItemVisual({\n   *      'color': color\n   *  });\n   */\n  setVisual: function (key, value) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);\n  },\n\n  /**\n   * Get item visual\n   */\n  getVisual: function (key, ignoreParent) {\n    return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent);\n  },\n\n  /**\n   * @public\n   * @return {number}\n   */\n  getRawIndex: function () {\n    return this.hostTree.data.getRawIndex(this.dataIndex);\n  },\n\n  /**\n   * @public\n   * @return {string}\n   */\n  getId: function () {\n    return this.hostTree.data.getId(this.dataIndex);\n  }\n};\n/**\n * @constructor\n * @alias module:echarts/data/Tree\n * @param {module:echarts/model/Model} hostModel\n * @param {Array.<Object>} levelOptions\n * @param {Object} leavesOption\n */\n\nfunction Tree(hostModel, levelOptions, leavesOption) {\n  /**\n   * @type {module:echarts/data/Tree~TreeNode}\n   * @readOnly\n   */\n  this.root;\n  /**\n   * @type {module:echarts/data/List}\n   * @readOnly\n   */\n\n  this.data;\n  /**\n   * Index of each item is the same as the raw index of coresponding list item.\n   * @private\n   * @type {Array.<module:echarts/data/Tree~TreeNode}\n   */\n\n  this._nodes = [];\n  /**\n   * @private\n   * @readOnly\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @private\n   * @readOnly\n   * @type {Array.<module:echarts/model/Model}\n   */\n\n  this.levelModels = zrUtil.map(levelOptions || [], function (levelDefine) {\n    return new Model(levelDefine, hostModel, hostModel.ecModel);\n  });\n  this.leavesModel = new Model(leavesOption || {}, hostModel, hostModel.ecModel);\n}\n\nTree.prototype = {\n  constructor: Tree,\n  type: 'tree',\n\n  /**\n   * Travel this subtree (include this node).\n   * Usage:\n   *    node.eachNode(function () { ... }); // preorder\n   *    node.eachNode('preorder', function () { ... }); // preorder\n   *    node.eachNode('postorder', function () { ... }); // postorder\n   *    node.eachNode(\n   *        {order: 'postorder', attr: 'viewChildren'},\n   *        function () { ... }\n   *    ); // postorder\n   *\n   * @param {(Object|string)} options If string, means order.\n   * @param {string=} options.order 'preorder' or 'postorder'\n   * @param {string=} options.attr 'children' or 'viewChildren'\n   * @param {Function} cb\n   * @param {Object}   [context]\n   */\n  eachNode: function (options, cb, context) {\n    this.root.eachNode(options, cb, context);\n  },\n\n  /**\n   * @param {number} dataIndex\n   * @return {module:echarts/data/Tree~TreeNode}\n   */\n  getNodeByDataIndex: function (dataIndex) {\n    var rawIndex = this.data.getRawIndex(dataIndex);\n    return this._nodes[rawIndex];\n  },\n\n  /**\n   * @param {string} name\n   * @return {module:echarts/data/Tree~TreeNode}\n   */\n  getNodeByName: function (name) {\n    return this.root.getNodeByName(name);\n  },\n\n  /**\n   * Update item available by list,\n   * when list has been performed options like 'filterSelf' or 'map'.\n   */\n  update: function () {\n    var data = this.data;\n    var nodes = this._nodes;\n\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n  },\n\n  /**\n   * Clear all layouts\n   */\n  clearLayouts: function () {\n    this.data.clearItemLayouts();\n  }\n};\n/**\n * data node format:\n * {\n *     name: ...\n *     value: ...\n *     children: [\n *         {\n *             name: ...\n *             value: ...\n *             children: ...\n *         },\n *         ...\n *     ]\n * }\n *\n * @static\n * @param {Object} dataRoot Root node.\n * @param {module:echarts/model/Model} hostModel\n * @param {Object} treeOptions\n * @param {Array.<Object>} treeOptions.levels\n * @param {Array.<Object>} treeOptions.leaves\n * @return module:echarts/data/Tree\n */\n\nTree.createTree = function (dataRoot, hostModel, treeOptions) {\n  var tree = new Tree(hostModel, treeOptions.levels, treeOptions.leaves);\n  var listData = [];\n  var dimMax = 1;\n  buildHierarchy(dataRoot);\n\n  function buildHierarchy(dataNode, parentNode) {\n    var value = dataNode.value;\n    dimMax = Math.max(dimMax, zrUtil.isArray(value) ? value.length : 1);\n    listData.push(dataNode);\n    var node = new TreeNode(dataNode.name, tree);\n    parentNode ? addChild(node, parentNode) : tree.root = node;\n\n    tree._nodes.push(node);\n\n    var children = dataNode.children;\n\n    if (children) {\n      for (var i = 0; i < children.length; i++) {\n        buildHierarchy(children[i], node);\n      }\n    }\n  }\n\n  tree.root.updateDepthAndHeight(0);\n  var dimensions = completeDimensions([{\n    name: 'value'\n  }], listData, {\n    dimCount: dimMax\n  });\n  var list = new List(dimensions, hostModel);\n  list.initData(listData);\n  linkList({\n    mainData: list,\n    struct: tree,\n    structAttr: 'tree'\n  });\n  tree.update();\n  return tree;\n};\n/**\n * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,\n * so this function is not ready and not necessary to be public.\n *\n * @param {(module:echarts/data/Tree~TreeNode|Object)} child\n */\n\n\nfunction addChild(child, node) {\n  var children = node.children;\n\n  if (child.parentNode === node) {\n    return;\n  }\n\n  children.push(child);\n  child.parentNode = node;\n}\n\nvar _default = Tree;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/data/Tree.js\n// module id = 673\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Link lists and struct (graph or tree)\n */\nvar each = zrUtil.each;\nvar DATAS = '\\0__link_datas';\nvar MAIN_DATA = '\\0__link_mainData'; // Caution:\n// In most case, either list or its shallow clones (see list.cloneShallow)\n// is active in echarts process. So considering heap memory consumption,\n// we do not clone tree or graph, but share them among list and its shallow clones.\n// But in some rare case, we have to keep old list (like do animation in chart). So\n// please take care that both the old list and the new list share the same tree/graph.\n\n/**\n * @param {Object} opt\n * @param {module:echarts/data/List} opt.mainData\n * @param {Object} [opt.struct] For example, instance of Graph or Tree.\n * @param {string} [opt.structAttr] designation: list[structAttr] = struct;\n * @param {Object} [opt.datas] {dataType: data},\n *                 like: {node: nodeList, edge: edgeList}.\n *                 Should contain mainData.\n * @param {Object} [opt.datasAttr] {dataType: attr},\n *                 designation: struct[datasAttr[dataType]] = list;\n */\n\nfunction linkList(opt) {\n  var mainData = opt.mainData;\n  var datas = opt.datas;\n\n  if (!datas) {\n    datas = {\n      main: mainData\n    };\n    opt.datasAttr = {\n      main: 'data'\n    };\n  }\n\n  opt.datas = opt.mainData = null;\n  linkAll(mainData, datas, opt); // Porxy data original methods.\n\n  each(datas, function (data) {\n    each(mainData.TRANSFERABLE_METHODS, function (methodName) {\n      data.wrapMethod(methodName, zrUtil.curry(transferInjection, opt));\n    });\n  }); // Beyond transfer, additional features should be added to `cloneShallow`.\n\n  mainData.wrapMethod('cloneShallow', zrUtil.curry(cloneShallowInjection, opt)); // Only mainData trigger change, because struct.update may trigger\n  // another changable methods, which may bring about dead lock.\n\n  each(mainData.CHANGABLE_METHODS, function (methodName) {\n    mainData.wrapMethod(methodName, zrUtil.curry(changeInjection, opt));\n  }); // Make sure datas contains mainData.\n\n  zrUtil.assert(datas[mainData.dataType] === mainData);\n}\n\nfunction transferInjection(opt, res) {\n  if (isMainData(this)) {\n    // Transfer datas to new main data.\n    var datas = zrUtil.extend({}, this[DATAS]);\n    datas[this.dataType] = res;\n    linkAll(res, datas, opt);\n  } else {\n    // Modify the reference in main data to point newData.\n    linkSingle(res, this.dataType, this[MAIN_DATA], opt);\n  }\n\n  return res;\n}\n\nfunction changeInjection(opt, res) {\n  opt.struct && opt.struct.update(this);\n  return res;\n}\n\nfunction cloneShallowInjection(opt, res) {\n  // cloneShallow, which brings about some fragilities, may be inappropriate\n  // to be exposed as an API. So for implementation simplicity we can make\n  // the restriction that cloneShallow of not-mainData should not be invoked\n  // outside, but only be invoked here.\n  each(res[DATAS], function (data, dataType) {\n    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);\n  });\n  return res;\n}\n/**\n * Supplement method to List.\n *\n * @public\n * @param {string} [dataType] If not specified, return mainData.\n * @return {module:echarts/data/List}\n */\n\n\nfunction getLinkedData(dataType) {\n  var mainData = this[MAIN_DATA];\n  return dataType == null || mainData == null ? mainData : mainData[DATAS][dataType];\n}\n\nfunction isMainData(data) {\n  return data[MAIN_DATA] === data;\n}\n\nfunction linkAll(mainData, datas, opt) {\n  mainData[DATAS] = {};\n  each(datas, function (data, dataType) {\n    linkSingle(data, dataType, mainData, opt);\n  });\n}\n\nfunction linkSingle(data, dataType, mainData, opt) {\n  mainData[DATAS][dataType] = data;\n  data[MAIN_DATA] = mainData;\n  data.dataType = dataType;\n\n  if (opt.struct) {\n    data[opt.structAttr] = opt.struct;\n    opt.struct[opt.datasAttr[dataType]] = data;\n  } // Supplement method.\n\n\n  data.getLinkedData = getLinkedData;\n}\n\nvar _default = linkList;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/data/helper/linkList.js\n// module id = 674\n// module chunks = 44","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * @param {number} [time=500] Time in ms\n * @param {string} [easing='linear']\n * @param {number} [delay=0]\n * @param {Function} [callback]\n *\n * @example\n *  // Animate position\n *  animation\n *      .createWrap()\n *      .add(el1, {position: [10, 10]})\n *      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)\n *      .done(function () { // done })\n *      .start('cubicOut');\n */\nfunction createWrap() {\n  var storage = [];\n  var elExistsMap = {};\n  var doneCallback;\n  return {\n    /**\n     * Caution: a el can only be added once, otherwise 'done'\n     * might not be called. This method checks this (by el.id),\n     * suppresses adding and returns false when existing el found.\n     *\n     * @param {modele:zrender/Element} el\n     * @param {Object} target\n     * @param {number} [time=500]\n     * @param {number} [delay=0]\n     * @param {string} [easing='linear']\n     * @return {boolean} Whether adding succeeded.\n     *\n     * @example\n     *     add(el, target, time, delay, easing);\n     *     add(el, target, time, easing);\n     *     add(el, target, time);\n     *     add(el, target);\n     */\n    add: function (el, target, time, delay, easing) {\n      if (zrUtil.isString(delay)) {\n        easing = delay;\n        delay = 0;\n      }\n\n      if (elExistsMap[el.id]) {\n        return false;\n      }\n\n      elExistsMap[el.id] = 1;\n      storage.push({\n        el: el,\n        target: target,\n        time: time,\n        delay: delay,\n        easing: easing\n      });\n      return true;\n    },\n\n    /**\n     * Only execute when animation finished. Will not execute when any\n     * of 'stop' or 'stopAnimation' called.\n     *\n     * @param {Function} callback\n     */\n    done: function (callback) {\n      doneCallback = callback;\n      return this;\n    },\n\n    /**\n     * Will stop exist animation firstly.\n     */\n    start: function () {\n      var count = storage.length;\n\n      for (var i = 0, len = storage.length; i < len; i++) {\n        var item = storage[i];\n        item.el.animateTo(item.target, item.time, item.delay, item.easing, done);\n      }\n\n      return this;\n\n      function done() {\n        count--;\n\n        if (!count) {\n          storage.length = 0;\n          elExistsMap = {};\n          doneCallback && doneCallback();\n        }\n      }\n    }\n  };\n}\n\nexports.createWrap = createWrap;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_echarts@3.8.5@echarts/lib/util/animation.js\n// module id = 675\n// module chunks = 44"],"sourceRoot":""}